# Dijkstra? (ID: H5-01)

## 一、问题描述

> **【问题描述】**
> 
> 给定一个含权的无向图，顶点编号为1~n，你的任务为找出顶点1到顶点 n 之间的最短路径。
> 
> **【输入形式】**
> 
> 输入的第一行为两个整数 n 和 m (2 ≤ n ≤ 10^5, 0 ≤ m ≤ 10^5)，其中 n 为顶点数，m 是边数。
> 
> 接下来的 m 行包含用形式 ai、bi 和 wi (1≤ai、bi ≤n，1≤ wi ≤ 10^6)，这里ai、bi 是边的端点，而 wi 是边的长度。
> 
> 该图可能包括环，或者一对顶点之间包含多条边。
> 
> **【输出形式】**
> 
> 如果无路径，输出-1，否则输出最短路径，如果有多个，则输出字典序最小的路径。
> 
> 对于两个整数序列 A (a1、a2、...)和 B (b1、b2、...)，称序列 A 字典序小于序列 B 当且仅当，存在 k ≥ 1，i <k 时，ai = bi，i =k 时，ai < bi 。
> 
> **【样例输入】**
> 
> ```
> 5 6
> 1 2 2
> 2 5 5
> 2 3 4
> 1 4 1
> 4 3 3
> 3 5 1
> ```
> 
> **【样例输出】**
> 
> ```
> 1 4 3 5
> ```

## 二、问题分析与边界条件

**问题核心**: 本题要求在一个含权的无向图中，找出从顶点1到顶点n的最短路径。当存在多条长度相同的最短路径时，需要输出节点序列字典序最小的那一条。

**思路拆解**: 直接在Dijkstra算法的松弛操作中加入字典序的判断是行不通的，因为局部的字典序最优选择无法保证全局路径的字典序最优。为了解决这个问题，我们可以将问题分解为以下三个步骤：

1. **计算最短路径长度**: 首先，我们需要确定从顶点1到顶点n的最短路径长度到底是多少。
    
2. **筛选有效路径**: 在确定了最短路径长度后，我们需要一种方法来判断图中的任意一条边(u, v)是否存在于某条最短路径上。
    
3. **构建字典序最小路径**: 在所有满足最短路径长度的边构成的子图中，从起点1开始，通过贪心策略构建出一条字典序最小的路径。
    

**边界条件**:

1. **路径不存在**: 顶点1与顶点n之间可能不连通。此时，无法找到路径，应输出-1。代码中通过判断最短路径长度是否为无穷大（`INF`）来处理。
    
2. **图的特性**: 题目明确指出图可能包含环或重边。我们使用邻接表和优先队列实现的Dijkstra算法可以正确处理这些情况。
    
3. **数据规模**: 顶点数 `n` 和边数 `m` 可达 10^5，需要使用时间复杂度较低的算法，如堆优化的Dijkstra（O(M log N)）。同时，路径长度可能超过32位整型范围，需要使用 `long long` 类型来存储距离。
    

## 三、算法设计

**核心思想**: 本解决方案采用“**正向Dijkstra + 反向Dijkstra + 贪心构造**”的策略，将问题完美分解。

1. **正向Dijkstra**: 从起点 `1` 出发，运行一次Dijkstra算法，计算出起点到所有其他节点的最短距离 `distFromSource`。这样我们就得到了 `1->n` 的最短路径总长度 `shortestPathLength`。
    
2. **反向Dijkstra**: 从终点 `n` 出发，在反向图（对于无向图即原图）上运行一次Dijkstra算法，计算出所有节点到终点 `n` 的最短距离 `distToDest`。
    
3. **贪心路径构建**: 有了以上两个距离数组，我们可以精确地判断任意一条边 `(u, v)` 是否位于某条 `1->n` 的最短路径上。其充要条件是：`distFromSource[u] + weight(u, v) + distToDest[v] == shortestPathLength`。基于此，我们从起点 `1` 开始，每一步都贪心地选择满足该条件的、且节点编号最小的邻居作为路径的下一个节点，直到到达终点 `n`。这个贪心策略是正确的，因为它在每一步都保证了路径的局部字典序最小，同时又不偏离任何一条最短路径。
    

**数据结构**:

- `vector<vector<Edge>> adj`: 使用邻接表存储图。`Edge` 是一个 `pair<int, int>`，表示 `{邻居节点, 边权重}`。邻接表适合存储稀疏图。
    
- `priority_queue<State>`: 使用最小优先队列（小顶堆）来实现Dijkstra算法的核心部分，用于高效地获取当前距离最小的待处理节点。`State` 是一个 `pair<long long, int>`，表示 `{距离, 节点编号}`。
    
- `vector<long long> distFromSource`, `vector<long long> distToDest`: 两个长整型数组，分别存储正向和反向Dijkstra算法计算出的最短距离。
    

**算法流程**:

1. 读取 `n` 和 `m`，并构建邻接表 `adj` 来表示图。由于是无向图，反向图与原图相同。
    
2. 调用 `dijkstra(1, n, adj)`，从起点1开始计算，结果存入 `distFromSource`。
    
3. 检查 `distFromSource[n]`。如果为无穷大，说明1和n不连通，输出-1并结束程序。否则，将其值赋给 `shortestPathLength`。
    
4. 调用 `dijkstra(n, n, adj)`，从终点n开始计算，结果存入 `distToDest`。
    
5. 初始化路径 `path`，并将起点1加入。设置 `currentNode = 1`。
    
6. 进入循环，只要 `currentNode` 不等于终点 `n`： a. 遍历 `currentNode` 的所有邻居 `neighbor`。 b. 对于每个邻居，检查是否满足最短路径条件：`distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength`。 c. 在所有满足条件的邻居中，找到节点编号最小的一个，记为 `nextNode`。 d. 将 `nextNode` 加入 `path`，并更新 `currentNode = nextNode`。
    
7. 循环结束后，`path` 中存储的就是字典序最小的最短路径。遍历并输出 `path` 中的所有节点。
    

## 四、核心代码讲解

**1. Dijkstra 算法通用实现**

```
vector<long long> dijkstra(int startNode, int n, const vector<vector<Edge>>& adj) {
    vector<long long> dist(n + 1, INF);
    priority_queue<State, vector<State>, greater<State>> pq;

    dist[startNode] = 0;
    pq.push({0, startNode});

    while (!pq.empty()) {
        long long currentDist = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (currentDist > dist[u]) {
            continue;
        }

        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
```

- **功能**: 这是一个标准的堆优化Dijkstra算法模板。输入起点、节点总数和图的邻接表，返回一个包含起点到所有节点最短距离的数组。
    
- **`dist`数组**: 初始化为无穷大`INF`，`dist[i]`记录起点到节点`i`的当前最短距离。
    
- **`priority_queue`**: `pq`是一个小顶堆，存储`{距离, 节点}`对，距离小的元素会被优先置于堆顶。
    
- **`dist[startNode] = 0`**: 起点到自身的距离为0，并将其入队作为算法的开端。
    
- **`while (!pq.empty())`**: 循环直到所有可达节点都被访问。
    
- **`if (currentDist > dist[u])`**: 一个重要的优化。如果从队列中取出的距离 `currentDist` 大于 `dist[u]` 中记录的距离，说明这是一个过时的、较长的路径信息，直接跳过。
    
- **松弛操作**: `if (dist[u] + weight < dist[v])`是核心的松弛操作。如果通过当前节点`u`可以找到一条到达邻居`v`的更短路径，则更新`dist[v]`并把新的状态`{dist[v], v}`压入优先队列。
    

**2. 贪心构建路径**

```
vector<int> path;
int currentNode = 1;
path.push_back(currentNode);

while (currentNode != n) {
    int nextNode = -1;
    // 遍历当前节点的所有邻居，寻找最优的下一个节点
    for (const auto& edge : adj[currentNode]) {
        int neighbor = edge.first;
        int weight = edge.second;

        // 检查该邻居是否在某条最短路径上
        if (distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength) {
            // 在所有有效的邻居中，选择编号最小的
            if (nextNode == -1 || neighbor < nextNode) {
                nextNode = neighbor;
            }
        }
    }
    // 移动到选择的下一个节点
    currentNode = nextNode;
    path.push_back(currentNode);
}
```

- **功能**: 这段代码实现了算法的第三步，即在确定了最短路径上的所有“合法”边之后，贪心地构建出字典序最小的路径。
    
- **`while (currentNode != n)`**: 循环从起点1开始，直到到达终点n为止。
    
- **`nextNode = -1`**: 在每一步迭代开始时，用于记录下一个节点的候选者，初始化为-1。
    
- **`if (distFromSource[...] == shortestPathLength)`**: 这是路径构建的关键判断。它利用预先计算好的两个距离数组，确保选择的边`(currentNode, neighbor)`一定位于某条从1到n的最短路径上。
    
- **`if (nextNode == -1 || neighbor < nextNode)`**: 这个判断实现了贪心选择。在所有“合法”的邻居中，选择节点编号最小的一个作为`nextNode`。
    
- **`path.push_back(currentNode)`**: 将选出的最优节点加入最终路径。
    

## 五、复杂度分析

**时间复杂度: O(M log N)**

- 算法的主体是两次独立的Dijkstra算法调用。
    
- 每一次堆优化的Dijkstra算法中，每个顶点最多入队一次，每条边最多被访问一次（对于无向图是两次）。
    
- 优先队列的操作（插入`push`和提取最小`pop`）的时间复杂度为 `O(log V)`，其中 `V` 是队列中的元素数量，最多为 `N`。
    
- 因此，单次Dijkstra的时间复杂度为 `O(M log N)`。
    
- 两次Dijkstra的总时间复杂度为 `2 * O(M log N)`，即 `O(M log N)`。
    
- 最后构建路径的步骤，最多遍历所有边一次，时间复杂度为 `O(N + M)`。
    
- 综上，算法的瓶颈在于Dijkstra，总时间复杂度为 `O(M log N)`。
    

**空间复杂度: O(N + M)**

- 存储图的邻接表 `adj` 和 `adjRev` 需要 `O(N + M)` 的空间。
    
- 两个距离数组 `distFromSource` 和 `distToDest` 分别需要 `O(N)` 的空间。
    
- Dijkstra算法中的优先队列在最坏情况下可能存储 `N` 个节点，需要 `O(N)` 的空间。
    
- 存储最终路径的 `path` 向量最多存储 `N` 个节点，需要 `O(N)` 的空间。
    
- 因此，总的空间复杂度为 `O(N + M)`。
    

## 六、总结与反思

**方法总结**: 本题是经典Dijkstra算法的一个巧妙变种，它考察了如何在满足最短路径约束的同时，优化第二个维度（字典序）。核心的解决方法是“**预计算+贪心**”：通过两次Dijkstra（正向和反向）预计算出全局信息（每个点到起点和终点的最短距离），然后利用这些信息指导后续的局部贪心选择，从而保证局部最优能够推导出全局最优。这种“双向搜索”或“meet-in-the-middle”的思想在解决许多图论路径问题时非常有效。

**优化与拓展**:

- 本题的解法在时间和空间上已经相当优越，对于给定的数据范围是完全足够的。
    
- 一个有趣的拓展是，如果问题要求输出所有最短路径中字典序第 `k` 小的路径，该如何解决？这会是一个更复杂的问题，可能需要结合搜索和剪枝技术。
    

**学习收获**:

1. **深化了对Dijkstra算法的理解**: 不仅仅是会背模板，而是能理解其原理，并将其作为工具解决更复杂的问题。
    
2. **学习了处理复合优化目标的策略**: 当问题有多个优化目标（如：长度最短、字典序最小）时，通常需要先满足最高优先级的目标（最短路径），然后在满足该目标的解空间内，再优化次要目标（字典序）。
    
3. **掌握了“双向Dijkstra”的应用**: 通过从起点和终点同时运行最短路算法，可以高效地判断某点或某边是否在最短路径上，这是一个非常实用且强大的技巧。

# 踩点上课 (H5-02)

## 一、问题描述

> **【问题描述】**
> 
> 阿迪通常开着闹钟睡觉，这样他才不至于上课迟到。
> 
> 他想知道能否赶上第一节课，为了不迟到，他需要知道从家到学校所需要的最少时间是多少。
> 
> 阿迪生活的城市是一个 n×m 的矩形区域，其中每个单元( i, j )由一个数字 aij 来表示
> 
> - 数字为 -1 时表示该单元被占用，禁止通行
>     
> - 数字为 0 时表示该单元是空闲的，阿迪可以穿过
>     
> - 数字为 x (1≤x ≤109) 时表示该单元包含入口，需要耗费的时间成本为 x，包含入口的单元也是空闲的，可以自由通行
>     
> 
> 从任何包含入口的单元出发，阿迪可以去往任何包含入口的其他单元，从入口( i, j )到入口( x, y ) 的时间成本总和为 aij + axy。
> 
> 除了在两个包含入口的单元之间移动，他也可以在具有相邻边的未被占用的单元之间移动，耗费的时间为 w 。实际上，他也可以进入一个包含入口的单元而不使用它。
> 
> 开始时，阿迪处在左上角单元 (1, 1)，而学校位于右下角(n, m)。
> 
> **【输入形式】**
> 
> 输入的第一行包含三个整数 n、m 和 w (2 ≤ n、m ≤ 2×103，1≤ w ≤109)，此处 n 和 m 是城市的大小，w 是在未被占用的单元之间移动所需要的时间。
> 
> 接下来的 n 行每行包含 m 个数 (-1 ≤ ai ≤ 109)，表示对单元的描述。
> 
> 输入保证单元(1, 1)和(n, m)是空闲的。
> 
> **【输出形式】**
> 
> 输出为一个数，表示阿迪去往学校需要花费的最少时间，如果他不能去到学校，则输出-1。
> 
> **【样例输入】**
> 
> ```
> 5 5 1
> 0 -1 0 1 -1
> 0 20 0 0 -1
> -1 -1 -1 -1 -1
> 3 0 0 0 0
> -1 0 0 0 0
> ```
> 
> **【样例输出】**
> 
> ```
> 14
> ```

## 二、问题分析与边界条件

**问题核心**: 本题要求计算在一个带有特殊“传送门”规则的网格图中，从左上角 (1,1) 到右下角 (n,m) 的最短路径成本。

**思路拆解**: 这是一个图论中的最短路问题。路径由两种移动方式构成：

1. **普通移动**: 在相邻的、非障碍的单元格之间移动，每次移动成本固定为 `w`。
    
2. **传送门移动**: 从一个入口 `P_i`（值为正数的单元格）可以移动到另一个入口 `P_j`，成本为 `grid[P_i] + grid[P_j]`。
    

关键的洞察在于，任何一条最优路径**最多只会使用一次传送门移动**。因为多次传送（如 S -> P1 -> P2 -> P3 -> P4 -> D）的成本为 `(val(P1)+val(P2)) + (val(P3)+val(P4))`，这总是大于或等于单次传送（如 S -> P1 -> P4 -> D）的成本 `val(P1)+val(P4)`。

基于此，问题被分解为两种独立的可能性：

1. 完全不使用传送门，只通过普通移动从起点到达终点。
    
2. 使用一次传送门，路径形如：起点 -> (普通移动) -> 入口A -> (传送) -> 入口B -> (普通移动) -> 终点。
    

**边界条件**: 根据题目和代码逻辑，需要考虑以下边界情况：

- **路径不通**:
    
    - 起点和终点之间可能没有任何普通路径。
        
    - 传送网络可能无法从起点或终点访问，即所有入口都无法通过普通移动到达。
        
    - 最终可能无法到达终点，此时应输出 -1。
        
- **无传送门**: 地图中可能没有任何入口（值 > 0 的单元格），此时只能进行普通移动。
    
- **数值溢出**: 路径成本 `w` 和入口值都很大，路径总成本可能超过32位整型范围，因此代码中必须使用 `long long` 来存储距离。
    
- **起点/终点即为入口**: 起点或终点本身也可能是入口，算法需要能正确处理这种情况。
    

## 三、算法设计

**核心思想**: 算法的核心是分别计算“不使用传送门”和“使用一次传送门”两种策略下的最短路径，然后取两者的最小值作为最终答案。

1. **不使用传送门**: 这等价于在网格图上寻找从起点到终点的最短路，由于所有边的权重（普通移动成本 `w`）都相同，可以使用**广度优先搜索 (BFS)** 高效求解。
    
2. **使用一次传送门**: 这条路径的成本可以分解为三部分：
    
    - `成本1`: 从起点 `S` 普通移动到某个入口 `P_i` 的最短距离。
        
    - `成本2`: `P_i` 和 `P_j` 之间的传送成本，即 `value(P_i) + value(P_j)`。
        
    - `成本3`: 从某个入口 `P_j` 普通移动到终点 `D` 的最短距离。
        
    
    为了找到使用传送门的最低总成本，我们需要找到 `min(成本1 + 成本2 + 成本3)`。这可以进一步优化为 `min(成本1 + value(P_i)) + min(成本3 + value(P_j))`。
    
    - `min(从S到入口Pi的最短路 + value(Pi))`
        
    - `min(从D到入口Pj的最短路 + value(Pj))`
        
    
    这两部分的计算都需要知道起点/终点到所有其他点的最短普通移动距离。因此，我们可以运行两次BFS来预计算这些距离。
    

**数据结构**:

- `std::vector<std::vector<int>> grid`: 存储输入的 n x m 网格。
    
- `std::vector<std::vector<long long>> dist`: 二维数组，用于存储 BFS 计算出的从某个源点到图中所有点的最短距离。
    
- `std::queue<std::pair<int, int>>`: BFS 的核心数据结构，用于按层次遍历网格节点。
    

**算法流程**:

1. **初始化**: 读取输入 `n`, `m`, `w` 和网格数据。定义一个足够大的数 `INF` 代表无穷大，用于表示不可达。
    
2. **第一次BFS**: 以起点 `(0, 0)` 为源点，运行一次 BFS，计算出 `dist_from_S` 数组，其中 `dist_from_S[i][j]` 表示从起点到 `(i, j)` 的最短普通移动距离。
    
3. **第二次BFS**: 以终点 `(n-1, m-1)` 为源点，运行一次 BFS，计算出 `dist_from_D` 数组，其中 `dist_from_D[i][j]` 表示从终点到 `(i, j)` 的最短普通移动距离。
    
4. **计算无传送门成本**: `cost_no_portal = dist_from_S[n-1][m-1]`。如果此值为 `INF`，则表示无法仅通过普通移动到达。
    
5. **计算使用传送门成本**:
    
    - 初始化 `min_S_to_portal = INF` 和 `min_D_to_portal = INF`。
        
    - 遍历整个网格，如果单元格 `(i, j)` 是一个入口 ( `grid[i][j] > 0` )：
        
        - 如果该入口可以从起点到达 (`dist_from_S[i][j] != INF`)，则更新 `min_S_to_portal = min(min_S_to_portal, dist_from_S[i][j] + grid[i][j])`。
            
        - 如果该入口可以从终点到达 (`dist_from_D[i][j] != INF`)，则更新 `min_D_to_portal = min(min_D_to_portal, dist_from_D[i][j] + grid[i][j])`。
            
    - `cost_with_portal = min_S_to_portal + min_D_to_portal`。
        
6. **确定最终答案**: 最终结果为 `min(cost_no_portal, cost_with_portal)`。如果结果仍然是 `INF`，则表示无论如何都无法到达终点，输出 -1。否则，输出计算出的最小值。
    

## 四、核心代码讲解

#### 1. BFS 广度优先搜索函数

```
vector<vector<ll>> bfs(pair<int, int> start, int n, int m, ll w, const vector<vector<int>>& grid) {
    vector<vector<ll>> dist(n, vector<ll>(m, INF));
    queue<pair<int, int>> q;

    int start_r = start.first;
    int start_c = start.second;

    if (grid[start_r][start_c] == -1) {
        return dist;
    }

    dist[start_r][start_c] = 0;
    q.push({start_r, start_c});

    int dr[] = {-1, 1, 0, 0};
    int dc[] = {0, 0, -1, 1};

    while (!q.empty()) {
        pair<int, int> curr = q.front();
        q.pop();
        int r = curr.first;
        int c = curr.second;

        for (int i = 0; i < 4; ++i) {
            int nr = r + dr[i];
            int nc = c + dc[i];

            if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] != -1 && dist[nr][nc] == INF) {
                dist[nr][nc] = dist[r][c] + w;
                q.push({nr, nc});
            }
        }
    }
    return dist;
}
```

**代码分析**:

- 这个函数是计算网格图中单源最短路径的标准 BFS 实现。
    
- `dist` 数组初始化为 `INF`，用于标记未访问过的节点并存储最短距离。
    
- `q` 是一个队列，存储待访问的节点坐标。
    
- 起点首先入队，其距离设为0。
    
- `dr` 和 `dc` 数组定义了上、下、左、右四个方向的移动。
    
- 主循环 `while (!q.empty())` 不断从队列中取出节点，并探索其所有未被访问过的、非障碍的邻居节点。
    
- 当找到一个合法的邻居 `(nr, nc)` 时，更新其距离 `dist[nr][nc] = dist[r][c] + w`，并将其入队。
    
- 函数返回 `dist` 数组，包含了从 `start` 点到所有可达点的最短距离。
    

#### 2. 主逻辑：计算两种策略的成本

```
void solve() {
    // ... 输入读取 ...

    // 1. 从起点 (0,0) 开始运行 BFS
    vector<vector<ll>> dist_from_S = bfs({0, 0}, n, m, w, grid);

    // 2. 从终点 (n-1, m-1) 开始运行 BFS
    vector<vector<ll>> dist_from_D = bfs({n - 1, m - 1}, n, m, w, grid);

    // 情况A: 完全不使用传送门的路径成本
    ll cost_no_portal = dist_from_S[n - 1][m - 1];

    // 情况B: 使用一次传送门的路径成本
    ll min_S_to_portal = INF;
    ll min_D_to_portal = INF;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (grid[i][j] > 0) { // 如果是入口
                if (dist_from_S[i][j] != INF) {
                    min_S_to_portal = min(min_S_to_portal, dist_from_S[i][j] + grid[i][j]);
                }
                if (dist_from_D[i][j] != INF) {
                    min_D_to_portal = min(min_D_to_portal, dist_from_D[i][j] + grid[i][j]);
                }
            }
        }
    }

    ll cost_with_portal = INF;
    if (min_S_to_portal != INF && min_D_to_portal != INF) {
        cost_with_portal = min_S_to_portal + min_D_to_portal;
    }

    // 4. 最终答案是两种情况成本的较小值
    ll final_ans = min(cost_no_portal, cost_with_portal);

    if (final_ans >= INF) {
        cout << -1 << endl;
    } else {
        cout << final_ans << endl;
    }
}
```

**代码分析**:

- 这段代码清晰地实现了算法设计的流程。
    
- 首先调用两次 `bfs` 函数，分别获取从起点和终点出发的距离图。
    
- `cost_no_portal` 直接从 `dist_from_S` 中查询终点位置的距离。
    
- 接着，通过一个双层循环遍历所有网格单元。当找到一个入口 (`grid[i][j] > 0`) 时，结合预计算的 `dist_from_S` 和 `dist_from_D`，计算并更新到达该入口并激活它的最低成本（`min_S_to_portal` 和 `min_D_to_portal`）。
    
- `cost_with_portal` 由 `min_S_to_portal` 和 `min_D_to_portal` 相加得到，前提是两者都不是 `INF`。
    
- 最后，比较 `cost_no_portal` 和 `cost_with_portal`，取较小值作为最终答案，并处理无法到达的情况。
    

## 五、复杂度分析

- **时间复杂度: O(N * M)**
    
    - **推导过程**: 算法主要由三次遍历网格的操作构成。第一次是 `bfs` from start，第二次是 `bfs` from end。每次 BFS 都会访问每个节点和每条边一次，在网格图中，节点数是 `N*M`，边数约是 `2*N*M`，所以单次 BFS 的时间复杂度是 `O(N*M)`。第三次是遍历所有单元格以计算传送门成本，其复杂度也是 `O(N*M)`。因此，总的时间复杂度由 BFS 主导，为 `O(N*M) + O(N*M) + O(N*M) = O(N*M)`。
        
- **空间复杂度: O(N * M)**
    
    - **推导过程**: 算法需要额外的空间来存储从起点和终点出发的距离数组。`dist_from_S` 和 `dist_from_D` 都是 `N x M` 大小的二维数组。BFS 中使用的队列在最坏情况下也可能存储 `O(N*M)` 个节点。因此，主要的额外空间开销与网格大小成正比，空间复杂度为 `O(N*M)`。
        

## 六、总结与反思

**方法总结**: 本题是一个在特殊规则下的网格图最短路问题。解决此类问题的关键在于**问题分解**和**模型抽象**。通过分析发现最优路径最多只经过一次“传送”，成功地将一个复杂问题分解为两个更简单的子问题：纯粹的网格最短路和“起点-传送-终点”模式的最短路。对于边权统一的网格图，**广度优先搜索 (BFS)** 是计算最短路径最直接、最高效的算法。

**学习收获**:

1. **复杂问题的简化能力**: 学会了通过分析问题特性（最优子结构、路径特点）来简化问题模型，这是解决复杂算法问题的核心能力。
    
2. **BFS的灵活应用**: 本题中两次从不同源点（起点和终点）执行BFS，以预计算所需的所有路径信息，体现了基础算法的灵活组合应用。
    
3. **代码实现细节**: 注意到了路径成本可能导致的整数溢出问题，并使用 `long long` 类型来保证计算的正确性。同时，通过定义 `INF` 来优雅地处理不可达状态，使代码逻辑更清晰。

