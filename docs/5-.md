# Dijkstra? (ID: H5_01)

## 一、问题描述

> **【问题描述】**
> 
> ​ 给定一个含权的无向图，顶点编号为1~n，你的任务为找出顶点1到顶点 n 之间的最短路径。
> 
> **【输入形式】**
> 
> ​ 输入的第一行为两个整数 n 和 m (2 ≤ n ≤ 105, 0 ≤ m ≤ 105)，其中 n 为顶点数，m 是边数。
> 
> ​ 接下来的 m 行包含用形式 ai、bi 和 wi (1≤ai、bi ≤n，1≤ wi ≤ 106)，这里ai、bi 是边的端点，而 wi 是边的长度。
> 
> ​ 该图可能包括环，或者一对顶点之间包含多条边。
> 
> **【输出形式】**
> 
> ​ 如果无路径，输出-1，否则输出最短路径，如果有多个，则输出字典序最小的路径。
> 
> ​ 对于两个整数序列 A (a1、a2、...)和 B (b1、b2、...)，称序列 A 字典序小于序列 B 当且仅当，存在 k ≥ 1，i <k 时，ai = bi，i =k 时，ai < bi 。
> 
> **【样例输入】**
> 
> ```
> 5 6
> 1 2 2
> 2 5 5
> 2 3 4
> 1 4 1
> 4 3 3
> 3 5 1
> ```
> 
> **【样例输出】**
> 
> ```
> 1 4 3 5
> ```

## 二、问题分析与边界条件

#### 问题核心

本题的核心任务是在一个带权无向图中，找出从顶点1到顶点n的最短路径。与标准的最短路径问题不同的是，本题增加了一个附加约束：当存在多条长度相同的最短路径时，需要输出节点序列字典序最小的那一条。

#### 思路拆解

直接在Dijkstra算法的松弛操作中加入“距离相同时选择节点编号小”的贪心策略是**错误**的，因为它无法保证整条路径的**全局**字典序最小。为了解决这个问题，我们可以将问题分解为以下三个步骤：

1. **计算最短路径长度**：首先，我们需要确定从顶点1到顶点n的最短路径长度到底是多少。
    
2. **筛选有效路径**：在确定了最短路径长度后，我们需要一种方法来判断图中的任意一条边 `(u, v)` 是否可能存在于某条最短路径上。
    
3. **构建字典序最小路径**：在所有属于最短路径的边中，我们从起点1开始，每一步都贪心地选择能够通往终点n且节点编号最小的下一个节点，从而构建出最终的路径。
    

#### 边界条件

根据题目描述和代码实现，需要考虑以下边界条件：

- **路径不存在**：顶点1和顶点n之间可能不连通。此时，从顶点1出发的Dijkstra算法计算出的 `dist[n]` 将为无穷大。程序需要输出-1。
    
- **图的规模**：顶点数 `n` 和边数 `m` 的最大值都达到了 105，因此必须使用效率较高的算法（如基于优先队列的Dijkstra）来避免超时。
    
- **图的结构**：图中可能包含自环或重边。邻接表的数据结构能够自然地处理这些情况。
    
- **路径长度溢出**：边权 `w` 最大为 106，路径长度可能会超过32位整型的范围，因此需要使用 `long long` 类型来存储距离，防止溢出。
    

## 三、算法设计

#### 核心思想

本题的解决方案巧妙地结合了两次Dijkstra算法和一次贪心构建，其核心思想是**利用从起点和终点两个方向的最短路信息来精确筛选出所有最短路径上的边，然后再进行有策略的贪心选择**。

1. **正向Dijkstra预计算**：首先，从起点1执行一次Dijkstra算法，计算出起点1到图中所有其他节点的最短距离，记为数组 `distFromSource`。这样我们就得到了1到n的最短路径总长度 `shortestPathLength = distFromSource[n]`。
    
2. **反向Dijkstra预计算**：接着，我们从终点n在**反向图**上执行一次Dijkstra算法（对于无向图，反向图与原图相同），计算出所有节点到终点n的最短距离，记为数组 `distToDest`。
    
3. **贪心路径构建**：有了这两个距离数组，我们可以得出一个关键的判断条件：一条边 `(u, v)` （权重为 `w`）如果存在于某条1到n的最短路径上，当且仅当它满足 `distFromSource[u] + w + distToDest[v] == shortestPathLength`。 这个公式的意义是：从起点1到`u`的最短距离，加上边 `(u,v)` 的权重，再加上从`v`到终点n的最短距离，三者之和恰好等于1到n的全局最短路径长度。 基于此，我们从起点1开始，在当前节点 `curr`，遍历其所有邻居 `next`，筛选出所有满足上述条件的“有效”邻居。在这些“有效”邻居中，我们选择节点编号最小的一个作为路径的下一个节点，并重复此过程，直到到达终点n。这个贪心策略是正确的，因为在路径的每一步，我们都选择了通往终点的、字典序最小的下一个节点，从而保证了整条路径的全局字典序是最小的。
    

#### 数据结构

- **邻接表 (`vector<vector<Edge>>`)**: 使用邻接表来存储图。`adj` 存储正向图，`adjRev` 存储反向图（在本题的无向图场景下两者相同）。其中 `Edge` 是一个 `pair<int, int>`，分别表示邻接点和边权。这种结构适合存储稀疏图。
    
- **优先队列 (`priority_queue`)**: 用于Dijkstra算法的实现，可以 O(logN) 的时间内获取当前距离最小的节点。`State` 是一个 `pair<long long, int>`，存储 `{距离, 节点编号}`，并自定义为小顶堆。
    
- **距离数组 (`vector<long long>`)**: `distFromSource` 和 `distToDest` 两个数组，用于存储两次Dijkstra算法的结果。
    

#### 算法流程

1. **输入与初始化**：读取顶点数 `n` 和边数 `m`。初始化正向邻接表 `adj` 和反向邻接表 `adjRev`。
    
2. **建图**：循环 `m` 次，读取每条边的信息 `(u, v, w)`，并将其添加到 `adj` 和 `adjRev` 中。
    
3. **正向Dijkstra**：调用 `dijkstra(1, n, adj)` 函数，计算出从起点1到所有节点的最短距离，存入 `distFromSource`。
    
4. **可达性判断**：检查 `distFromSource[n]` 是否为无穷大。若是，则说明1到n没有路径，输出-1并终止程序。
    
5. **反向Dijkstra**：调用 `dijkstra(n, n, adjRev)` 函数，计算出所有节点到终点n的最短距离，存入 `distToDest`。
    
6. **贪心路径构建**： a. 创建一个空的整型向量 `path` 用于存储最终路径。 b. 将起点1放入 `path`，并设 `currentNode = 1`。 c. 进入循环，条件为 `currentNode != n`： i. 遍历 `currentNode` 的所有邻居 `neighbor`。 ii. 对每个邻居，检查是否满足最短路径条件：`distFromSource[currentNode] + weight + distToDest[neighbor] == distFromSource[n]`。 iii. 在所有满足条件的邻居中，找到节点编号最小的一个，记录为 `nextNode`。 iv. 更新 `currentNode = nextNode`，并将其加入 `path`。
    
7. **输出结果**：遍历 `path` 向量，按格式要求输出路径上的所有节点。
    

## 四、核心代码讲解

#### 1. Dijkstra算法通用实现

```
// Dijkstra 算法的通用实现，返回从起点到所有点的距离数组
vector<long long> dijkstra(int startNode, int n, const vector<vector<Edge>>& adj) {
    vector<long long> dist(n + 1, INF);
    priority_queue<State, vector<State>, greater<State>> pq;

    dist[startNode] = 0;
    pq.push({0, startNode});

    while (!pq.empty()) {
        long long currentDist = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (currentDist > dist[u]) {
            continue;
        }

        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
```

**逐行分析**:

- 这是一个标准的使用优先队列优化的Dijkstra算法实现。
    
- `vector<long long> dist(n + 1, INF);`: 初始化距离数组`dist`，所有节点的距离初始为无穷大`INF`。
    
- `priority_queue<State, vector<State>, greater<State>> pq;`: 定义一个小顶堆，用于存储待处理的节点 `{距离, 节点编号}`，并按距离从小到大排序。
    
- `if (currentDist > dist[u])`: 这是一个剪枝优化。如果从队列中取出的状态的距离比已经记录在`dist`数组中的最短距离还要大，说明这是一个过时的、较差的路径信息，直接跳过，避免不必要的松弛操作。
    
- `if (dist[u] + weight < dist[v])`: 这是Dijkstra算法的核心——松弛操作。如果通过`u`到达`v`的距离 (`dist[u] + weight`) 比已知的`dist[v]`更短，就更新`dist[v]`并把新的、更优的状态 `{dist[v], v}` 加入优先队列。
    

#### 2. 贪心路径构建

```
// 步骤 3: 贪心构建字典序最小路径
vector<int> path;
int currentNode = 1;
path.push_back(currentNode);

while (currentNode != n) {
    int nextNode = -1;
    // 遍历当前节点的所有邻居，寻找最优的下一个节点
    for (const auto& edge : adj[currentNode]) {
        int neighbor = edge.first;
        int weight = edge.second;

        // 检查该邻居是否在某条最短路径上
        if (distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength) {
            // 在所有有效的邻居中，选择编号最小的
            if (nextNode == -1 || neighbor < nextNode) {
                nextNode = neighbor;
            }
        }
    }
    // 移动到选择的下一个节点
    currentNode = nextNode;
    path.push_back(currentNode);
}
```

**逐行分析**:

- 该代码段实现了算法设计的第三步，即在确定了所有最短路径上的“有效边”后，通过贪心策略构建最终路径。
    
- `while (currentNode != n)`: 循环直到我们构建的路径到达终点 `n`。
    
- `int nextNode = -1;`: 在每次循环开始时，初始化下一个节点为-1。
    
- `for (const auto& edge : adj[currentNode])`: 遍历当前节点的所有邻居。
    
- `if (distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength)`: 这是本算法最关键的判断。它利用预先计算好的两个距离数组，精确地筛选出那些走了之后仍然能保证最终路径是最短的邻居节点。
    
- `if (nextNode == -1 || neighbor < nextNode)`: 在所有满足上述条件的“有效”邻居中，我们选择节点编号最小的一个。`nextNode == -1`确保第一个有效邻居被选中，`neighbor < nextNode`确保后续能找到更小的。
    
- `currentNode = nextNode; path.push_back(currentNode);`: 将选出的最优节点作为路径的下一个节点，并加入到`path`向量中。
    

## 五、复杂度分析

- **时间复杂度: O(M log N)**
    
    - **推导过程**: 整个算法的运行时间主要由两次Dijkstra算法决定。单次Dijkstra算法使用优先队列（二叉堆）进行优化，图中每条边最多入队一次，每次入队或出队操作的时间复杂度为 O(logN)（其中N是顶点数）。因此，一次Dijkstra的时间复杂度为 O(MlogN)。两次Dijkstra的总时间复杂度仍然是 O(MlogN)。最后的路径构建步骤，需要遍历路径上每个节点的邻接边，最坏情况下总共访问的边数不超过 2M，节点数不超过 N，因此其时间复杂度为 O(N+M)。综上，算法的瓶颈在于Dijkstra，总时间复杂度为 O(MlogN)。
        
- **空间复杂度: O(N + M)**
    
    - **推导过程**: 算法需要额外空间来存储图的邻接表 `adj` 和 `adjRev`，这部分空间为 O(N+M)。同时，需要两个大小为 N+1 的数组 `distFromSource` 和 `distToDest` 来存储距离信息，这部分空间为 O(N)。Dijkstra算法中的优先队列最多可能存储 N 个节点。因此，总的空间复杂度为 O(N+M)。
        

## 六、总结与反思

- **方法总结**: 本题是经典Dijkstra算法的一个巧妙变种，它考察了如何通过增加预处理步骤来解决带有复杂约束的路径问题。核心技巧是“**双向预处理 + 贪心构造**”。通过从起点和终点分别运行Dijkstra，我们获得了关于全局路径的充分信息，这使得后续的局部贪心选择（选择字典序最小的节点）能够保证产生全局最优解。
    
- **优化与拓展**:
    
    - **有向图**: 如果题目中的图是有向图，本算法依然适用。只需在建图时，将 `adjRev` 正确地构建为 `adj` 的转置图（即所有边反向）即可。
        
    - **其他约束**: 类似的思想可以应用于其他路径约束问题，例如“找出经过最少节点的最短路径”或“找出某条边权重之和最小的最短路径”等。关键在于如何设计预处理阶段来获取足够的信息，以指导后续的路径构造。
        
- **学习收获**:
    
    1. **深刻理解问题约束**: 面对非标准的算法问题，首先要深入分析附加约束的本质。本题的“字典序最小”约束是全局性的，不能通过简单的局部贪心来满足。
        
    2. **预处理思想**: 当直接求解困难时，可以考虑通过预处理计算一些辅助信息，将问题转化为一个更简单的形式。两次Dijkstra就是典型的预处理。
        
    3. **算法的组合应用**: 解决复杂问题往往需要组合使用多种算法思想。本题将两次最短路算法与一次贪心算法结合，展现了算法设计的灵活性。

# 踩点上课 (ID: H5_02)

## 一、问题描述

> **【问题描述】**
> 
> 阿迪通常开着闹钟睡觉，这样他才不至于上课迟到。
> 
> 他想知道能否赶上第一节课，为了不迟到，他需要知道从家到学校所需要的最少时间是多少。
> 
> 阿迪生活的城市是一个 n×m 的矩形区域，其中每个单元( i, j )由一个数字 aij 来表示
> 
> - 数字为 -1 时表示该单元被占用，禁止通行
>     
> - 数字为 0 时表示该单元是空闲的，阿迪可以穿过
>     
> - 数字为 x (1≤x ≤109) 时表示该单元包含入口，需要耗费的时间成本为 x，包含入口的单元也是空闲的，可以自由通行
>     
> 
> 从任何包含入口的单元出发，阿迪可以去往任何包含入口的其他单元，从入口( i, j )到入口( x, y ) 的时间成本总和为 aij + axy。
> 
> 除了在两个包含入口的单元之间移动，他也可以在具有相邻边的未被占用的单元之间移动，耗费的时间为 w 。实际上，他也可以进入一个包含入口的单元而不使用它。
> 
> 开始时，阿迪处在左上角单元 (1, 1)，而学校位于右下角(n, m)。
> 
> **【输入形式】**
> 
> 输入的第一行包含三个整数 n、m 和 w (2 ≤ n、m ≤ 2×103，1≤ w ≤109)，此处 n 和 m 是城市的大小，w 是在未被占用的单元之间移动所需要的时间。
> 
> 接下来的 n 行每行包含 m 个数 (-1 ≤ ai ≤ 109)，表示对单元的描述。
> 
> 输入保证单元(1, 1)和(n, m)是空闲的。
> 
> **【输出形式】**
> 
> 输出为一个数，表示阿迪去往学校需要花费的最少时间，如果他不能去到学校，则输出-1。
> 
> **【样例输入】**
> 
> ```
> 5 5 1
> 0 -1 0 1 -1
> 0 20 0 0 -1
> -1 -1 -1 -1 -1
> 3 0 0 0 0
> -1 0 0 0 0
> ```
> 
> **【样例输出】**
> 
> ```
> 14
> ```

## 二、问题分析与边界条件

**问题核心**: 本题要求计算在一个带有特殊“传送入口”的二维网格中，从左上角 (1,1) 到右下角 (n,m) 的最短路径成本。

**思路拆解**: 这是一个图论中的最短路问题。路径由两种移动方式构成：

1. **普通移动**: 在相邻且非障碍的单元格之间移动，每次移动成本固定为 `w`。
    
2. **入口移动**: 从任意一个入口 `P_i` (值为正数的单元格) 移动到另一个入口 `P_j`，成本为 `value(P_i) + value(P_j)`。
    

关键的洞察在于，任何一条最优路径最多只会使用一次入口移动。因为多次使用入口（如 `A -> B` 再 `C -> D`）的成本为 `(val(A)+val(B)) + (val(C)+val(D))`，这不会比选择最优的单次入口移动（如 `A -> D`，成本为 `val(A)+val(D)`）更优。

因此，问题被分解为求解以下两种情况的最短路，并取其最小值：

1. **完全不使用入口**: 从起点到终点的路径完全由普通移动构成。
    
2. **使用一次入口**: 路径形式为：起点 `->` (普通移动) `->` 入口A `->` (入口移动) `->` 入口B `->` (普通移动) `->` 终点。
    

**边界条件**:

1. **路径不存在**: 起点与终点之间可能完全不连通，或者传送网络无法同时被起点和终点访问。在这种情况下，应输出 -1。代码中通过检查最终计算出的成本是否为无穷大 (`INF`) 来判断。
    
2. **数值溢出**: 移动成本 `w` 和入口成本 `aij` 都很大 (最高 `10^9`)，路径长度累加后可能超过标准32位整数的范围。因此，必须使用64位长整型 (`long long`) 来存储距离。
    
3. **无入口**: 地图中可能不存在任何入口。算法需要能正确处理这种情况，此时只能选择纯普通移动的路径。
    
4. **起点/终点不可达**: 题目保证起点和终点本身非障碍，但它们周围可能被障碍物完全包围，导致无法移动。BFS可以自然地处理这种情况。
    

## 三、算法设计

基于问题分析，我们发现最短路径只可能是两种情况之一。因此，我们可以分别计算这两种情况的最小成本，然后取其中的较小值作为最终答案。

**核心思想**: 将问题分解，通过两次广度优先搜索（BFS）预处理出所有点到起点和终点的普通移动距离，然后结合这些信息计算两种路径类型的最终成本。

**数据结构**:

1. `vector<vector<int>> grid`: 一个 `n x m` 的二维向量，用于存储输入的原始地图信息。
    
2. `vector<vector<ll>> dist_from_S`, `dist_from_D`: 两个 `n x m` 的二维向量，用于存储从起点 (1,1) 和终点 (n,m) 出发，通过普通移动到达网格中所有单元格的最短距离。使用 `long long` (`ll`) 类型防止溢出。
    
3. `queue<pair<int, int>>`: 用于实现广度优先搜索（BFS）的核心数据结构，存储待访问的单元格坐标。
    

**算法流程**:

1. **初始化**: 读取输入的 `n`, `m`, `w` 和整个网格 `grid`。定义一个足够大的常量 `INF` 代表不可达。
    
2. **第一次BFS**: 从起点 `(0, 0)` 开始执行BFS，计算出起点到网格中所有可达单元格的最短普通移动距离，结果存入 `dist_from_S`。由于所有普通移动的边权 `w` 相同，BFS是计算最短路径的最高效算法。
    
3. **第二次BFS**: 从终点 `(n-1, m-1)` 开始执行BFS，计算出终点到网格中所有可达单元格的最短普通移动距离，结果存入 `dist_from_D`。
    
4. **计算路径A成本 (不使用入口)**:
    
    - 该路径的成本即为起点到终点的纯普通移动距离，可以直接从 `dist_from_S[n-1][m-1]` 获取。我们称之为 `cost_no_portal`。
        
5. **计算路径B成本 (使用一次入口)**:
    
    - 首先，遍历整个网格，找出所有入口。
        
    - 计算从起点到达任一入口并激活它的最小成本：`min_S_to_portal = min(dist_from_S[i][j] + grid[i][j])`，其中 `(i,j)` 是一个可从起点到达的入口。
        
    - 计算从终点到达任一入口并激活它的最小成本：`min_D_to_portal = min(dist_from_D[i][j] + grid[i][j])`，其中 `(i,j)` 是一个可从终点到达的入口。
        
    - 路径B的总成本为 `cost_with_portal = min_S_to_portal + min_D_to_portal`。
        
6. **确定最终结果**:
    
    - 最终答案是 `min(cost_no_portal, cost_with_portal)`。
        
    - 如果最终答案仍然为 `INF`，说明无法从起点到达终点，输出 -1。否则，输出计算出的最小值。
        

## 四、核心代码讲解

#### 1. 广度优先搜索 (BFS) 函数

```
vector<vector<ll>> bfs(pair<int, int> start, int n, int m, ll w, const vector<vector<int>>& grid) {
    vector<vector<ll>> dist(n, vector<ll>(m, INF));
    queue<pair<int, int>> q;

    int start_r = start.first;
    int start_c = start.second;

    // 如果起点本身是障碍物，则无法从这里出发
    if (grid[start_r][start_c] == -1) {
        return dist;
    }

    dist[start_r][start_c] = 0;
    q.push({start_r, start_c});

    // 定义四个移动方向：上、下、左、右
    int dr[] = {-1, 1, 0, 0};
    int dc[] = {0, 0, -1, 1};

    while (!q.empty()) {
        pair<int, int> curr = q.front();
        q.pop();

        int r = curr.first;
        int c = curr.second;

        for (int i = 0; i < 4; ++i) {
            int nr = r + dr[i];
            int nc = c + dc[i];

            // 检查新坐标是否在边界内、是否可达（非障碍且未访问过）
            if (nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] != -1 && dist[nr][nc] == INF) {
                dist[nr][nc] = dist[r][c] + w;
                q.push({nr, nc});
            }
        }
    }
    return dist;
}
```

**代码分析**: 这个 `bfs` 函数是整个算法的基石。它接受一个起点坐标和网格信息，返回一个包含从该起点到所有其他点的最短普通移动距离的二维数组。

- `dist` 数组初始化为无穷大 `INF`，表示所有点初始时都不可达。
    
- 起点 `start` 的距离设为0，并将其加入队列 `q`。
    
- 循环不断从队列中取出单元格，并探索其上、下、左、右四个相邻的单元格。
    
- 对于每个有效的、未被访问过的邻居（`dist[nr][nc] == INF`），更新其距离为当前单元格距离加上 `w`，并将其加入队列。
    
- 当队列为空时，搜索结束，`dist` 数组中就包含了所有最短路径信息。
    

#### 2. 主逻辑：计算并比较两种路径成本

```
// ... BFS调用之后 ...

// 情况A: 完全不使用传送门的路径成本
ll cost_no_portal = dist_from_S[n - 1][m - 1];

// 情况B: 使用一次传送门的路径成本
ll min_S_to_portal = INF;
ll min_D_to_portal = INF;

for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        // 如果当前格子是入口
        if (grid[i][j] > 0) {
            // 只有当该入口能从起点到达时，才计算其成本
            if (dist_from_S[i][j] != INF) {
                min_S_to_portal = min(min_S_to_portal, dist_from_S[i][j] + grid[i][j]);
            }
            // 只有当该入口能从终点到达时，才计算其成本
            if (dist_from_D[i][j] != INF) {
                min_D_to_portal = min(min_D_to_portal, dist_from_D[i][j] + grid[i][j]);
            }
        }
    }
}

ll cost_with_portal = INF;
// 只有当起点和终点都能连接到传送网络时，此路径才可能存在
if (min_S_to_portal != INF && min_D_to_portal != INF) {
    cost_with_portal = min_S_to_portal + min_D_to_portal;
}

// 最终答案是两种情况成本的较小值
ll final_ans = min(cost_no_portal, cost_with_portal);
```

**代码分析**: 这段代码清晰地实现了算法设计的核心部分。

1. `cost_no_portal` 直接从第一次BFS的结果中获得。
    
2. 通过两层循环遍历网格中的每一个单元格，检查它是否为入口 (`grid[i][j] > 0`)。
    
3. 对于每个入口，它会利用预计算好的 `dist_from_S` 和 `dist_from_D` 来更新从起点/终点到入口网络的最低成本 (`min_S_to_portal` 和 `min_D_to_portal`)。`if (dist... != INF)` 的判断确保了只考虑可达的入口。
    
4. 最后，将两部分成本相加得到 `cost_with_portal`，并与 `cost_no_portal` 比较，得出最终答案。
    

## 五、复杂度分析

**时间复杂度: O(N * M)**

- **推导过程**: 算法的主要开销在于两次完整的网格BFS。对于一个 N×M 的网格，节点的数量为 N×M，边的数量最多约为 4×N×M。标准BFS的时间复杂度为 O(节点数 + 边数)，因此每次BFS的复杂度是 O(N_M)。之后，算法需要遍历一次网格来寻找所有入口并计算最小入口成本，这部分的时间复杂度也是 O(N_M)。所以，总的时间复杂度为 O(N_M) + O(N_M) + O(N_M)，即 O(N_M)。
    

**空间复杂度: O(N * M)**

- **推导过程**: 算法需要额外的空间来存储BFS的结果。`dist_from_S` 和 `dist_from_D` 是两个 N×M 大小的二维数组，它们占用了 O(N_M) 的空间。此外，BFS执行时使用的队列在最坏情况下也可能存储 O(N_M) 个节点。因此，算法所需的总空间与网格大小成正比，空间复杂度为 O(N*M)。
    

## 六、总结与反思

**方法总结**: 本题是一个在网格图上的最短路问题，其特点是混合了两种移动模式。解题的关键在于通过分析最优解的结构，将一个看似复杂的全局网络问题（所有入口互相连接）简化为两个独立的、更易于处理的子问题。这种“分类讨论”和“预处理”的思想是解决复杂算法问题的常用技巧。通过预先计算出所有点到起点和终点的基础距离，我们可以快速地组合出包含特殊移动的路径成本。

**优化与拓展**:

- 如果题目中的普通移动成本 `w` 不是一个固定的值，而是每个单元格之间移动的成本都不同，那么BFS将不再适用。此时，我们需要使用 **Dijkstra算法** 来求解单源最短路径，时间复杂度会相应增加到 O(N_M * log(N_M))。
    
- 如果题目允许多次使用传送门，问题会变得复杂得多，可能需要将每个入口视为图中的一个节点，构建一个包含所有单元格和入口的新图，然后在这个新图上运行最短路算法。
    

**学习收获**:

1. **问题简化能力**: 学会了如何通过分析题目特性和最优解的性质来简化问题模型，将复杂问题分解为几个标准算法可以解决的子问题。
    
2. **BFS的应用**: 巩固了使用BFS求解无权或等权图最短路问题的能力，并理解了其适用场景。
    
3. **双向搜索思想**: 运行两次BFS（一次从起点，一次从终点）是一种“双向搜索”或“相遇在中间”思想的体现。虽然本题不是严格的相遇，但这种分别从两端进行预处理的技巧对于解决路径问题非常有效。
    
4. **编码细节**: 认识到在处理可能产生巨大数值的路径求和问题时，使用 `long long` 等更大范围的数据类型来防止整数溢出的重要性。


