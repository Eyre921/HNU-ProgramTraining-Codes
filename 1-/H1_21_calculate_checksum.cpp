// Original Filename: 21. 计算校验码.cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
	int t;
	cin >> t;

	while (t--)
	{
		int B;
		string N;
		cin >> B >> N;

		// 计算N各位数字的和
		int digit_sum = 0;
		for (char c: N)
		{
			if (c >= '0' && c <= '9')
			{
				digit_sum += c - '0';
			} else
			{
				// a=10, b=11, c=12, d=13, e=14, f=15
				digit_sum += c - 'a' + 10;
			}
		}

		// 计算需要的校验码
		int remainder = digit_sum % (B - 1);
		int checksum;
		if (remainder == 0)
		{
			checksum = 0;
		} else
		{
			checksum = (B - 1) - remainder;
		}

		// 输出校验码
		if (checksum < 10)
		{
			cout << checksum << endl;
		} else
		{
			// 10->a, 11->b, 12->c, 13->d, 14->e, 15->f
			cout << (char) ('a' + checksum - 10) << endl;
		}
	}

	return 0;
}
/*
21. 计算校验码
【问题描述】

传送一个B（B≤16）进制的数值N时，最后加上一个一位（B进制的）校验码，使得N加上校验位后能被B-1整除。比如十进制的数值12310，其校验码就是3，因为十进制数值123310能被9整除。16进制的数7816，其校验码为0，因为16进制的78016是15的倍数。超过十进制后，用字母a表示10，字母b表示11，字母c表示12，字母d表示13，字母e表示14，字母f表示15。

告诉你进制B，以及一个B进制的正整数N，要求你计算正整数N在B进制下的校验码。

【输入形式】

输入第一行正整数t (10 ≤ n ≤ 100)，表示有多少组测试数据。

后面有t行，每行两个正整数B，N（2≤ B≤16），中间用一个空格隔开，B是10进制整数，N用B进制形式表示。测试数据保证没有非法的B进制数N（也即N中每一位都是在0到B-1之间，没有前导0）。

40%的测试数据N的位数L 1 ≤ L≤ 10；

30%的测试数据N的位数L 1 ≤ L≤ 102；

20%的测试数据N的位数L 1 ≤ L≤ 103；

10%的测试数据N的位数L 1 ≤ L≤ 104；

【输出形式】

对于每组测试数据，输出一位占一行：正整数N在B进制下的校验码。（如果校验码可以为B-1，也可以为0，输出0）。

【样例输入】


4
10 123
16 78
16 1234321
12 ab
【样例输出】


3
0
e
1
【样例说明】

第一行的4表示有4组测试数据，下面四行，每行一组测试数据。

第一组测试数据 10进制数123 最后添加检验码3，10进制数1233是9（=10-1）的倍数

第二组测试数据 16进制数78 最后添加检验码0，16进制数780是15（=16-1）的倍数

第三组测试数据 16进制数1234321 最后添加检验码e（=14），16进制数1234321e是15（=16-1）的倍数

第四组测试数据 12进制数ab 最后添加检验码1，12进制数ab1是11（12-1）的倍数

【Tips】

B进制的数能被B-1整除，当且仅当各位数字和能被B-1整除。

第一组测试数据 10进制数123 最后添加检验码3，10进制数1233各位数字和是9，是9的倍数

第二组测试数据 16进制数78 最后添加检验码0，16进制数780各位数字和是15，是15的倍数

第三组测试数据 16进制数1234321 最后添加检验码e，16进制数1234321e各位数字和是30，是15的倍数

第四组测试数据 12进制数ab 最后添加检验码1，12进制数ab1各位数字和是22，是11的倍数
 */