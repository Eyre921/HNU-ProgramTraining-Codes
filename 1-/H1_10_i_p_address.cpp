// Original Filename: 10.IP地址.cpp
#include<iostream>
#include<string>
#include<stdlib.h>
#include<vector>
using namespace std;

int main()
{
	int n, num = 0;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		string str[4], tstr = "00000000";
		getline(cin, str[0], '.');
		getline(cin, str[1], '.');
		getline(cin, str[2], '.');
		getline(cin, str[3]); //输入四段ip；
		for (int i = 0; i < 4; i++)
		{
			//atoi函数的作用是 把字符串转换成整型数的一个函数
			int t = atoi(str[i].c_str()); //c_str是string类中的一个函数，功能是返回当前字符串的首字符地址   ps:c_str()返回的是const char *类型
			int j = 7;
			while (t > 0)
			{
				tstr[j] = t % 2 + 48;
				t = t / 2;
				j--;
			}
			for (int i = 0; i < 8; i++)
			{
				if (tstr[i] == '1') num += 1;
			}
			//num = count(tstr.begin(),tstr.end(),'1');
			for (int k = 0; k < 8; k++)
				tstr[k] = '0';
			//cout << num <<endl;
			//tstr.replace(0,8,"00000000"); //下标从0开始的连续8个字符都被"00000000"替代
		}
		cout << num << endl;
		num = 0;
	}
	return 0;
}
/*
 *
10. IP地址
【问题描述】

一个IP地址由32位二进制的数组成，比如：

111111111111111111111111000000002

为了便于记忆，我们将8个二进制位用一个十进制数表示，一个IP地址由四个十进制数表示，上述的IP地址表示为：

255.255.255.0

现在给你一个上述形式的IP地址，请回答IP地址的32个二进制位中，有多少位是1。

如IP地址为255.255.255.0，其中24位是1。

【输入形式】

有多组测试数据。

测试数据第一行是一个正整数T，表示测试数据组数。

每组测试数据是一个IP地址，形式为：

IP1.IP2.IP3.IP4

其中0 ≤IP1,IP2,IP3,IP4≤ 255,用十进制表示。每个IP地址不保证是实用IP地址。

40%的测试数据组数T  10≤T≤ 102；

30%的测试数据组数T  102≤T≤ 103；

20%的测试数据组数T  103≤T≤ 104；

10%的测试数据组数T  104≤T≤ 105；

【输出形式】

对于每个IP地址，输出一行包含一个非负整数：该IP地址的32个二进制位中，1的位数。

【样例输入】


5
255.255.255.0
127.0.0.1
0.0.0.1
1.2.3.4
0.0.0.0
【样例输出】


24
8
1
5
0
提示：样例中32位的IP地址为：

11111111111111111111111100000000 2

01111111000000000000000000000001 2

00000000000000000000000000000001 2

00000001000000100000001100000100 2

00000000000000000000000000000000 2
 */