# Dijkstra? (ID: 1)

## 一、问题描述

> **【问题描述】**
> 
> 给定一个含权的无向图，顶点编号为1~n，你的任务为找出顶点1到顶点 n 之间的最短路径。
> 
> **【输入形式】**
> 
> 输入的第一行为两个整数 n 和 m (2 ≤ n ≤ 10^5, 0 ≤ m ≤ 10^5)，其中 n 为顶点数，m 是边数。
> 
> 接下来的 m 行包含用形式 ai、bi 和 wi (1≤ai、bi ≤n，1≤ wi ≤ 10^6)，这里ai、bi 是边的端点，而 wi 是边的长度。
> 
> 该图可能包括环，或者一对顶点之间包含多条边。
> 
> **【输出形式】**
> 
> 如果无路径，输出-1，否则输出最短路径，如果有多个，则输出字典序最小的路径。
> 
> 对于两个整数序列 A (a1、a2、...)和 B (b1、b2、...)，称序列 A 字典序小于序列 B 当且仅当，存在 k ≥ 1，i <k 时，ai = bi，i =k 时，ai < bi 。
> 
> **【样例输入】**
> 
> ```
> 5 6
> 1 2 2
> 2 5 5
> 2 3 4
> 1 4 1
> 4 3 3
> 3 5 1
> ```
> 
> **【样例输出】**
> 
> ```
> 1 4 3 5
> ```

## 二、问题分析与边界条件

**问题核心**: 本题要求在给定的带权无向图中，找到从顶点1到顶点n的一条路径，这条路径必须同时满足两个条件：1) 它是所有可能路径中总权重最小的（即最短路径）；2) 在所有最短路径中，它的顶点序列的字典序是最小的。

**思路拆解**: 要解决这个问题，我们可以将其分解为以下几个步骤：

1. **计算最短路径长度**: 首先，我们需要确定从顶点1到顶点n的最短路径长度到底是多少。如果不知道这个确切的值，我们就无法判断一条路径是否为“最短路径”。
    
2. **筛选有效路径**: 在确定了最短路径长度后，我们需要一种方法来识别出图中的哪些边可以构成一条从1到n的最短路径。
    
3. **构建字典序最小路径**: 从起点1开始，在所有能够走向终点n且不偏离最短路径的邻居节点中，每次都贪心地选择编号最小的那个节点，直到抵达终点n。这样构建出的路径即为字典序最小的最短路径。
    

**边界条件**: 根据题目描述和代码实现，需要考虑以下边界情况：

1. **路径不存在**: 顶点1与顶点n之间可能不连通。在这种情况下，无法找到路径，应按要求输出-1。代码中通过检查最短路径长度是否为无穷大（`INF`）来判断。
    
2. **输入规模**: 顶点数 `n` 和边数 `m` 最大可达 10^5，路径总长度可能超过普通整型变量的范围。代码中使用了 `long long` 来存储距离，以防止溢出。
    
3. **图的结构**: 题目明确指出图中可能包含环或重边，标准的Dijkstra算法能够正确处理这些情况。
    
4. **起点即终点**: 虽然题目限制 `n >= 2`，但健壮的算法也应能处理起点和终点相同的情况。
    

## 三、算法设计

**核心思想**: 本题的难点在于“字典序最小”这一约束。如果在单次Dijkstra算法的松弛操作中，当距离相等时简单地选择字典序小的节点，是无法保证全局路径字典序最小的。

正确的解法是采用一种“双向Dijkstra + 贪心构造”的策略。具体分为三步：

1. **正向Dijkstra**: 从起点1执行一次Dijkstra算法，计算出起点1到图中所有其他节点的最短距离，记为 `distFromSource` 数组。这样我们就得到了1到n的最短路径总长度 `shortestPathLength = distFromSource[n]`。
    
2. **反向Dijkstra**: 从终点n在**反向图**上执行一次Dijkstra算法，计算出终点n到所有其他节点的最短距离。这等价于在原图中计算所有节点到终点n的最短距离，记为 `distToDest` 数组。（对于无向图，反向图与原图相同）。
    
3. **贪心路径构建**: 有了 `distFromSource` 和 `distToDest` 这两个数组，我们可以精确地判断任意一条边 `(u, v)` (权重为 `w`) 是否位于某条1->n的最短路径上。其充要条件是： `distFromSource[u] + w + distToDest[v] == shortestPathLength` 这个公式的含义是：从起点1到u的最短距离，加上边(u,v)的权重，再加上从v到终点n的最短距离，三者之和恰好等于1到n的全局最短路径长度。 基于此，我们从起点1开始，迭代地构建路径：在当前节点 `curr`，遍历其所有邻居 `next`，筛选出所有满足上述条件的“有效”邻居。在这些“有效”邻居中，选择节点编号最小的一个作为路径的下一个节点，然后重复此过程，直到到达终点n。
    

**数据结构**:

- `std::vector<std::vector<std::pair<int, int>>> adj`: 使用邻接表来存储图。`adj[u]` 存储一个`pair`的列表，每个`pair`包含一个邻居节点 `v` 和对应的边权重 `w`。这种结构非常适合表示稀疏图。
    
- `std::priority_queue`: 使用最小优先队列来实现Dijkstra算法。队列中存储 `pair<long long, int>`，分别代表 `{当前距离, 节点编号}`，并根据距离进行升序排序，确保每次能取出距离最小的节点进行扩展。
    
- `std::vector<long long> dist`: 用于存储起点（或终点）到各个节点的最短距离。
    

## 四、核心代码讲解

**1. Dijkstra算法通用实现**

```
// Dijkstra 算法的通用实现，返回从起点到所有点的距离数组
vector<long long> dijkstra(int startNode, int n, const vector<vector<Edge>>& adj) {
    vector<long long> dist(n + 1, INF);
    priority_queue<State, vector<State>, greater<State>> pq;

    dist[startNode] = 0;
    pq.push({0, startNode});

    while (!pq.empty()) {
        long long currentDist = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        // 如果当前取出的距离已经不是最短的，则跳过
        if (currentDist > dist[u]) {
            continue;
        }

        // 遍历所有邻居节点
        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            // 松弛操作：如果找到了更短的路径，则更新距离并加入队列
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
```

**代码分析**: 这是一个标准的基于优先队列的Dijkstra算法实现。

- `dist` 数组初始化为无穷大 `INF`，起点距离设为0。
    
- `pq` 是一个最小堆，用于高效地获取当前所有已知路径中距离最短的节点。
    
- `while (!pq.empty())` 循环是算法的主体，不断从队列中取出距离最小的节点 `u`。
    
- `if (currentDist > dist[u])` 是一个重要的优化，避免了因同一节点被多次以不同距离入队而导致的重复计算。
    
- 核心的松弛操作 `if (dist[u] + weight < dist[v])` 判断是否可以通过节点 `u` 到达其邻居 `v` 来缩短 `v` 的已知最短距离。如果可以，就更新 `dist[v]` 并将新的状态 `{dist[v], v}` 推入优先队列。
    

**2. 贪心构建字典序最小路径**

```
// 步骤 3: 贪心构建字典序最小路径
vector<int> path;
int currentNode = 1;
path.push_back(currentNode);

while (currentNode != n) {
    int nextNode = -1;
    // 遍历当前节点的所有邻居，寻找最优的下一个节点
    for (const auto& edge : adj[currentNode]) {
        int neighbor = edge.first;
        int weight = edge.second;

        // 检查该邻居是否在某条最短路径上
        if (distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength) {
            // 在所有有效的邻居中，选择编号最小的
            if (nextNode == -1 || neighbor < nextNode) {
                nextNode = neighbor;
            }
        }
    }
    // 移动到选择的下一个节点
    currentNode = nextNode;
    path.push_back(currentNode);
}
```

**代码分析**: 这段代码实现了算法设计的第三步。

- `currentNode` 从起点1开始。
    
- 在 `while` 循环中，每一轮都为 `currentNode` 寻找路径上的下一个节点。
    
- 内部的 `for` 循环遍历 `currentNode` 的所有邻居 `neighbor`。
    
- `if (distFromSource[currentNode] + weight + distToDest[neighbor] == shortestPathLength)` 这行代码是关键，它利用预先计算好的两个距离数组，精确地判断 `currentNode -> neighbor`这条边是否可以作为最短路径的一部分。
    
- `if (nextNode == -1 || neighbor < nextNode)` 负责在所有满足条件的“有效”邻居中，找到并记录下节点编号最小的那一个（`nextNode`）。
    
- 循环结束后，将找到的最小编号节点 `nextNode` 作为路径的下一个节点，并继续下一轮迭代，直到抵达终点 `n`。
    

## 五、复杂度分析

**时间复杂度: O(M log N)**

- 算法的执行时间主要由两次Dijkstra算法决定。
    
- 标准的基于优先队列的Dijkstra算法中，每个顶点最多入队和出队一次，每次出队后会遍历其所有出边。
    
- 优先队列的插入（`push`）和删除最小元素（`pop`）操作的时间复杂度为 O(log N)，其中 N 是队列中的元素数量，最坏情况下为图的顶点数。
    
- 每条边 `(u, v)` 最多被松弛一次。因此，总的时间复杂度为 O(M * log N)。
    
- 最后的路径构建步骤需要遍历路径上每个节点的邻居，总共访问的边不会超过 M，访问的节点为 N，所以这部分的复杂度是 O(N+M)。
    
- 综上，总时间复杂度由Dijkstra主导，为 O(M log N)。
    

**空间复杂度: O(N + M)**

- 存储图的邻接表（`adj` 和 `adjRev`）需要 O(N + M) 的空间。
    
- 两个距离数组 `distFromSource` 和 `distToDest` 需要 O(N) 的空间。
    
- Dijkstra算法中的优先队列在最坏情况下可能存储所有N个顶点，需要 O(N) 的空间。
    
- 存储最终路径的 `path` 向量最多需要 O(N) 的空间。
    
- 因此，总的空间复杂度为 O(N + M)。
    

## 六、总结与反思

**方法总结**: 本题是一个在经典最短路径问题上的拓展，核心是处理“字典序最小”这一附加约束。通过本题，我们掌握了一种解决此类问题的通用范式：

1. **预计算**: 首先通过标准算法（如Dijkstra）计算出解决核心问题所需的基础信息（例如本题中的正、反向最短距离）。
    
2. **约束筛选**: 利用预计算出的信息，建立一个判断标准（Check），用于筛选出所有满足核心约束的备选项（例如本题中所有在最短路径上的边）。
    
3. **贪心选择**: 在满足核心约束的备选项集合中，根据附加约束（例如本题的字典序最小）进行贪心选择，逐步构造出最终解。
    

**学习收获**:

- **深化对Dijkstra的理解**: 本题让我意识到，Dijkstra不仅能求出最短距离，其计算过程中产生的距离数组更是解决复杂问题的宝贵信息。
    
- **双向搜索思想**: 从起点和终点同时开始计算（即正向和反向Dijkstra）是一种强大的技巧。它能够精确地定位出所有位于最短路径上的节点和边，为后续的决策提供了坚实的基础。
    
- **贪心的正确性**: 必须仔细分析问题，确保贪心策略的每一步选择都是在不影响全局最优解的前提下进行的。本题的贪心之所以正确，是因为我们已经通过双向Dijkstra确保了每一步选择都在“最短路径”这条“康庄大道”上，然后才在其中挑选“字典序”最小的分支。
    

通过解决这个问题，我更加理解了算法设计中“分解”与“组合”的思想，即将一个复杂问题分解为几个可以用经典算法解决的子问题，再将子问题的解组合起来，得到最终的答案。