/*
6. 身份证校验
【问题描述】

我国国标〖GB 11643-1999〗中规定：公民身份号码是18位特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。其校验码(最后一位)计算方法和步骤为：

(1)十七位数字本体码加权求和公式

S = Sum(Ai * Wi), i = 0, ... , 16 ，先对前17位数字的权求和

其中Ai：表示第i位置上的身份证号码数字值

Wi：表示第i位置上的加权因子，前17位加权因子从左到右分别为

Wi：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2

(2)计算模

Y = mod(S, 11)

(3)通过模Y查下表得到对应的校验码

Y

0

1

2

3

4

5

6

7

8

9

10

校验码

1

0

X

9

8

7

6

5

4

3

2

例如：某身份证前17位为11010519491231002

i

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

wi

7

9

10

5

8

4

2

1

6

3

7

9

10

5

8

4

2


1

1

0

1

0

5

1

9

4

9

1

2

3

1

0

0

2

积

7

9

0

5

0

20

2

9

24

27

7

18

30

5

0

0

4

得到和为：167；则模为y=167%11=2

查(3)得校验码为X(大写）

请按上面所述步骤编程，输入一个二代身份证号，检查该身份证是否正确。

【输入形式】

输入若干行，每行一个身份证号码，最后一行输入-1

【输出形式】

输出1代表正确，0代表错误

【样例输入】

120223198902021249
130132199210293822
130402198207290622
-1
【样例输出】

1
1
0
*/
/**
 * @file id_validator.cpp
 * @brief 身份号码校验程序
 *
 * 核心思路:
 * 严格按照国标 GB 11643-1999 的规定，对18位身份证号码的最后一位校验码进行验证。
 * 1.  **格式检查**: 首先验证输入字符串长度是否为18，以及前17位是否全为数字。
 * 2.  **加权求和 (S)**: 将身份证号码前17位数字 `Ai` 分别乘以对应的加权因子 `Wi` 并求和。
 * - Wi: {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2}
 * 3.  **计算模 (Y)**: 对加权和S进行模11运算，得到 Y = S % 11。
 * 4.  **查找校验码**: 根据Y的值 (0-10)，从一个固定的映射表中找到期望的校验码。
 * - Y:      {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
 * - 校验码: {'1','0','X','9','8','7','6','5','4','3','2'}
 * 5.  **比对**: 将计算出的期望校验码与身份证号码的第18位进行比较，若相同则有效，否则无效。
 *
 * 时间复杂度: O(1)
 * 对于每个身份证号，操作次数是固定的（17次乘法和加法），与输入规模无关。
 *
 * 空间复杂度: O(1)
 * 除了存储输入的字符串外，算法本身使用的额外空间是常数级的。
 */

#include <iostream>
#include <string>
#include <vector>
#include <cctype>   // for isdigit

// 启用C++标准库，无需显式使用 std:: 前缀
using namespace std;

/**
 * @brief 校验一个18位身份证号码是否有效
 * @param id 待校验的身份证号码字符串
 * @return 如果有效则返回true，否则返回false
 */
bool isValidIdNumber(const string& id) {
    // 步骤1: 检查长度是否为18位
    if (id.length() != 18) {
        return false;
    }

    // 定义加权因子和校验码映射表，使用常量确保数据不被修改
    const vector<int> weights = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};
    const vector<char> checkDigits = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};

    long long weightedSum = 0;

    // 步骤2: 计算前17位数字的加权和
    for (int i = 0; i < 17; ++i) {
        // 检查当前字符是否为数字
        if (!isdigit(id[i])) {
            return false;
        }
        // 将字符转换为数字并乘以对应的权重，累加到总和
        weightedSum += (id[i] - '0') * weights[i];
    }

    // 步骤3: 计算模
    int modulus = weightedSum % 11;

    // 步骤4: 通过模获取正确的校验码
    char expectedCheckDigit = checkDigits[modulus];

    // 步骤5: 将计算出的校验码与身份证的最后一位进行比对
    return id[17] == expectedCheckDigit;
}

int main() {
    // 优化I/O性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    /*
     * --- 测试用例说明 ---
     * 【样例输入】
     * 120223198902021249
     * 130132199210293822
     * 130402198207290622
     * -1
     *
     * 【样例输出】
     * 1
     * 1
     * 0
     *
     * --- 其他关键测试用例 ---
     * 输入: "11010519491231002X" -> 输出: 1 (官方示例，校验码为X)
     * 输入: "110105194912310021" -> 输出: 0 (校验码错误)
     * 输入: "12345678901234567"  -> 输出: 0 (长度不足)
     * 输入: "a23456789012345678"  -> 输出: 0 (包含非数字字符)
     */

    string idNumber;
    // 循环读取输入，直到遇见"-1"，这是题目要求的输入结束标志
    while (cin >> idNumber && idNumber != "-1") {
        cout << (isValidIdNumber(idNumber) ? 1 : 0) << endl;
    }

    return 0;
}