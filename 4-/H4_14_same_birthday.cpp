/*
14. 相同生日
【问题描述】

在一个有n个人的大班级中，存在两个人生日相同的概率非常大，现给出每个学生的学号，出生月日，试找出所有生日相同的学生。

【输入形式】

第一行为整数n，表示有n个学生，n<=200。此后每行包含一个字符串和两个整数，分别表示学生的学号(字符串长度为11位)和出生月(1<=m<=12)日(1<=d<=31)，学号、月、日之间用一个空格分隔。

【输出形式】

对每组生日相同的学生，输出一行，其中前两个数字表示月和日，后面跟着所有在当天出生的学生的学号，数字、学号之间都用一个空格分隔。对所有的输出，要求按日期从前到后的顺序输出。对生日相同的学号，按输入的顺序输出。

【样例输入】

6
07101020105 3 15
07101020115 4 5
07101020118 3 15
07101020108 4 5
07101020111 4 5
07101020121 8 10
【样例输出】

3 15 07101020105 07101020118
4 5 07101020115 07101020108 07101020111
8 10 07101020121
*/
/*
 * 核心思路:
 * 1. 数据结构选择: 问题的核心是“将学生按生日分组”并“按日期顺序输出”。`std::map` 是解决此类问题的
 * 理想数据结构。它是一个基于红黑树的有序关联容器，可以自动根据其键（Key）进行排序。
 *
 * 2. 键(Key)的设计: 为了让 `std::map` 能够按日期（先月后日）排序，我们需要一个能代表日期的、可比较的键。
 * 一个巧妙且高效的方法是将月和日组合成一个单独的整数，例如 `key = month * 100 + day`。
 * 这样，3月15日就变成了整数315，4月5日变成了405。由于乘数100大于最大的天数31，这种编码方式能确保
 * 日期的自然顺序和整数键的大小顺序完全一致（例如 315 < 405）。`std::map` 在插入时，就会利用这个
 * 整数键自动为我们完成所有生日的排序工作。
 *
 * 3. 值(Value)的设计: 对于每个生日（键），我们需要存储所有过生日的学生学号，并严格保持他们的输入顺序。
 * `std::vector<string>` 是完美的选择，因为它能存储一个动态的字符串列表，并维护元素的插入顺序。
 *
 * 4. 算法流程:
 * a. 创建一个 `map<int, vector<string>>` 容器，我们称之为 `birthdayMap`。
 * b. 循环读取所有n个学生的输入。对每个学生，计算其生日对应的整数键，然后将其学号 `push_back` 到
 * map中该键对应的 `vector` 之中。`map`的 `[]` 操作符会自动处理键不存在的情况（创建新的空vector）。
 * c. 当所有输入处理完毕后，`birthdayMap` 中已经存储了所有按生日分组且按日期排序的学生信息。
 * d. 最后，我们只需遍历这个 `map`。对每一个键值对，先从键中解码出月和日，然后按格式依次输出
 * 月、日以及 `vector` 中的所有学号即可。
 *
 * 时间复杂度: O(N log K)
 * - N 是学生总数，K 是不同生日的总数 (K <= N, 并且 K <= 366)。
 * - 每次向 `std::map` 插入一个元素的时间复杂度是 O(log K)。共插入N次，所以此部分为 O(N log K)。
 * - 遍历并输出 map 的时间复杂度为 O(K + N)。
 * - 总体复杂度由插入操作主导。因为 K 最大仅为366，log K 是一个极小的常数，所以实际性能接近 O(N)。
 *
 * 空间复杂度: O(N)
 * - 需要存储所有 N 个学生的学号（每个长度为11），以及K个vector的开销。
 * - 总体空间复杂度与输入规模 N 成线性关系。
 */

#include <iostream>
#include <vector>
#include <string>
#include <map>

// 使用 std 命名空间，可以省略 `std::` 前缀，使代码更简洁
using namespace std;

void solve() {
    int n;
    cin >> n;

    // 使用 std::map 来存储生日信息。
    // Key: int - 将 month 和 day 编码成一个整数 (month * 100 + day)，利用 map 的自动排序特性。
    // Value: vector<string> - 存储同一天生日的所有学生学号，并能保持其原始输入顺序。
    map<int, vector<string>> birthdayMap;

    for (int i = 0; i < n; ++i) {
        string studentId;
        int month, day;
        cin >> studentId >> month >> day;

        // 生成一个可比较且能代表日期的整数键，用于map的自动排序。
        int dateKey = month * 100 + day;

        // 将学生学号添加到对应生日的列表中。
        // 如果map中不存在这个key，`[]`操作符会自动创建一个空的vector，然后执行push_back。
        birthdayMap[dateKey].push_back(studentId);
    }

    // 遍历已自动按日期排序的 map 并输出结果。
    // 使用 const auto& 是一种现代C++的最佳实践，可以避免不必要的拷贝，提高效率。
    for (const auto& pair : birthdayMap) {
        int dateKey = pair.first;
        const vector<string>& studentIds = pair.second;

        // 根据题目样例，即使某生日只有一个学生，也需要输出。
        // 我们的逻辑默认就会处理这种情况，所以不需要额外的 if (studentIds.size() >= 1) 判断。

        // 从整数键中解码出原始的月和日。
        int month = dateKey / 100;
        int day = dateKey % 100;

        // 按格式要求，首先输出月和日。
        cout << month << " " << day;

        // 接着遍历并输出当天生日的所有学生学号。
        for (const string& id : studentIds) {
            cout << " " << id;
        }
        cout << endl;
    }
}

int main() {
    // 禁用 C++ 标准流与 C 标准流的同步，大幅提高 I/O 效率，是高性能计算的常用技巧。
    ios_base::sync_with_stdio(false);
    // 解除 cin 与 cout 的绑定，避免不必要的刷新，进一步提速。
    cin.tie(NULL);

    // 调用解决问题的函数。
    solve();

    return 0;
}