/*
18. 最少钱币数
【问题描述】这是一个古老而又经典的问题。用给定的几种钱币凑成某个钱数，一般而言有多种方式。例如：给定了 6 种钱币面值为 2、5、10、20、50、100，用来凑 15 元，可以用 5 个 2 元、1个 5 元，或者 3 个 5 元，或者 1 个 5 元、1个 10 元，等等。显然，最少需要 2 个钱币才能凑成 15 元。
        你的任务就是，给定若干个互不相同的钱币面值，编程计算，最少需要多少个钱币才能凑成某个给出的钱数。

【输入形式】输入可以有多个测试用例。每个测试用例的第一行是待凑的钱数值 M（1 <= M<= 2000，整数），接着的一行中，第一个整数 K（1 <= K <= 10）表示币种个数，随后是 K个互不相同的钱币面值 Ki(1 <= Ki <= 1000)。输入 M=0 时结束。

【输出形式】每个测试用例输出一行，即凑成钱数值 M 最少需要的钱币个数。如果凑钱失败，输出“Impossible”。你可以假设，每种待凑钱币的数量是无限多的。

【样例输入】

15
6 2 5 10 20 50 100
1
1 2
0

【样例输出】

2
Impossible

【样例说明】
【评分标准】
*/
/**
 * @file min_coins.cpp
 * @brief 最少钱币数问题的动态规划解决方案
 *
 * 核心思路:
 * 这是一个经典的动态规划问题（完全背包问题）。我们创建一个DP数组 `dp`，
 * 其中 `dp[i]` 表示凑成金额 `i` 所需的最少钱币数。
 *
 * 1. 状态定义: `dp[i]` 是凑成金额 `i` 的最少钱币数量。
 *
 * 2. 初始化: `dp[0]` 设置为0（凑成0元需要0个钱币）。DP数组的其他所有位置
 * 初始化为一个比最大可能结果还大的数（例如 M+1），作为“无穷大”，
 * 表示该金额尚未被成功凑成。
 *
 * 3. 状态转移: 我们从金额 1 遍历到 M。对于每个金额 `i`，我们尝试使用
 * 每一种可用的钱币 `c`。如果 `i >= c`，说明我们可以通过在已凑成 `i-c` 的
 * 基础上再加一枚钱币 `c` 来得到金额 `i`。因此，我们更新 `dp[i]` 的值为
 * `min(dp[i], dp[i - c] + 1)`。
 *
 * 4. 结果判断: 遍历完成后，如果 `dp[M]` 仍然是我们初始化的“无穷大”，
 * 说明金额 M 无法被凑成；否则，`dp[M]` 就是我们要求的答案。
 *
 * 时间复杂度: O(M * K)，其中 M 是目标金额，K 是钱币种数。
 * 空间复杂度: O(M)，用于存储DP数组。
 */

#include <iostream>
#include <vector>
#include <algorithm> // for std::min

// 启用C++标准库，无需显式使用 std:: 前缀
using namespace std;

int main() {
    // 优化I/O性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    /*
     * --- 测试用例说明 ---
     * 【样例输入】
     * 15
     * 6 2 5 10 20 50 100
     * 1
     * 1 2
     * 0
     *
     * 【样例输出】
     * 2
     * Impossible
     */

    int m;
    // 循环读取输入，直到 M 为 0
    while (cin >> m && m != 0) {
        int k;
        cin >> k;
        vector<int> coins(k);
        for (int i = 0; i < k; ++i) {
            cin >> coins[i];
        }

        // dp[i] 表示凑成金额 i 所需的最少钱币数
        // 初始化dp数组。m+1 是一个安全的“无穷大”值，因为即使面值最小为1，
        // 最多也只需要 m 个钱币。
        vector<int> dp(m + 1, m + 1);

        // base case: 凑成金额0需要0个钱币
        dp[0] = 0;

        // 填充DP数组
        // 从金额1遍历到目标金额m
        for (int i = 1; i <= m; ++i) {
            // 尝试使用每一种钱币
            for (int coin : coins) {
                // 如果当前金额 i 不小于钱币面值
                // 并且金额 i-coin 是可以凑成的
                if (i >= coin && dp[i - coin] != m + 1) {
                    // 更新dp[i]为更小的值
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // 检查最终结果
        if (dp[m] > m) { // 如果值仍为“无穷大”，则无法凑成
            cout << "Impossible" << endl;
        } else {
            cout << dp[m] << endl;
        }
    }

    return 0;
}