/*
13. 最简单的计算机
【问题描述】

一个名叫是 PigHeadThree 的研究组织设计了一台实验用的计算机，命名为 PpMm。PpMm只能执行简单的六种命令 A，B，C，D，E，F；只有二个内存 M1，M2；三个寄存器 R1，R2，R3。六种命令的含义如下：
命令 A：将内存 M1 的数据装到寄存器 R1 中；
命令 B：将内存 M2 的数据装到寄存器 R2 中；
命令 C：将寄存器 R3 的数据装到内存 M1 中；
命令 D：将寄存器 R3 的数据装到内存 M2 中；
命令 E：将寄存器 R1 中的数据和寄存器 R2 中的数据相加，结果放到寄存器 R3 中；
命令 F：将寄存器 R1 中的数据和寄存器 R2 中的数据相减，结果放到寄存器 R3 中。
你的任务是：设计一个程序模拟 PpMm 的运行。

【输入形式】

有若干组，每组有 2 行，第一行是 2 个整数，分别表示 M1 和 M2 中的初始内容；第二行是一串长度不超过 200 的由大写字母 A 到 F 组成的命令串，命令串的含义如上所述。

【输出形式】

对应每一组的输入，输出只有一行，二个整数，分别表示 M1，M2 的内容；其中 M1 和 M2 之间用逗号隔开。

【样例输入】

100 288
ABECED
876356 321456
ABECAEDBECAF
【样例输出】

388,388
2717080,1519268
*/
/*
 * 核心思路:
 * 这是一个典型的模拟问题。我们需要根据题目描述，为计算机的各个组件（内存、寄存器）
 * 创建对应的变量，然后逐一执行指令串中的指令，并相应地更新这些变量的值。
 *
 * 1. 状态表示:
 * - 使用五个整型变量来模拟计算机的状态：`m1`, `m2` (内存) 和 `r1`, `r2`, `r3` (寄存器)。
 *
 * 2. 指令处理:
 * - 程序通过一个循环来处理多组测试数据。
 * - 在每组测试数据中，首先读取 M1 和 M2 的初始值。
 * - 接着，读取包含所有指令的字符串。
 * - 遍历指令字符串中的每一个字符，使用 `switch` 语句来匹配并执行对应的操作。
 * `switch` 语句是处理这种多分支固定条件判断的理想选择，它比一长串 `if-else if`
 * 结构更清晰，且在某些情况下效率更高。
 *
 * 3. 循环与输入:
 * - 使用 `while (cin >> m1 >> m2)` 结构来优雅地处理未知数量的输入组，
 * 当没有更多输入时，循环会自动终止。
 *
 * 整个过程就是对计算机硬件行为的直接翻译，逻辑简单直接。
 *
 * 时间复杂度: O(L)
 * 对于每一组测试数据，其中 L 是命令串的长度。我们需要遍历一次命令串，
 * 每次操作（赋值、加/减）都是常数时间 O(1)。
 *
 * 空间复杂度: O(L)
 * 主要由存储命令串的 `std::string` 决定。如果逐字符读取并处理，空间复杂度可以降至 O(1)。
 * 但鉴于 L 不超过200，O(L) 的空间开销完全可以接受，且代码更简洁。
 */

#include <iostream>
#include <string>

// 遵循规范，直接使用 std 命名空间
using namespace std;

// 将模拟过程封装在一个函数中，提高代码的模块化和可测试性
void simulatePpMm(int initialM1, int initialM2, const string& commands) {
    // 步骤1: 初始化计算机的内存和寄存器
    // M1, M2 使用输入值初始化
    int m1 = initialM1;
    int m2 = initialM2;
    // 寄存器的初始状态未定义，为安全起见，初始化为0
    int r1 = 0, r2 = 0, r3 = 0;

    // 步骤2: 遍历并执行指令串中的每一条指令
    for (char command : commands) {
        // 使用 switch 语句根据指令字符执行相应操作
        switch (command) {
            case 'A': // 将内存 M1 的数据装到寄存器 R1 中
                r1 = m1;
                break;
            case 'B': // 将内存 M2 的数据装到寄存器 R2 中
                r2 = m2;
                break;
            case 'C': // 将寄存器 R3 的数据装到内存 M1 中
                m1 = r3;
                break;
            case 'D': // 将寄存器 R3 的数据装到内存 M2 中
                m2 = r3;
                break;
            case 'E': // 将 R1 和 R2 的数据相加，结果放到 R3 中
                r3 = r1 + r2;
                break;
            case 'F': // 将 R1 和 R2 的数据相减，结果放到 R3 中
                r3 = r1 - r2;
                break;
            // default 分支用于处理潜在的无效指令，增强代码健壮性
            default:
                // 在本题中，可以假设输入总是有效的，故此分支可留空
                break;
        }
    }

    // 步骤3: 输出最终的内存状态
    cout << m1 << "," << m2 << endl;
}

int main() {
    // 提高IO性能，是处理大数据量输入的良好习惯
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int m1_initial, m2_initial;
    string commandString;

    // 使用 while 循环处理多组输入数据
    // 当 cin 成功读取到两个整数时，循环继续
    while (cin >> m1_initial >> m2_initial) {
        // 读取紧随其后的命令串
        cin >> commandString;
        // 调用模拟器函数处理当前这组数据
        simulatePpMm(m1_initial, m2_initial, commandString);
    }

    // --- main 函数的测试用例说明 ---
    // 本程序根据题目要求，从标准输入动态读取多组测试数据。
    //
    // 样例输入1:
    // 100 288
    // ABECED
    // 对应输出: 388,388
    //
    // 样例输入2:
    // 876356 321456
    // ABECAEDBECAF
    // 对应输出: 2717080,1519268

    return 0;
}