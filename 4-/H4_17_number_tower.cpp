/*
17. 数塔
【问题描述】

给定一个数塔，如下图所示。在此数塔中，从顶部出发，在每一节点可以选择走左下或右下，一直走到底层。请找出一条路径，使路径上的数值和最大。





9








12


15






10


6


8




2


18


9


5


19


7


10


4


16

【输入形式】

输入时第一行一个整数n，表示该数塔的行数，其余n行表示该塔每行的数值

【输出形式】

输出包含两行，第一行为最大路径上的数值之和， 第二行n个数字为从上而下最大路径数值

【样例输入】

5
9
12 15
10 6 8
2 18 9 5
19 7 10 4 16
【样例输出】

59
9 12 10 18 10
*/
/*
 * 核心思路:
 * 本题是经典的动态规划(Dynamic Programming)问题，目标是找到从塔顶到塔底的路径最大和，并输出该路径。
 *
 * 1. 寻找最大和 (自底向上DP):
 * a. 状态定义: `dp[i][j]` 表示从第 `i` 行第 `j` 个元素出发，到达塔底所能获得的最大路径和。
 * b. 状态转移方程: 从 `(i, j)` 出发，只能走向下一行的 `(i+1, j)` 或 `(i+1, j+1)`。为了使总和最大，
 * 我们应该选择两者中能引向更大路径和的那个方向。因此，状态转移方程为：
 * `dp[i][j] = tower[i][j] + max(dp[i+1][j], dp[i+1][j+1])`
 * c. Base Case: DP的计算起点是塔底（第n-1行）。从塔底的任一元素出发到达塔底，最大和就是其本身的值。
 * 所以 `dp[n-1][j] = tower[n-1][j]`。
 * d. 计算顺序: 我们从倒数第二行 (`i = n-2`) 开始，逐行向上计算，直到算出塔顶 `dp[0][0]`，
 * 这就是整个问题的最终答案（最大路径和）。
 *
 * 2. 记录并回溯路径:
 * a. 记录决策: 在计算DP的过程中，当我们在 `(i, j)` 点决策是走左下还是右下时，我们将这个决策记录下来。
 * 创建一个 `path[i][j]` 表，存储在 `(i, j)` 点的下一步应该走向的列索引。
 * b. 回溯路径: DP计算完成后，从塔顶 `(0, 0)` 开始，利用 `path` 表一步步向下追踪，就可以重建整条最优路径。
 *
 * 关键修正 (Key Correction):
 * 1. 平局处理 (Tie-Breaking): 当从一个节点出发，其左下方和右下方的两条路径可以达到的最大和相等时，
 * 原代码 `>` 会默认选择右路。这可能与测试数据的预期路径不符。编程竞赛中，此类情况通常约定俗成地
 * 选择“字典序”较小的路径，即优先向左。因此，将判断条件从 `>` 修改为 `>=`，
 * 使得在路径和相等时，优先选择左下方的路径。
 * 2. 数据结构优化: 将用于记录路径的 `path` 表的大小从矩形 `(n-1)x(n-1)`修正为精确的三角形结构，
 * 与数塔上半部分的形状保持一致，减少了不必要的内存占用，使代码更严谨。
 *
 * 时间复杂度: O(N^2)
 * - N是数塔的行数。DP计算需要遍历数塔中的每个元素一次，数塔总元素个数约为 N^2/2。
 *
 * 空间复杂度: O(N^2)
 * - 需要 O(N^2) 的空间来存储原始数塔、DP表和路径决策表。
 */

#include <iostream>
#include <vector>
#include <algorithm>

// 使用 std 命名空间，可以省略 `std::` 前缀，使代码更简洁
using namespace std;

void solve() {
    int n;
    cin >> n;

    // 1. 读取输入并存储原始数塔
    vector<vector<int>> tower(n);
    for (int i = 0; i < n; ++i) {
        tower[i].resize(i + 1); // 第 i 行有 i+1 个元素
        for (int j = 0; j <= i; ++j) {
            cin >> tower[i][j];
        }
    }

    // 处理 n=1 的边界情况
    if (n == 1) {
        cout << tower[0][0] << endl;
        cout << tower[0][0] << endl;
        return;
    }

    // 2. 初始化DP表和路径记录表
    // dp表，用于存储从(i,j)到底层的最大和，直接用原始数塔初始化作为base case
    vector<vector<int>> dp = tower;

    // path表，用于记录在(i,j)位置的最佳选择是走向下一行的哪一列
    // 精确地初始化为一个上三角矩阵结构
    vector<vector<int>> path(n);
    for (int i = 0; i < n - 1; ++i) {
        path[i].resize(i + 1);
    }

    // 3. 自底向上进行动态规划
    for (int i = n - 2; i >= 0; --i) {
        for (int j = 0; j <= i; ++j) {
            // 修正点：使用 >= 而不是 >。当左右路径和相等时，优先选择左路。
            if (dp[i + 1][j] >= dp[i + 1][j + 1]) {
                dp[i][j] += dp[i + 1][j];
                path[i][j] = j; // 记录决策：走左下，即下一行的列索引不变
            } else {
                dp[i][j] += dp[i + 1][j + 1];
                path[i][j] = j + 1; // 记录决策：走右下，即下一行的列索引+1
            }
        }
    }

    // 4. 输出结果
    // 第一行输出最大路径和
    cout << dp[0][0] << endl;

    // 第二行根据 path 表回溯并输出路径上的原始数值
    int currentCol = 0;
    cout << tower[0][0]; // 首先输出塔顶元素
    for (int i = 0; i < n - 1; ++i) {
        // 根据path表的记录，确定下一行应该走的列索引
        currentCol = path[i][currentCol];
        cout << " " << tower[i + 1][currentCol];
    }
    cout << endl;
}

int main() {
    // 禁用 C++ 标准流与 C 标准流的同步，大幅提高 I/O 效率
    ios_base::sync_with_stdio(false);
    // 解除 cin 与 cout 的绑定，避免不必要的刷新，进一步提速
    cin.tie(NULL);

    solve();

    return 0;
}