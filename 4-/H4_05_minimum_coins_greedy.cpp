/*
5. 最小钱币数（贪心算法）
【问题描述】

阿迪有很多钱。他在银行里有n元。出于安全考虑，他想用现金取款（此处不透露原因）。钞票的面额是1，5，10，20，100元。取出全部余额后能收到的最小钞票数是多少？

【输入形式】

输入一个正整数n，（1≤n≤109）
【输出形式】

阿迪能收到的最小钞票数
【样例输入1】

125
【样例输出1】

3
【样例输入2】

43
【样例输出2】

5
【样例输入3】

1000000000
【样例输出3】

10000000
【样例说明】

本题可以直接使用贪心策略（优先尽可能多选择大面额的钞票）解决：主要原因是后一个的权值（这里就是纸币面值）是前一个的2倍或以上。

可以思考一下如果货币的类型是1,9,10元三种，要求凑出18元，你可能就会发现贪心算法出错了！
*/
/*
 * 核心思路:
 * 1. 贪心策略: 这是一个经典的贪心算法问题。为了使钞票总数最少，我们的策略应该是“优先使用面额最大的钞票”。
 * 从最大面额100元开始，我们尽可能多地使用它，然后用剩余的金额去匹配次大面额的钞票（20元），以此类推，
 * 直到处理完所有面额。
 * 2. 算法步骤:
 * a. 定义一个包含所有钞票面额的数组，并按降序排列：{100, 20, 10, 5, 1}。
 * b. 初始化钞票总数为 0。
 * c. 遍历该数组，对于每个面额 d，通过整除运算 (n / d) 计算出当前金额 n 最多可以兑换多少张该面额的钞票。
 * d. 将计算出的钞票数累加到总数中。
 * e. 通过取模运算 (n % d) 更新需要继续兑换的剩余金额。
 * f. 重复此过程，直到处理完所有面额（或剩余金额为0）。
 * 3. 正确性说明: 贪心策略在此处之所以有效，是因为钞票面额系统满足“无后效性”和“最优子结构”。简单来说，
 * 任何一张大面额钞票的价值都大于任意数量的较小面额钞票的组合可能产生的“优化”。例如，使用5张1元纸币
 * 永远不会比使用1张5元纸币更优。这保证了每一步的局部最优选择（用最大面额）都能导向全局最优解。
 *
 * 时间复杂度: O(1)
 * - 算法的执行时间取决于钞票面额的种类数量，这是一个固定的常数（本题中为5种）。
 * - 循环次数是恒定的，与输入金额 n 的大小无关，因此时间复杂度为常数级别。
 *
 * 空间复杂度: O(1)
 * - 算法仅使用了有限的几个变量（输入金额、总数）和一个固定大小的数组来存储面额。
 * - 所需空间不随输入 n 的增长而增长，因此空间复杂度为常数级别。
 */

#include <iostream>
#include <vector>
#include <numeric> // 引入此头文件是处理数值序列的良好编程习惯

// 使用 std 命名空间，可以省略 `std::` 前缀，使代码更简洁
using namespace std;

/**
 * @brief 解决 "最小钱币数" 问题的核心函数
 */
void solve() {
    // 读取需要取款的总金额。使用 long long 是一种安全的编程习惯，可以防止整数溢出，
    // 尽管对于 n <= 10^9 的范围，int 也足够。
    long long amount;
    cin >> amount;

    // 定义钞票的面额，并按从大到小的顺序排列，这是贪心策略能够正确实施的关键。
    // 使用 const 确保这个关键数据不会在程序中被意外修改。
    const vector<int> denominations = {100, 20, 10, 5, 1};

    // 初始化钞票总数为0
    long long totalBills = 0;

    // 通过范围for循环遍历每一种面额的钞票，代码更现代且不易出错
    for (int billValue : denominations) {
        // 如果当前金额已经为0，说明已经全部分配完毕，可以提前结束循环以优化
        if (amount == 0) {
            break;
        }

        // 计算当前面额的钞票需要多少张 (例如: 125 / 100 = 1)
        totalBills += amount / billValue;

        // 更新剩余未分配的金额 (例如: 125 % 100 = 25)
        amount %= billValue;
    }

    // 输出最终计算出的最小钞票数
    cout << totalBills << endl;
}

int main() {
    // 禁用 C++ 标准流与 C 标准流的同步，可以大幅提高 I/O 效率，是高性能计算的常用技巧
    ios_base::sync_with_stdio(false);
    // 解除 cin 与 cout 的绑定，避免不必要的刷新，进一步提速
    cin.tie(NULL);

    // 调用解决问题的函数。
    // 根据题目描述，通常只需要处理一个测试用例。
    solve();

    return 0;
}