/*
2. 组个最小数
【问题描述】

给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。

现给定数字，请编写程序输出能够组成的最小的数。

【输入形式】

每个输入包含1个测试用例。每个测试用例在一行中给出多个（不超过50个）数字（0~9之间），整数间用一个空格分隔，且至少拥有1个非0的数字。

【输出形式】

在一行中输出能够组成的最小的数。

【样例输入】

2 2 0 0 0 3 0 0 1 0
【样例输出】

1000000223
*/
/*
 * 核心思路:
 * 1. 贪心算法: 要组成最小的数，直观上应该将较小的数字放在高位（最左边）。因此，第一步是对所有给定的数字进行升序排序。
 * 2. 处理首位为0的特殊情况: 排序后，如果第一个数字是0，那么它不能作为最高位。这是因为题目要求组成的数不能有前导零
 * （例如，"012"不是一个合法的表示，应为"102"）。题目已保证至少有一个非0数字。
 * 为了在满足此条件的同时使数字最小，我们需要将排序后序列中第一个非0的数字，与首位的0进行交换。
 * 例如，对于输入 "2 2 0 0 0 3 0 0 1 0"，排序后得到 "0 0 0 0 0 0 1 2 2 3"。首位是0，不合法。
 * 在序列中找到的第一个非0数字是'1'，将它与首位的'0'交换，得到 "1 0 0 0 0 0 0 2 2 3"。
 * 这确保了我们使用了最小的非零数字作为开头，且其余数字保持了尽可能小的顺序，从而构成了整体最小的数。
 * 3. 最终结果: 经过上述处理后，将数字序列拼接起来，即为最终答案。
 *
 * 时间复杂度: O(N log N)
 * - 主要时间开销在于对所有数字进行排序，其中 N 是数字的总个数。
 * - 读入数据为 O(N)，查找第一个非0数字和交换操作最坏为 O(N)，输出为 O(N)。
 * - 因此，总的时间复杂度由排序决定，为 O(N log N)。
 *
 * 空间复杂度: O(N)
 * - 需要一个容器（如 std::vector）来存储 N 个输入的数字。
 */

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <sstream>

// 使用 std 命名空间，可以省略 `std::` 前缀，使代码更简洁
using namespace std;

/**
 * @brief 解决 "组个最小数" 问题的核心函数
 */
void solve() {
    // 读取包含所有数字的整行输入
    string line;
    getline(cin, line);

    // 使用 stringstream 来方便地从字符串中解析出由空格分隔的数字
    stringstream inputStream(line);

    // 使用一个 vector 来存储所有的输入数字
    vector<int> digits;
    int currentDigit;
    while (inputStream >> currentDigit) {
        digits.push_back(currentDigit);
    }

    // 对所有数字进行升序排序，这是构成最小数的基础
    sort(digits.begin(), digits.end());

    // 检查是否存在首位为0的情况
    // 题目保证至少有一个非0数字，所以我们不需要担心所有数字都是0的极端情况
    if (!digits.empty() && digits[0] == 0) {

        // 寻找第一个非0的数字的索引
        // C++17标准库的 `find_if` 是一种更现代、更具表达力的方式，但简单的for循环可读性也很好
        size_t firstNonZeroIndex = 0;
        for (size_t i = 0; i < digits.size(); ++i) {
            if (digits[i] != 0) {
                firstNonZeroIndex = i;
                break; // 找到后立即退出循环
            }
        }

        // 将第一个非0的数字与首位的0进行交换
        // 这样可以确保我们得到的是以最小非0数字开头的、总值最小的数
        if (firstNonZeroIndex != 0) {
            swap(digits[0], digits[firstNonZeroIndex]);
        }
    }

    // 遍历处理后的数字容器，并逐个打印，组成最终的最小数
    for (int digit : digits) {
        cout << digit;
    }
    cout << endl;
}

int main() {
    // 禁用 C++ 标准流与 C 标准流的同步，可以大幅提高 I/O 效率
    ios_base::sync_with_stdio(false);
    // 解除 cin 与 cout 的绑定，避免不必要的刷新，进一步提速
    cin.tie(NULL);

    // 调用解决问题的函数。本题只有单个测试用例。
    solve();

    return 0;
}