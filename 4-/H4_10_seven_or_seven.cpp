/*
10. 7， 还是7
【问题描述】输出 7 和 7 的倍数，还有包含 7 的数字例如（17，27，37...70，71，72，73...）

【输入形式】一个正整数 N。(N 不大于 30000)

【输出形式】从小到大排列的不大于 N 的与 7 有关的正整数，每行一个。

【样例输入】

20

【样例输出】

7
14
17

【样例说明】
【评分标准】
*/
/*
 * 核心思路:
 * 题目要求筛选出1到N之间所有“与7有关”的正整数。根据题意，“与7有关”包含两种情况：
 * 1. 该数字是7的倍数。
 * 2. 该数字的十进制表示中包含数字'7'。
 *
 * 解决方案非常直观：
 * - 遍历从1到N的每一个整数i。
 * - 对于每个整数i，我们进行两项检查：
 * a. 是否为7的倍数：这可以通过取模运算 `i % 7 == 0` 来判断。
 * b. 是否包含数字'7'：这需要检查该数的每一位。一个高效的方法是反复对该数取10的余数（得到个位数）并判断是否为7，
 * 然后将该数整除以10（去掉个位数），循环此过程直到该数变为0。为了代码的模块化和清晰性，
 * 这个逻辑被封装在一个独立的辅助函数 `containsDigitSeven` 中。
 * - 如果整数i满足上述两个条件中的任意一个（逻辑或 `||`），就将其输出。
 *
 * 由于是从小到大遍历，输出的数字自然就是升序排列的。
 *
 * 时间复杂度: O(N * log10(N))
 * 我们需要遍历N个数字。对于每个数字i，判断其是否为7的倍数是O(1)操作，
 * 而判断其是否包含数字'7'的操作复杂度与其位数成正比，即 O(log10(i))。
 * 因此，总时间复杂度为 O(N * log10(N))。
 *
 * 空间复杂度: O(1)
 * 算法仅使用了少数几个变量，没有使用与输入N规模相关的额外存储空间。
 */

#include <iostream>

// 遵循规范，直接使用 std 命名空间
using namespace std;

// 辅助函数：检查一个正整数是否包含数字 '7'
// 将此逻辑封装起来可以提高代码的可读性和复用性
bool containsDigitSeven(int number) {
    // 循环处理，直到所有位数都被检查过
    while (number > 0) {
        // 通过取模运算获取最低位（个位）
        if (number % 10 == 7) {
            // 如果发现'7'，立即返回true，无需继续检查
            return true;
        }
        // 通过整除运算移除最低位
        number /= 10;
    }
    // 如果循环结束仍未找到'7'，则返回false
    return false;
}

int main() {
    // 提高IO性能，是处理大数据量输入的良好习惯
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // 循环遍历从 1 到 n 的所有正整数
    for (int i = 1; i <= n; ++i) {
        // 条件判断：是7的倍数 或者 包含数字'7'
        if (i % 7 == 0 || containsDigitSeven(i)) {
            // 如果满足条件，则按要求输出，每行一个
            cout << i << endl;
        }
    }

    // --- main 函数的测试用例说明 ---
    // 本程序根据题目要求，从标准输入动态读取测试数据。
    //
    // 样例输入:
    // 20
    // 对应输出:
    // 7    (7是7的倍数)
    // 14   (14是7的倍数)
    // 17   (17包含数字'7')
    //
    // 另一个测试用例:
    // 输入:
    // 80
    // 输出应包含: 7, 14, 17, 21, 27, 28, ..., 70, 71, 72, ..., 77, 78, ...

    return 0;
}