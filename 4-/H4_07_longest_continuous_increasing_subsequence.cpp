/*
7. 最长连续递增子序列
【问题描述】

给出一个由n个正整数组成的数组。您的任务是找到给定数组的递增子数组的最大长度。

递增子数组由数组中若干个连续元素组成，且子数组中的每个元素严格地大于前一个元素。

【输入形式】

第一行为一个正整数n(1≤n≤105)，表示数组元素的个数

第二行给出n个正整数a1 a2......an  （1≤ai≤109） ，整数之间使用空格分隔
【输出形式】

输出最大递增子数组的长度
【样例输入】

5
1 7 2 11 15
【样例输出】

3
【样例说明】

1 7可以构成一个递增子数组

2 11 15可以构成一个递增子数组

所以本样例的输出结果为3
*/
/*
 * 核心思路:
 * 这个问题要求我们寻找“连续”且“严格递增”的子数组的最大长度。
 * “连续”这个限制条件大大简化了问题，使我们无需使用复杂的动态规划（通常用于解决非连续的“最长递增子序列”问题）。
 *
 * 我们可以采用一次线性扫描（One Pass）的贪心策略来解决：
 * 1. 初始化两个变量：
 * - `maxLength`: 用于记录全局的最长递增子数组长度。
 * - `currentLength`: 用于记录当前正在扫描的连续递增子数组的长度。
 * 如果数组不为空，任何单个元素本身就是长度为1的递增子数组，所以这两个变量的初始值都应为1。
 *
 * 2. 从数组的第二个元素开始向后遍历，比较当前元素 `nums[i]` 与前一个元素 `nums[i-1]`。
 * - 如果 `nums[i] > nums[i-1]`，说明当前的递增序列得以延续，因此我们将 `currentLength` 加一。
 * - 如果 `nums[i] <= nums[i-1]`，说明递增序列在此处中断。此时，我们需要用刚结束的这个序列的长度 `currentLength`
 * 去更新全局的 `maxLength`（`maxLength = max(maxLength, currentLength)`），
 * 然后将 `currentLength` 重置为1，因为 `nums[i]` 将开始一个新的、长度至少为1的连续子数组。
 *
 * 3. 遍历结束后，必须再进行一次 `maxLength` 的更新。这是因为如果最长的递增子序列恰好在数组的末尾结束，
 * 那么在循环内部将没有机会更新 `maxLength`。
 *
 * 这种方法只需遍历数组一次，因此效率极高。
 *
 * 时间复杂度: O(N)
 * 我们只需要对数组进行一次完整的遍历。
 *
 * 空间复杂度: O(1)
 * 我们只使用了有限的几个额外变量来存储状态，与输入数组的大小无关。
 */

#include <iostream>
#include <vector>
#include <algorithm> // 用于 std::max

// 遵循规范，直接使用 std 命名空间
using namespace std;

int main() {
    // 提高IO性能，是处理大数据量输入的良好习惯
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // 处理边界情况：如果数组为空，则最长长度为0
    if (n == 0) {
        cout << 0 << endl;
        return 0;
    }

    // 使用 vector 存储数组元素，更安全、更现代
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
    }

    // 初始化：只要数组不为空，结果至少为1（单个元素自身构成一个子序列）
    int maxLength = 1;
    int currentLength = 1;

    // 从第二个元素开始遍历，与前一个元素比较
    for (int i = 1; i < n; ++i) {
        // 判断当前元素是否严格大于前一个元素
        if (nums[i] > nums[i - 1]) {
            // 如果是，则当前递增序列的长度加一
            currentLength++;
        } else {
            // 如果不是，说明递增序列中断
            // 此时用当前序列的长度更新全局最大长度
            maxLength = max(maxLength, currentLength);
            // 并将当前长度重置为1，开始新的序列计数
            currentLength = 1;
        }
    }

    // 最后的检查：如果最长递增序列一直持续到数组末尾，
    // 循环内将没有机会更新maxLength，所以在此处需要最后一次比较
    maxLength = max(maxLength, currentLength);

    // 输出最终结果
    cout << maxLength << endl;

    // --- main 函数的测试用例说明 ---
    // 本程序根据题目要求，从标准输入动态读取测试数据。
    //
    // 样例输入:
    // 5
    // 1 7 2 11 15
    // 对应输出: 3
    // 解释:
    // 1. 扫描到 1 7, currentLength = 2
    // 2. 扫描到 2, 递增中断, maxLength = max(1, 2) = 2, currentLength 重置为 1
    // 3. 扫描到 11, currentLength = 2
    // 4. 扫描到 15, currentLength = 3
    // 5. 循环结束, 最终检查 maxLength = max(2, 3) = 3
    //
    // 边界测试用例1 (整个数组递增):
    // 输入:
    // 6
    // 10 20 30 40 50 60
    // 输出: 6
    //
    // 边界测试用例2 (单个元素):
    // 输入:
    // 1
    // 100
    // 输出: 1

    return 0;
}