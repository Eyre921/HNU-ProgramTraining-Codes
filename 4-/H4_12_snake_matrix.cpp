/*
12. 蛇行矩阵
【问题描述】蛇形矩阵是由 1 开始的自然数依次排列成的一个矩阵上三角形

【输入形式】 正整数 N表示层数，N 不大于 100

【输出形式】输出一个 N 行的蛇形矩阵，矩阵三角中同一行的数字用一个空格分开，行尾不要多余的空格。

【样例输入】

5

【样例输出】

1 3 6 10 15
2 5 9 14
4 8 13
7 12
11

【样例说明】
【评分标准】
*/
/**
 * @file snake_matrix.cpp
 * @brief 蛇形矩阵问题的直接计算法实现
 *
 * 核心思路:
 * 通过数学归纳法推导出蛇形矩阵中任意位置 (i, j) 元素的通项公式，从而实现 O(1) 复杂度的单点计算。
 * 1.  首先推导第一列 (j=0) 元素的规律：matrix[i][0] 是在 matrix[i-1][0] 的基础上加上 i。
 * 这构成了一个等差数列求和，可得 matrix[i][0] = 1 + i*(i+1)/2。
 * 2.  然后分析同一行内 (行i) 元素的递增规律：matrix[i][j] 是在 matrix[i][j-1] 的基础上加上 (i+j+1)。
 * 因此，matrix[i][j] 等于该行首元素加上从第1列到第j列的增量累加。
 * 3.  结合以上两点，可以得到任意位置 (i, j) 元素的直接计算公式：
 * matrix[i][j] = 1 + i*(i+1)/2 + (i+1)*j + j*(j+1)/2
 *
 * 这种方法避免了模拟填充路径或依赖前驱节点的递推计算，代码更简洁，且易于理解其数学本质。
 *
 * 时间复杂度: O(N^2)
 * 需要双层循环遍历并计算 N*(N+1)/2 个矩阵元素。
 *
 * 空间复杂度: O(1)
 * 本实现采用即算即打印的方式，不存储整个矩阵，因此空间复杂度为常数级。如果需要存储，则为O(N^2)。
 */

#include <iostream>
#include <vector>

// 启用C++标准库，无需显式使用 std:: 前缀
using namespace std;

int main() {
    // 优化I/O性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    /*
     * --- 测试用例说明 ---
     * 【样例输入】
     * 5
     *
     * 【样例输出】
     * 1 3 6 10 15
     * 2 5 9 14
     * 4 8 13
     * 7 12
     * 11
     */

    int n;
    cin >> n;

    // 输入值校验，确保在有效范围内
    if (n > 0 && n <= 100) {
        // 逐行生成并打印蛇形矩阵
        for (int i = 0; i < n; ++i) {
            // 每行的元素个数为 n - i
            int rowSize = n - i;
            for (int j = 0; j < rowSize; ++j) {
                // 使用通项公式直接计算元素值
                long long startOfRow = 1LL + (long long)i * (i + 1) / 2;
                long long value = startOfRow + (long long)(i + 1) * j + (long long)j * (j + 1) / 2;

                // 打印元素，并处理行内空格
                cout << value << (j == rowSize - 1 ? "" : " ");
            }
            // 每行结束后换行
            cout << endl;
        }
    }

    return 0;
}