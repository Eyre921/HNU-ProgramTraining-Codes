/*
*14. 缺席考试的是谁？
【问题描述】

程序设计考试结束了，传来个不好的消息：有一个学生没参加考试!需要尽快知道缺席考试的人是谁，以便尽快做出处理。

糟糕的是，尽管有签到表，但由于人数较多，签到情况比较混乱：有的签到表签在一张白纸上，有的虽然签在名册上，但并不是签在自己姓名旁，更有学生签到了别的签到表上……

现在只能根据这2n-1个姓名（名册上有n个学生姓名，签到有n-1个姓名，签到姓名和名册姓名可能混在一起了），来找到缺席考试的人是谁。唯一一个有利的条件是所有参加考试的人都签了名，且只签一次，签名也都正确无误。

现在任务交给你：编写一个程序，找出缺席考试的是谁。


【输入形式】

有多组测试数据。

每组测试数据开始一行，是一个正整数n，表示总人数，n=0意味着输入结束并且不需要处理。

以下2n-1行，每行一个字符串，长度不超过20，表示一个人的姓名。姓名有大小写的英文字母、常用汉字组成(注意每个汉字占2个字节，中英文姓名都不排除有重名情况)。

40%的测试数据1 ≤ n≤ 10；

30%的测试数据1 ≤ n≤ 100；

20%的测试数据1 ≤ n≤ 103；

10%的测试数据1 ≤ n≤ 104；

提示：大量输入数据，C/C++输入推荐使用scanf函数


【输出形式】

对于每组测试数据，输出一行，只包含一个字符串，表示缺席的人的姓名。

【样例输入】

2
张三
张三
李四
0
【样例输出】

李四
【解题技巧】

位运算中的异或操作
*/

/**
 * @file find_absent_student.cpp
 * @brief 解决方案：找出唯一出现奇数次的姓名
 *
 * 核心思路:
 * 题目给出了n个学生的花名册和n-1个学生的签到记录，混合在一起共2n-1个姓名。
 * 这意味着，每个到场的学生，其姓名会出现两次（花名册一次，签到一次），总共是偶数次。
 * 而缺席的学生，其姓名只会出现一次（仅在花名-册上），总共是奇数次。
 * 因此，问题被巧妙地转化为：在一堆姓名中，找到那个唯一出现奇数次的姓名。
 *
 * 算法选择与“异或”提示分析:
 * 1.  异或操作提示：对于整数，异或(XOR, ^)运算有一个关键性质：A ^ A = 0，A ^ 0 = A。
 * 如果有一系列整数，其中只有一个数出现奇数次，其他都出现偶数次，那么将所有数
 * 异或起来的结果就是那个只出现奇数次的数。这是因为所有成对的数异或后都变成了0。
 *
 * 2.  应用于字符串：C++中的 `std::string` 类型不能直接进行异或操作。
 * 我们可以实现与异或操作“配对抵消”思想等价的逻辑。
 * -   方案A (哈希+异或)：将每个字符串哈希成一个整数，然后异或所有哈希值。
 * 这种方法有哈希冲突的风险，可能导致错误结果，不保证100%正确。
 * -   方案B (使用std::map计数)：这是最稳健、清晰的方案。我们用一个 `map`
 * 来统计每个姓名出现的次数。遍历完所有姓名后，再遍历一遍map，找到那个
 * 出现次数为奇数的姓名即可。
 * -   方案C (使用std::set模拟异或)：遍历姓名列表，如果姓名已在set中，则删除它
 * （配对抵消）；如果不在，则加入它。最后set中剩下的唯一姓名就是答案。
 *
 * 本解法采用方案B (`std::map`)，因为它逻辑直观，性能也完全满足本题的数据规模要求，
 * 并且能正确处理姓名中包含汉字等复杂字符的情况。
 *
 * 输入提示分析:
 * 题目提示使用 `scanf` 以提高效率。对于大量的输入，这确实比默认的 `cin` 快。
 * 但通过 `ios_base::sync_with_stdio(false);` 和 `cin.tie(NULL);`
 * 可以大幅优化 `cin` 的性能，使其与 `scanf` 相当，同时又能安全、便捷地
 * 处理 `std::string`，因此本解法采用优化后的 `cin`。
 *
 * 时间复杂度: O(N log N)
 * N是学生总数。总共需要读入 2N-1 个姓名，每次对map进行插入或更新操作的时间
 * 复杂度为 O(log K)，其中K是map中不同姓名的数量 (K <= N)。
 *
 * 空间复杂度: O(N * L)
 * L是姓名的最大长度。Map需要存储最多N个不同的姓名。
 */

#include <iostream>
#include <string>
#include <vector>
#include <map>

// 使用标准命名空间，简化代码
using namespace std;

void solve() {
    int n;
    // 循环处理多组测试数据，直到n为0
    while (cin >> n && n != 0) {
        // map用于统计每个姓名出现的次数
        map<string, int> nameCounts;

        int totalNames = 2 * n - 1;

        // 读取所有 2n-1 个姓名
        for (int i = 0; i < totalNames; ++i) {
            string name;
            cin >> name;
            // 对应姓名的计数加一
            nameCounts[name]++;
        }

        // 遍历map，找到出现次数为奇数的姓名
        string absentStudent;
        for (const auto& pair : nameCounts) {
            // 如果计数值是奇数，则该姓名的主人就是缺席者
            if (pair.second % 2 != 0) {
                absentStudent = pair.first;
                break; // 找到后即可退出循环
            }
        }

        // 输出缺席者的姓名
        cout << absentStudent << endl;
    }
}

int main() {
    // 优化C++标准流的IO性能，使其速度接近scanf
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solve();

    return 0;
}