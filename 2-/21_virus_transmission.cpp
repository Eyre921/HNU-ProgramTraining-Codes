/*
21. 新型冠状病毒（COVID19）传播
【问题描述】

       在以习近平同志为核心的党中央的正确领导下，我国新冠疫情得到了有效控制。防控新冠病毒，必须时刻引起大家的足够重视，特别是人员集中活动场所，保持好社交距离。

       然而，在大洋彼岸的 M 国，人们对COVID19并未引起足够重视，他们的领导人川建国同志甚至对居家隔离、戴口罩以及保持社交距离等措施非常不屑，该国疫情已经完全失控。

       在一个风景秀丽的小镇，一天早上，有 N 名晨跑爱好者（编号 1 ～ N ）沿着优雅的江边景观道朝同一方向进行晨跑，第 i 名跑者从位置 Si 处起跑， 且其速度为 Vi。换句话说，对所有的实数 t ≥ 0，在时刻 t 时第 i 名跑者的位置为 Si + Vi ·t。

       很不幸的是，其中一名跑者在 t = 0 的时刻感染了病毒，且是无症状感染者，这种病毒只会在同一时刻处在同一位置的跑者之间传播，新感染了病毒的跑者也会感染其他人，很显然，等待足够长的时间，那么病毒会感染一些特定的跑者。

       事后发现其中有一名跑者感染了新冠病毒，如果此人就是在 t = 0 时刻的那名感染者，那么，在 N 名晨跑爱好者中会有多少人感染新冠病毒？

【输入形式】

        输入包含三行：

 第一行包含为两个整数 N 和 K，分别表示运动员的人数以及开始时感染了病毒的跑者编号。

 第二行包含 N 个正整数 S1、S2、...、SN，用空格隔开，分别表示跑者的起始位置。

 第三行包含 N 个正整数 V1、V2、...、VN，用空格隔开，分别表示跑者的速度。

【输出形式】

         输出为一个整数，表示最终被感染人数。

【样例输入】

6 3
3 9 8 5 7 5
6 6 5 4 6 3
【样例输出】

3
【样例说明】
【评分标准】

     对于50%的评测用例，0< K ≤ N ≤102

     对于70%的评测用例，0< K ≤ N ≤104

     对于100%的评测用例，0< K ≤ N ≤107
 */

/**
 * @file virus_transmission.cpp
 * @brief 解决方案：计算新冠病毒在晨跑者中的最终感染人数
 *
 * 核心思路:
 * 这是一个关于追及问题的物理模型。其核心思想是，所有最终被感染的跑者会形成一个
 * “感染群组”。这个群组在赛道上移动时，会有一个最快的“领跑者”和一个最慢的“殿后者”。
 * 它们的运动轨迹定义了一个移动的“感染时空区域”。任何轨迹与之相交的跑者都会被感染。
 *
 * 算法采用一个高效的两阶段（Two-pass）方法来求解：
 *
 * 1.  第一阶段：确定感染群体的速度边界。
 * -   算法首先确定整个“感染群组”最终的最快速度 `max_v` 和最慢速度 `min_v`。
 * -   一个关键的洞察是：这个最终的速度边界是由那些能与初始病患 `k` 直接相遇的
 * 跑者决定的。任何能进一步扩大速度边界的跑者，其本身也必须能被初始病患 `k`
 * 所在的群体追上或追上该群体。
 * -   因此，第一遍循环遍历所有人，找出所有能与 `k` 直接相遇的人（同起点、
 * 在前且更慢、在后且更快），并用他们的速度来不断扩大 `max_v` 和 `min_v` 的边界。
 *
 * 2.  第二阶段：根据速度边界统计所有感染者。
 * -   在确定了最终的 `max_v` 和 `min_v` 后，我们就有了一个完整的“感染时空区域”的
 * 移动特征。
 * -   第二遍循环再次遍历所有人，根据每个人的位置和速度判断他们是否会被感染：
 * a.  对于在 `k` 前方起跑的人，只要他的速度比 `max_v` 慢，就一定会被感染群组的
 * “领跑者”追上。
 * b.  对于在 `k` 后方起跑的人，只要他的速度比 `min_v` 快，就一定能追上感染群组的
 * “殿后者”。
 * c.  与 `k` 同起点的人在 t=0 时刻就已相遇并感染。
 * -   将这三部分人数相加，即为最终结果。
 *
 * 时间复杂度: O(N)
 * 算法包含两次独立的、对N个跑者的线性遍历。
 *
 * 空间复杂度: O(N)
 * 需要使用数组存储N个跑者的初始位置和速度。
 */
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
// 题目的 N 最大值为 10^5，但这里开了 10^7+10，可能是模板习惯，够用即可
const int N = 1e7 + 10;
int n, k;
// ans 用来最终计数
int ans;
int s[N], v[N];

int main()
{
    // 读取跑者总数 n 和初始感染者编号 k
    cin >> n >> k;
    // 读取所有人的初始位置
    for (int i = 1; i <= n; i++) cin >> s[i];
    // 读取所有人的速度
    for (int i = 1; i <= n; i++) cin >> v[i];

    // --- 阶段一: 确定感染群体的速度边界 ---
    // 核心思想是，所有最终被感染的人会形成一个“感染群组”。
    // 这个群组有一个最快的领跑者和一个最慢的殿后者。
    // max_v: 用来记录感染群组中“最快”的速度。
    // min_v: 用来记录感染群组中“最慢”的速度。
    // 初始时，我们只知道病人k，所以速度边界就是v[k]。
    int max_v = v[k], min_v = v[k];

    // 第一次遍历：此循环的目的是找到所有能与初始病人k（或与k同起点的人）
    // 直接构成感染关系的人，并用他们的速度来更新整个感染群体的速度边界 (max_v, min_v)。
    for (int i = 1; i <= n; i++)
    {
        // 情况1: 跑者i在病人k前面 (s[i] > s[k])，但速度比k慢 (v[i] < v[k])。
        // 这意味着k迟早会追上i，从而直接感染i。
        // i的速度就可能成为感染群组里更慢的速度，所以我们更新min_v。
        if (s[i] > s[k] && v[i] < v[k])
        {
            min_v = min(min_v, v[i]);
        }
        // 情况2: 跑者i在病人k后面 (s[i] < s[k])，但速度比k快 (v[i] > v[k])。
        // 这意味着i迟早会追上k，从而直接感染i。
        // i的速度就可能成为感染群组里更快的速度，所以我们更新max_v。
        if (s[i] < s[k] && v[i] > v[k])
        {
            max_v = max(max_v, v[i]);
        }
        // 情况3: 跑者i和病人k在同一位置起跑 (s[i] == s[k])。
        // 他们在 t=0 时刻就相遇，所以i立即被感染。
        // 我们需要把这个人的速度也纳入考虑，来更新速度边界。
        if (s[i] == s[k])
        {
            // 注意：这里的ans计数方式比较特殊，它只先加上了和k同起点的人。
            // 最终结果还需要在下一轮循环中累加。病人k自己也会在这里被算进去一次。
            ans++;
            min_v = min(min_v, v[i]);
            max_v = max(max_v, v[i]);
        }
    }

    // --- 阶段二: 根据速度边界统计所有间接感染者 ---
    // 现在我们有了整个感染群体的最快速度max_v和最慢速度min_v。
    // 这两个速度定义了一个移动的“感染区间”。
    // 任何跑者，只要其运动轨迹会进入这个由感染群体构成的“移动时空区域”，就会被感染。

    // 第二次遍历，统计所有会被这个“感染群组”追上或追上这个“感染群组”的人。
    // 注意：这里我们只考虑那些与k不同起点的人，因为同起点的已经在阶段一被ans统计过了。
    for (int i = 1; i <= n; i++)
    {
        // 情况A: 跑者i在病人k后面 (s[i] < s[k])。
        // 要想追上并被感染，他必须比感染群组中“最慢”的那个殿后者(min_v)还要快。
        // 只要 v[i] > min_v，他就总有一天能追上感染群组的“尾巴”。
        if (s[i] < s[k] && v[i] > min_v) ans++;

        // 情况B: 跑者i在病人k前面 (s[i] > s[k])。
        // 要想被追上并感染，他必须比感染群组中“最快”的那个领跑者(max_v)还要慢。
        // 只要 v[i] < max_v，感染群组的“排头兵”总有一天能追上他。
        if (s[i] > s[k] && v[i] < max_v) ans++;
    }

    // 输出最终统计的总人数。
    cout << ans << endl;
    return 0;
}