/*
 *
* 2. xxx定律
【问题描述】

       对于一个正整数n，如果是偶数，就把n砍掉一半；如果是奇数，把n变成 3*n+ 1后砍掉一半，直到该数变为1为止。
       请计算需要经过几步才能将n变到1，具体可见样例。

【输入形式】

       测试包含多个用例，每个用例包含一个整数n,当n为0 时表示输入结束。（1<=n<=10000）

【输出形式】

       对于每组测试用例请输出一个数，表示需要经过的步数,每组输出占一行。

【样例输入】

3
2
0
【样例输出】

5
1
 */

/**
* @file collatz_like_sequence.cpp
 * @brief 解决方案：计算考拉兹猜想变体的步数
 *
 * 核心思路:
 * 这是一个直接的模拟问题。我们根据题目描述的规则，对输入的数字n进行迭代变换，
 * 直到n的值变为1。
 * 1. 使用一个循环来处理多组测试用例，当输入为0时循环结束。
 * 2. 对于每一个输入的n，初始化一个步数计数器`stepCount`为0。
 * 3. 启动一个内层循环，条件为 `n != 1`。
 * 4. 在循环内部，判断n的奇偶性：
 * - 如果n是偶数，则执行 n = n / 2。
 * - 如果n是奇数，则执行 n = (3 * n + 1) / 2。
 * 5. 每次变换后，将步数计数器`stepCount`加1。
 * 6. 当n变为1时，内层循环结束，此时的`stepCount`即为所需的总步数。
 *
 * 时间复杂度: O(S(N))
 * 对于单个输入N，时间复杂度取决于其变换到1所需的步数，这个步数函数S(N)没有简单的
 * 封闭形式解。但对于给定的输入范围(N <= 10000)，该序列总是能在有限且不大的步数内
 * 收敛到1，因此计算速度非常快。
 *
 * 空间复杂度: O(1)
 * 算法在计算过程中仅使用了有限的几个变量（如当前的n值和步数计数器），
 * 所需内存空间是固定的，与输入n的大小无关。
 */

#include <iostream> // 用于标准输入输出 (cin, cout)

// 使用标准命名空间，简化代码
using namespace std;

// 函数负责计算将n变换到1所需的步数
void solve() {
    long long n; // 使用long long防止中间计算(3*n+1)溢出，虽然在本题int范围足够

    // 循环读取输入，直到输入为0，表示结束
    while (cin >> n && n != 0) {
        // 初始化步数计数器
        int stepCount = 0;

        // 循环进行变换，直到n的值变为1
        // 循环条件 `n != 1` 优雅地处理了输入n=1时步数为0的情况
        while (n != 1) {
            // 判断n是奇数还是偶数
            if (n % 2 == 0) {
                // 如果是偶数，则将其砍掉一半
                n /= 2;
            } else {
                // 如果是奇数，则将其变为 3*n+1 后砍掉一半
                n = (3 * n + 1) / 2;
            }
            // 每完成一次变换，步数加一
            stepCount++;
        }

        // 输出当前n值所需的总步数
        cout << stepCount << endl;
    }
}

int main() {
    // 优化C++标准流的IO性能，对于大量输入输出的场景能提升速度
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 调用解决问题的函数
    solve();

    // 演示样例测试
    // 【样例输入】
    // 3
    // 2
    // 0
    // 【预期输出】
    // 5
    // 1

    return 0;
}