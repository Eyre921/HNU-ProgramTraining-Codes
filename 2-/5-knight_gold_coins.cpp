/*
* 5. 金币
【问题描述】

国王为他的忠诚的骑士支付金币。在他服役的第一天，骑士收到一枚金币。在接下来2天（第二天和第三天的服务），骑士每天收到2金币。在未来三天（第五，第四，和第六天的服务），骑士每天收到三金币。在未来四天（第七，第八，第九，和第十天的服务），骑士每天收到四金币。这一模式的付款方式将继续下去：在接下来的n天骑士每天将收到n枚金币，而在接接下来的n+1天每天将收到n+1枚金币，这里n是正整数。你的程序将确定在任何给定的天数（从第1天开始）支付给骑士的金币总数。

【输入形式】

输入包含至少一行，但不超过21行。输入的每一行包含一个测试案例的数据，即一个整数（1~10000），代表天数。

【输出形式】

每一行输出对应一个测试用例，由天数和支付给骑士的金币总数量组成，中间用空格分隔。

【样例输入】

10
6
10000
1000
21
22
【样例输出】

10 30
6 14
10000 942820
1000 29820
21 91
22 98
 */

/**
 * @file knight_gold_coins.cpp
 * @brief 解决方案：计算骑士在特定天数内获得的总金币数
 *
 * 核心思路:
 * 这个问题描述了一个分阶段的支付模式：
 * - 第1阶段：持续1天，每天1金币。
 * - 第2阶段：持续2天，每天2金币。
 * - 第k阶段：持续k天，每天k金币。
 *
 * 我们的目标是计算前N天总共获得的金币数。
 *
 * 一个直接且高效的模拟方法是按“阶段”进行累加，而不是按“天”。
 * 1.  我们用一个循环来模拟骑士经历的各个阶段（k=1, 2, 3, ...）。
 * 2.  在循环中，我们判断当前剩下的天数是否足够完成整个第k阶段（即k天）。
 * 3.  如果天数足够，我们就一次性计算完这k天的全部金币（k * k个），
 * 并从总天数中减去k天，然后进入下一阶段(k+1)。
 * 4.  如果天数不够完成整个第k阶段，说明骑士的服役将在这个阶段中结束。
 * 剩下的`remainingDays`天里，他每天都能获得k个金币。
 * 我们计算这部分金币（`remainingDays * k`个）并将其加入总数，然后结束计算。
 * 5.  这个逐阶段累加的方法避免了逐天计算的低效，其循环次数与阶段数（约等于输入天数的平方根）成正比，
 * 对于10000这个量级的数据来说速度非常快。
 *
 * 时间复杂度: O(sqrt(N))
 * 其中N是输入的天数。设总共有k个完整的阶段，则 N ≈ k*(k+1)/2，即 k 约等于 sqrt(2*N)。
 * 循环的次数与阶段数k成正比，因此时间复杂度为 O(sqrt(N))。
 *
 * 空间复杂度: O(1)
 * 算法在计算过程中仅使用了有限的几个变量，所需内存空间是固定的，与输入天数N的大小无关。
 */

#include <iostream> // 用于标准输入输出 (cin, cout)

// 使用标准命名空间，简化代码
using namespace std;

// 函数负责计算金币总数
void solve() {
    int totalDays;

    // 循环读取每个测试用例，直到输入结束
    while (cin >> totalDays) {
        long long totalCoins = 0;   // 使用long long防止金币总数溢出，尽管本题int足够
        int daysRemaining = totalDays; // 剩余待计算的天数
        int currentStage = 1;       // 当前所在的阶段

        // 当剩余天数足以完成当前整个阶段时，进行累加
        while (daysRemaining >= currentStage) {
            // 累加当前阶段所能获得的所有金币 (currentStage * currentStage)
            totalCoins += (long long)currentStage * currentStage;

            // 从剩余天数中减去当前阶段所花费的天数
            daysRemaining -= currentStage;

            // 进入下一个阶段
            currentStage++;
        }

        // 计算最后一个未完成阶段的金币
        // 循环结束后，daysRemaining是最后一个阶段所经历的天数
        if (daysRemaining > 0) {
            totalCoins += (long long)daysRemaining * currentStage;
        }

        // 按照格式输出结果
        cout << totalDays << " " << totalCoins << endl;
    }
}

int main() {
    // 优化C++标准流的IO性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 调用解决问题的函数
    solve();

    // 样例测试
    // 【样例输入】
    // 10
    // 6
    // 10000
    // 1000
    // 21
    // 22
    // 【预期输出】
    // 10 30
    // 6 14
    // 10000 942820
    // 1000 29820
    // 21 91
    // 22 98

    return 0;
}