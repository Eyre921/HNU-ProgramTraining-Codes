/*
20. 字符串压缩
【问题描述】

       给定一个由n个小写字母组成的字符串s，需要使用最少数量的钱币来压缩它。

       压缩该字符串，必须将s表示为多个相互连接的非空字符串: s=t1t2...tk，其中第 i 个字符串按照下列两种方法之一编码：

如果|ti|=1，也就是说 ti为单个字符组成的字符串，编码时需要支付a个钱币

如果ti是t1t2...ti-1的子串，编码时需要支付b个钱币

      你的任务是计算压缩给定的字符串需要花费的最小钱币数。

【输入形式】

       输入的第一行包含3个用空格分隔的正整数：n、a和b(1≤n、a、b≤5000)，第二行为一个长度为n的小写字符串。

【输出形式】

       输出一个整数，表示你需要为压缩s所需要支付的最小钱币数。
【样例输入1】

3 3 1
aba
【样例输出1】

7
【样例输入2】

4 1 1
abcd
【样例输出2】

4
【样例输入3】

4 10 1
aaaa
【样例输出3】

12
【样例输入4】

8 1 3
aaaaaaaa
【样例输出3】

7
【样例说明】

【评分标准】
 */

/**
 * @file string_compression_dp.cpp
 * @brief 解决方案：计算字符串压缩的最小成本
 *
 * 核心思路:
 * 这是一个典型的动态规划问题。我们的目标是找到将字符串 s 分割为 s=t1t2...tk
 * 并编码的最小成本。
 *
 * 1.  动态规划状态定义:
 * 定义一个一维数组 `dp`，其中 `dp[i]` 表示压缩字符串 s 的前 i 个字符
 * (即子串 s[0...i-1]) 所需的最小钱币数。我们的最终目标是求解 `dp[n]`。
 *
 * 2.  状态转移方程:
 * 为了计算 `dp[i]` 的值，我们需要考虑所有可能形成前 i 个字符的最后一段 `ti`。
 * 假设最后一段 `ti` 是从索引 `j` 开始到 `i-1` 结束的子串 `s[j...i-1]`，
 * 那么在处理这段之前，我们已经用 `dp[j]` 的成本压缩好了前 `j` 个字符。
 * 因此，`dp[i]` 的值可以通过遍历所有可能的分割点 `j` (0 <= j < i) 来找到最小值：
 * `dp[i] = min(dp[j] + cost(s[j...i-1]))`
 *
 * `cost(s[j...i-1])` 的计算有两种情况：
 * a.  如果子串 `s[j...i-1]` 长度为1（即 j = i-1），成本为 `a`。
 * 转移：`dp[i] = dp[i-1] + a`。
 * b.  如果子串 `s[j...i-1]` 在其前面的字符串 `s[0...j-1]` 中出现过，成本为 `b`。
 * 转移：`dp[i] = dp[j] + b`。
 *
 * 3.  实现细节:
 * -   程序通过一个外层循环 `i` 从 1 到 n，依次计算 `dp[1], dp[2], ..., dp[n]`。
 * -   在计算 `dp[i]` 时，首先用“单字符编码”的方式 `dp[i-1] + a` 为 `dp[i]`
 * 提供一个初始候选值。
 * -   然后，通过一个内层循环 `j` 从 0 到 `i-1`，尝试所有可能的最后一段 `s[j...i-1]`。
 * -   对于每一个子串 `s[j...i-1]`，代码通过线性扫描的方式在其前缀 `s[0...j-1]`
 * 中查找是否存在相同的子串。
 * -   如果找到了，就用 `dp[j] + b` 来尝试更新 `dp[i]` 的值。
 * -   最终 `dp[n]` 即为所求的最小成本。
 *
 * 时间复杂度: O(N^4)
 * 外层循环 i (N) * 内层循环 j (N) * 字符串查找循环 k (N) * 子串比较 (N)。
 * 对于 N=5000 的数据规模，此复杂度较高。
 *
 * 空间复杂度: O(N)
 * 主要用于存储大小为 N+1 的 dp 数组。
 */
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits> // 用于 INT_MAX

using namespace std;

int main() {
    // 优化C++标准流的IO性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // n: 字符串长度, a: 单字符编码成本, b: 子串编码成本
    int n, a, b;
    string s; // 待压缩的字符串
    cin >> n >> a >> b >> s;

    // dp[i] 表示压缩字符串s的前i个字符（s[0...i-1]）的最小成本
    vector<int> dp(n + 1, INT_MAX);

    // base case: 压缩一个空字符串的成本为0
    dp[0] = 0;

    // 迭代计算 dp[1] 到 dp[n]
    for (int i = 1; i <= n; i++) {

        // --- 状态转移计算 ---
        // `dp[i]` 的值由所有可能的最后一段编码方式中的最小值决定

        // 可能性 1: 将第 i 个字符 s[i-1] 作为单个字符进行编码
        // 这种编码方式基于压缩好前 i-1 个字符的状态 dp[i-1]
        if (dp[i - 1] != INT_MAX) {
            dp[i] = min(dp[i], dp[i - 1] + a);
        }

        // 可能性 2: 尝试将一个后缀 s[j...i-1] 作为子串进行编码
        // 遍历所有可能的后缀起点 j (0 <= j < i)
        for (int j = 0; j < i; j++) {
            // 提取当前考虑的后缀子串
            string current = s.substr(j, i - j);
            bool found = false; // 标记该子串是否在其前缀 s[0...j-1] 中出现过

            // 在前面的字符串部分 s[0...j-1] 中线性查找当前子串
            // k 是查找时的起始位置
            // 查找范围必须足够长以容纳 current 子串
            for (int k = 0; k <= j - (int)current.length(); k++) {
                if (s.substr(k, current.length()) == current) {
                    found = true; // 找到了
                    break;
                }
            }

            // 如果找到了，并且 dp[j] 是一个可达状态
            // 就用 dp[j] + b 来尝试更新 dp[i]
            if (found && dp[j] != INT_MAX) {
                dp[i] = min(dp[i], dp[j] + b);
            }
        }
    }

    // dp[n] 存储了压缩整个字符串s的最小成本
    cout << dp[n] << endl;

    return 0;
}