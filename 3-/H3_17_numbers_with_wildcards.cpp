/*
17. 带通配符的数
【问题描述】给定一个可以带通配符问号的正整数W，问号可以代表任意一个一位数字。再给定一个正整数X，和W具有同样的长度。问有多少个整数符合W的形式并且比X大？

【输入形式】多组数据，每组数据两行，第一行是W，第二行是X，它们长度相同，在[1..10]之间。

【输出形式】每行一个整数表示结果。

【样例输入】

36?1?8
236428
8?3
910
?
5

【样例输出】

100
0
4
*/

/*
 * @file: Number_with_Wildcards.cpp
 *
 * @brief:
 * 本文件实现了"带通配符的数"问题的解决方案。程序计算有多少个符合
 * 通配符模式 W 的整数，其值严格大于另一个给定的整数 X。
 *
 * @core_idea:
 * 采用按位比较和组合计数的思想，从高位到低位（从左到右）遍历两个字符串。
 * 核心逻辑是，在保证当前数字`Y`的前缀与`X`的前缀相同的情况下，在某一位`i`上让`Y[i]`大于`X[i]`，
 * 从而使整个数`Y`大于`X`。
 *
 * 1.  **逐位遍历**: 循环遍历每一位 `i`（从 0 到 `len-1`）。在每次迭代中，我们都假设
 * `Y`的前 `i-1` 位构成的数字前缀与 `X` 的前缀是完全匹配且符合`W`模式的。
 *
 * 2.  **计算“胜出”可能**: 在当前位 `i`，我们计算可以使 `Y[i]` 大于 `X[i]` 的方法数。
 * -   如果 `W[i]` 是 '?'，那么 `Y[i]` 可以选择的数字范围是 `(X[i]-'0' + 1)` 到 `9`。
 * -   如果 `W[i]` 是一个固定数字，只有当它严格大于 `X[i]` 对应的数字时，才有1种选择。
 *
 * 3.  **组合计算后缀**: 一旦我们在第 `i` 位确定了 `Y[i] > X[i]`，那么 `Y` 的后续所有位
 * （从 `i+1` 到末尾）就可以任意选择符合 `W` 模式的数字了，因为此时 `Y` 已经确定大于 `X`。
 * 我们只需计算 `W` 的后缀中有多少个 '?'，记为 `q_suffix_count`，那么后续位就
 * 有 `10^q_suffix_count` 种组合方式。将当前位的选择数乘以这个组合数，累加到总数中。
 *
 * 4.  **维持前缀匹配**: 在计算完第 `i` 位“胜出”的情况后，我们需要判断前缀匹配是否还能继续。
 * 如果 `W[i]` 是一个固定数字且不等于 `X[i]`，那么前缀匹配就此中断。由于
 * `W[i] > X[i]` 的情况已经在上面计算过，这里只剩下 `W[i] < X[i]` 的情况，
 * 后续构成的任何数都不可能再大于 `X`，因此可以直接终止整个遍历。
 * 如果 `W[i]` 是 '?' 或等于 `X[i]`，则说明前缀可以继续匹配，循环进入下一位。
 *
 * @time_complexity: O(L^2)
 * L 是输入字符串的长度。外层循环遍历 L 次，内层为了计算后缀 '?' 的数量也需要
 * 遍历，导致 L^2 的复杂度。鉴于 L 最大为10，这个效率完全满足要求。
 * (注：可以通过预处理后缀'?'数量，将复杂度优化到 O(L))
 *
 * @space_complexity: O(1)
 * 除了存储输入的字符串外，只使用了常数级别的额外空间。
 */

#include <iostream>
#include <string>
#include <vector>

// 为了代码简洁，直接使用 std 命名空间
using namespace std;

// 自定义整数幂函数，以避免使用<cmath>中的pow()可能带来的浮点误差，更适合算法题
long long integer_power(int base, int exp) {
    long long result = 1;
    for (int i = 0; i < exp; ++i) {
        result *= base;
    }
    return result;
}

// 主解决函数
void solve() {
    string W, X;
    // 循环读取多组数据，直到输入结束 (EOF)
    while (cin >> W >> X) {
        int len = W.length();
        long long totalCount = 0;

        // 从最高位（左边）开始，逐位进行比较和计数
        for (int i = 0; i < len; ++i) {
            // **步骤1: 计算在当前位 i “胜出” (即 Y[i] > X[i]) 的方法数**
            // 这个计算的前提是 Y[0...i-1] 与 X[0...i-1] 严格相等
            long long choicesForCurrentDigit = 0;
            if (W[i] == '?') {
                // 如果W[i]是通配符，Y[i]可以选择的数字是比X[i]大的所有数字
                choicesForCurrentDigit = 9 - (X[i] - '0');
            } else {
                // 如果W[i]是固定数字，只有当它严格大于X[i]时，才有1种选择
                if ((W[i] - '0') > (X[i] - '0')) {
                    choicesForCurrentDigit = 1;
                }
            }

            // 如果在当前位可以胜出
            if (choicesForCurrentDigit > 0) {
                // 那么后续的所有 '?' 位置都可以填任意0-9的数字
                // 计算后缀中 '?' 的数量
                int suffixQuestionMarkCount = 0;
                for (int j = i + 1; j < len; ++j) {
                    if (W[j] == '?') {
                        suffixQuestionMarkCount++;
                    }
                }
                // 累加这部分产生的、所有符合条件的数的数量
                totalCount += choicesForCurrentDigit * integer_power(10, suffixQuestionMarkCount);
            }

            // **步骤2: 判断前缀匹配是否可以继续**
            // 如果 W[i] 是固定数字且不等于 X[i]，那么前缀匹配就此中断。
            // Y[i] > X[i] 的情况已在上面处理过，剩下的就是 Y[i] < X[i] 的情况，
            // 这种情况下 Y 永远无法大于 X，故可提前结束循环。
            if (W[i] != '?' && W[i] != X[i]) {
                break;
            }
        }
        cout << totalCount << endl;
    }
}

int main() {
    // 提高C++标准输入输出流的效率
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solve();

    return 0;
}

/*
 * ========================================
 * 测试用例与执行分析
 * ========================================
 *
 * 【样例输入】
 * 36?1?8
 * 236428
 *
 * 【代码执行流程】
 * 1. 读入 W="36?1?8", X="236428"。
 * 2. i = 0: W[0]='3', X[0]='2'。
 * - 计算胜出可能: '3' > '2'，有1种选择。
 * - 后缀 "6?1?8" 中有2个 '?'。
 * - 贡献量 = 1 * 10^2 = 100。totalCount = 100。
 * - 判断前缀匹配: W[0] != X[0]，前缀匹配中断。break。
 * 3. 循环结束。输出 totalCount = 100。
 *
 * 【样例输入】
 * ?
 * 5
 *
 * 【代码执行流程】
 * 1. 读入 W="?", X="5"。
 * 2. i = 0: W[0]='?', X[0]='5'。
 * - 计算胜出可能: Y[0] > '5'，Y[0] 可以是 6,7,8,9。有 9-5=4 种选择。
 * - 后缀为空，'?' 数量为 0。
 * - 贡献量 = 4 * 10^0 = 4。totalCount = 4。
 * - 判断前缀匹配: W[0]是'?'，可以等于X[0]，匹配可以继续。
 * 3. 循环结束。输出 totalCount = 4。
 */