/*2. 数字统计
【问题描述】

给定一个k位整数N = dk-1*10k-1 + ... + d1*101 + d0 (0<=di<=9, i=0,...,k-1, dk-1>0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。

【输入形式】

每个输入包含1个测试用例，即一个不超过1000位的正整数N。

【输出形式】

对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出

【样例输入】

100311
【样例输出】

0:2
1:3
3:1
*/
/**
 * @file Digit_Statistics.cpp
 * @brief 统计一个大整数中各位数字出现的次数。
 *
 * 核心思路:
 * 1.  问题中的整数N最多可达1000位，远超任何标准整型（如`long long`）的表示范围。
 * 因此，最直接且有效的方法是将其作为字符串（`std::string`）来读取和处理。
 * 2.  为了统计0-9这10个数字的出现次数，我们可以使用一个大小为10的整型数组或`std::vector`作为频率映射表（哈希表）。
 * 数组的下标（0到9）直接对应数字本身，存储的值就是该数字出现的次数。
 * 3.  遍历读入的数字字符串中的每一个字符。对于每个字符`ch`，通过`ch - '0'`操作将其转换为对应的整数值`d`，
 * 然后将频率表中索引为`d`的计数器加一。
 * 4.  遍历完成后，频率表就存储了所有数字的出现次数。题目要求按数字的升序输出，
 * 我们只需从0到9遍历频率表，如果某个数字的计数不为0，就按`D:M`的格式输出。
 *
 * 时间复杂度: O(K)
 * K是输入整数N的位数（即字符串的长度）。我们需要遍历一次字符串来统计，以及遍历一次大小固定的频率表（常数时间），
 * 所以总时间复杂度与字符串长度成正比。
 *
 * 空间复杂度: O(K)
 * 主要用于存储输入的数字字符串。频率表的大小是常数10，因此额外空间复杂度为O(1)。
 */

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// 使用标准命名空间，简化代码
using namespace std;

int main() {
    // 加速C++ I/O操作，对于大数据量输入尤其重要
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 声明一个字符串变量，用于存储不超过1000位的正整数N
    string numberString;
    cin >> numberString;

    // 创建一个大小为10的向量作为频率计数器，索引i对应数字i的出现次数。
    // vector<int>(10, 0) 初始化一个包含10个元素且所有元素均为0的向量。
    vector<int> digitCounts(10, 0);

    // 使用C++11的范围for循环遍历输入字符串中的每个字符
    // 这是遍历容器或字符串的现代化、更安全、更可读的写法
    for (char digitChar : numberString) {
        // 将字符'0'-'9'转换为对应的整数0-9
        // 例如，'3' - '0' 的结果是整数 3
        int digit = digitChar - '0';

        // 对应数字的计数器加1
        digitCounts[digit]++;
    }

    // 按题目要求的升序格式（D:M）输出结果
    // 循环遍历0到9
    for (int i = 0; i < 10; ++i) {
        // 检查当前数字i是否在输入的整数N中出现过
        if (digitCounts[i] > 0) {
            // 如果出现过（计数大于0），则按格式输出该数字及其出现次数
            cout << i << ":" << digitCounts[i] << endl;
        }
    }

    return 0;
}