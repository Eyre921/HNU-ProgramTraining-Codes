 /*13. 导弹防御系统
【问题描述】

某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。

【输入形式】

每组输入有两行，

第一行，输入雷达捕捉到的敌国导弹的数量k（k<=25），

第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。

【输出形式】

每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。

【样例输入】

8
300 207 155 300 299 170 158 65
【样例输出】

6
*/
/**
 * @file Missile_Defense_System.cpp
 * @brief 使用动态规划计算最长非递增子序列。
 *
 * 核心思路:
 * 这个问题本质上是求解一个序列的“最长非递增子序列”（Longest Non-Increasing Subsequence, LNIS）。
 * “非递增”意味着序列中的后一个元素小于或等于前一个元素（a[i] >= a[j] for i < j）。
 * 这完全符合题目中“以后每一发炮弹都不能高于前一发的高度”的描述。
 *
 * 我们采用经典的动态规划（Dynamic Programming）方法来解决：
 * 1.  状态定义：我们定义一个DP数组 `dp`，其中 `dp[i]` 表示以第 `i` 枚导弹（即 `heights[i]`）
 * 作为结尾的拦截序列，其最长可能达到的长度。
 *
 * 2.  状态转移方程：为了计算 `dp[i]`，我们需要考虑在它之前的所有导弹 `j` (0 <= j < i)。
 * 如果 `heights[j] >= heights[i]`，这意味着第 `i` 枚导弹可以被接在以第 `j` 枚导弹结尾的
 * 拦截序列之后。这样就形成了一个更长的，以 `heights[i]` 结尾的拦截序列，其长度为 `dp[j] + 1`。
 * 我们要找的是最长的那个，所以需要遍历所有满足条件的 `j`，并取 `dp[j] + 1` 的最大值。
 * 因此，状态转移方程为：
 * `dp[i] = max(dp[i], dp[j] + 1)`  (对于所有 `0 <= j < i` 且 `heights[j] >= heights[i]`)
 *
 * 3.  初始化：对于任何一枚导弹，它自身都可以构成一个长度为1的拦截序列。
 * 所以我们将 `dp` 数组的所有元素初始化为1。
 *
 * 4.  最终结果：最长的拦截序列不一定以最后一枚导弹结尾。它可能以任何一枚导弹结尾。
 * 因此，最终的答案是整个 `dp` 数组中的最大值。
 *
 * 时间复杂度: O(k^2)
 * 我们使用两层嵌套循环来填充DP表。外层循环 k 次，内层循环最多 k 次。
 * 对于 k<=25 的小数据规模，这个复杂度是完全可以接受的。
 *
 * 空间复杂度: O(k)
 * 我们需要一个大小为 k 的DP数组和一个大小为 k 的数组来存储导弹高度。
 */

#include <iostream>
#include <vector>
#include <algorithm>

// 使用标准命名空间，简化代码
using namespace std;

int main() {
    // 加速C++ I/O操作
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int k;
    // 虽然题目看似描述单个测试用例，但在很多平台中可能会有多组输入。
    // 使用 while(cin >> k) 结构可以优雅地处理单组或多组输入的情况。
    while (cin >> k) {
        if (k <= 0) {
            cout << 0 << endl;
            continue;
        }

        // 存储k枚导弹的高度
        vector<int> heights(k);
        for (int i = 0; i < k; ++i) {
            cin >> heights[i];
        }

        // dp[i] 表示以第 i 枚导弹结尾的最长拦截序列的长度
        // 初始化为1，因为每枚导弹自身至少可以形成长度为1的序列
        vector<int> dp(k, 1);

        // 填充DP表
        // i 从 1 开始，因为它需要与前面的元素比较
        for (int i = 1; i < k; ++i) {
            // 遍历 i 之前的所有导弹 j
            for (int j = 0; j < i; ++j) {
                // 如果找到一个可以放在第 i 枚导弹之前的导弹 j
                // (即 j 的高度不小于 i 的高度)
                if (heights[j] >= heights[i]) {
                    // 尝试用 dp[j] + 1 来更新 dp[i]，看是否能得到更长的序列
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }

        // 最终结果是dp数组中的最大值，因为它可能在任何位置结束
        // 使用STL的 *max_element 算法可以方便地找到最大值
        cout << *max_element(dp.begin(), dp.end()) << endl;
    }

    return 0;
}