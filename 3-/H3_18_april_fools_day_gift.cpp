/*
18. 愚人节的礼物
【问题描述】

四月一日快到了，Vayko 想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko 为了愚人，准备了一堆盒子，其中只有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。用()表示一个盒子，B表示礼物，Vayko 想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。

【输入形式】

本题目包含多组测试，请处理到文件结束。每组测试包含一个长度不大于 1000, 只包含'(',')'和'B'三种字符的字符串，代表 Vayko 设计的礼物透视图。你可以假设，每个透视图画的都是合法的。

【输出形式】

对于每组测试，请在一行里面输出愚人指数。

【样例输入】

((((B)()))())
(B)
【样例输出】

4
1
*/

/**
 * @file AprilFoolsGift_Corrected.cpp
 * @brief 核心思路:
 * 经过复盘，此前的解法未能正确处理盒子并列的情况，现修正如下。
 * 本题的“愚人指数”即“最少需要拆多少个盒子”，这等价于礼物`B`在盒子结构中的实际嵌套深度。
 *
 * 1.  **动态深度追踪:** 我们可以通过一次线性扫描，用一个计数器 `currentDepth` 实时追踪当前位置的嵌套深度。这个计数器完美地模拟了栈的行为：
 * -   `currentDepth` 初始化为0，代表在所有盒子之外。
 * -   从左到右遍历字符串。
 * -   当遇到一个左括号 `(` 时，意味着我们进入了更深一层（打开了一个新盒子），因此将 `currentDepth` 加一。
 * -   当遇到一个右括号 `)` 时，意味着我们从当前盒子中退出，返回到上一层，因此将 `currentDepth` 减一。
 * -   当遇到礼物 `B` 时，遍历即可停止。此时的 `currentDepth` 值，精确地代表了 `B` 被多少层盒子所包裹，这也就是需要打开的最少盒子数量。
 *
 * 2.  **优势:** 这种“深度计数器”的方法，相比于先用栈去简化字符串再计数的思路，在实现上更简洁，并且在单次遍历中直接得出结果，
 * 避免了额外的数据结构开销和二次处理，效率上更胜一筹。它正确地处理了所有合法嵌套结构，包括并列盒子（如 `((A)(B))`）的情况。
 *
 * @time_complexity O(P)，其中 P 是字符 'B' 在输入字符串中的位置。我们只需要遍历到 'B' 出现即可。
 * 在最坏情况下 P 接近于字符串长度 N，此时复杂度为 O(N)。
 * @space_complexity O(1)，我们只需要一个额外的整数变量来存储当前的深度，空间开销为常数。
 */

#include <iostream>
#include <string>

// 使用标准命名空间，以符合题目要求简化代码
using namespace std;

int main() {
    // 优化C++标准流的I/O性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    string giftLayout;
    // 循环读取每一行输入，直到文件结束 (EOF)，以处理多组测试数据
    while (cin >> giftLayout) {
        int currentDepth = 0; // 用于精确追踪当前盒子的嵌套深度

        // 遍历字符串中的每一个字符
        for (char symbol : giftLayout) {
            if (symbol == '(') {
                // 每遇到一个左括号，意味着进入一个新盒子，深度加一
                currentDepth++;
            } else if (symbol == ')') {
                // 每遇到一个右括号，意味着关闭并离开一个盒子，深度减一
                currentDepth--;
            } else if (symbol == 'B') {
                // 遇到礼物 B，任务完成。此时的深度就是需要打开的盒子数。
                // 输出结果并立即跳出循环，开始处理下一个测试用例。
                cout << currentDepth << endl;
                break;
            }
        }
    }

    return 0;
}