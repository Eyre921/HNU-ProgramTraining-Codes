/*
8. 良心树
【问题描述】

      给定一颗有根树，顶点编号为1~n，树是一个无环的连通图，有根树有一个特定的顶点，称为根。

      顶点i的祖先是从根到顶点i的路径上除顶点 i 以外的所有顶点，顶点 i 的父母是 i 的祖先中最接近 i 的顶点，每个顶点都是它父母的孩子。在给定的树中，顶点 i 的父母是顶点pi，对于根，pi为-1。例如：

QQ图片20210629145621.png

      这是一个n=8个顶点的树，根为5， 顶点2的父母为3，顶点1的父母为5,6的祖先为4和5，7的祖先为8、3和5。

      在树中，其中一些顶点不尊重其他一些顶点，实际上，如果ci =1，表示顶点 i 不尊重它的所有祖先，而如果ci =0，则表示它尊重它所有的祖先。

      你需要一个一个地删除一些顶点，在每一步中，选择一个非根顶点，它不尊重它的父母并且它的所有孩子顶点也不尊重它。如果有几个这样的顶点，你需要选择具有最小编号的顶点。当你删除了这样的一个顶点v , 则v 的所有子顶点与v 的父母顶点相连。

QQ图片20210629150825.png

        上图是删除顶点7的示例。

         直到树中无满足删除标准的顶点，则上述过程停止。按顺序输出你删除的所有顶点，注意这个顺序的唯一的。

【输入形式】

         输入的第一行为一个整数 n (1≤ n ≤105)，表示树的顶点数。

         接下来的 n 行描述了整颗树：第 i 行包含两个整数 pi 和 ci (1≤ pi ≤ n,  0≤  ci ≤1)，这里 pi 是顶点i 的父母，若ci=0，表示顶点 i 尊重它的父母，ci=1，表示顶点 i 不尊重它的父母，pi=-1时，表示顶点 i 是树的根，同时 ci=0。

【输出形式】

         如果树中至少有一个顶点被删除，则按照顺序输出顶点编号，否则输入-1。

【样例输入1】

5
3 1
1 1
-1 0
2 1
3 0
【样例输出1】

1 2 4
【样例输入2】

5
-1 0
1 1
1 1
2 0
3 0
【样例输出2】

-1
【样例输入3】

8
2 1
-1 0
1 0
1 1
1 1
4 0
5 1
7 0
【样例输出3】

5
【样例说明】
第一个样例的删除过程如下（在图中，ci=1的顶点是黄色的）

首先删除顶点1，因为它不尊重祖先并且它的所有孩子也不尊重它，而1是这样的顶点中编号最小的

删除后顶点2将连接到顶点3

然后删除顶点2，因为它不尊重祖先并且它的所有孩子也不尊重它。

顶点4将连接到顶点3

然后删除顶点4，因为它不尊重祖先，并且它的所有孩子也不尊重它（无孩子）

无更多顶点可删

QQ图片20210629153821.png

在第二个样例中，无需删除顶点

顶点2和3的孩子尊重它们

顶点4和5尊重它们的祖先

QQ图片20210629154127.png

在第三个样例中显示如下

QQ图片20210629154254.png
*/
/*
 * 核心思路:
 * 这是一个在树上进行迭代删除的问题。关键在于正确理解删除条件以及删除操作对其他节点状态的影响。
 *
 * 1. 删除条件分析:
 * 一个非根节点 `v` 可以被删除，当且仅当满足两个条件：
 * a) `v` 不尊重其父节点，即 `c[v] = 1`。
 * b) `v` 的所有孩子 `u` 都不尊重 `v`，即对于 `v` 的所有孩子 `u`，都有 `c[u] = 1`。
 *
 * 2. 关键洞察 (简化问题):
 * 我们需要分析一次删除操作是否会改变其他节点的“可删除”状态。
 * - 节点 `x` 的可删除状态取决于 `c[x]` 的值以及其所有孩子的 `c` 值。
 * - `c` 值是静态的，在整个过程中不会改变。
 * - 当我们删除节点 `v` 时，`v` 的孩子们 `u` 会被重新连接到 `v` 的父节点 `p`。
 * 这改变了 `p` 的孩子集合。
 * - 让我们分析 `p` 的可删除状态是否会因此改变。`p` 的可删除性取决于它是否有“尊重”它的孩子
 * （即 `c` 值为 0 的孩子）。
 * - 在删除 `v` 之前，`v` 是 `p` 的一个孩子。因为 `v` 要被删除，必有 `c[v] = 1`，所以 `v`
 * 是一个“不尊重”的孩子，它对 `p` 的“尊重孩子数”没有贡献。
 * - `v` 的孩子们 `u` 也都满足 `c[u] = 1`，所以它们也都是“不尊重”的孩子。
 * - 当 `v` 被删除，`p` 失去了孩子 `v`，并获得了 `v` 的所有孩子 `u`。在这个过程中，`p` 失去了一个不尊重的孩子，
 * 又获得了一堆不尊重的孩子。
 * - 因此，`p` 的“尊重”它的孩子的数量没有发生任何变化！
 * - 惊人的结论：删除一个节点 `v` 不会改变其父节点 `p` 的可删除状态，也不会影响任何其他节点。
 * 这意味着一个节点是否可删除，仅取决于树的初始结构和所有节点的 `c` 值，它是一个静态属性。
 *
 * 3. 简化后的算法:
 * 既然删除操作不影响其他节点的可删除性，问题就从一个复杂的动态模拟简化为了一个简单的静态检查。
 * 我们不再需要模拟删除和重连过程。我们只需要在初始状态下，找出所有满足删除条件的节点即可。
 * a. 根据输入的父节点指针，建立每个节点的子节点列表。
 * b. 遍历所有节点，计算每个节点拥有多少个“尊重”它的孩子（`c` 值为 0 的孩子）。
 * c. 再次遍历所有节点 `i`（从1到n），检查它是否满足删除条件：
 * - `c[i] == 1`
 * - `i` 的“尊重”它的孩子的数量为 0。
 * d. 将所有满足条件的节点收集起来。由于题目要求每次删除编号最小的，而我们的分析表明
 * 所有可删除节点从一开始就确定了，所以我们只需将所有这些节点按编号从小到大输出即可。
 *
 * 时间复杂度: O(N)
 * - N是树的顶点数。建树、计算尊重子节点数、检查删除条件都只需要遍历一次所有节点或边，因此算法是线性的。
 *
 * 空间复杂度: O(N)
 * - 需要 O(N) 的空间来存储树的结构（父节点、子节点列表等）。
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void solve() {
    int n;
    cin >> n;

    // 存储每个节点的父节点和 c 值
    vector<int> parents(n + 1);
    vector<int> respects(n + 1);

    // 建立每个节点的子节点列表，用于后续统计
    vector<vector<int>> children(n + 1);

    for (int i = 1; i <= n; ++i) {
        int p, c;
        cin >> p >> c;
        parents[i] = p;
        respects[i] = c;
        if (p != -1) {
            children[p].push_back(i);
        }
    }

    // 核心步骤1: 计算每个节点拥有多少个“尊重”它的孩子 (c[child] == 0)
    vector<int> respectful_children_count(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        // 遍历 i 的所有孩子，统计其中 c 值为 0 的个数
        for (int child_node : children[i]) {
            if (respects[child_node] == 0) {
                respectful_children_count[i]++;
            }
        }
    }

    // 核心步骤2: 找出所有在初始状态下就满足删除条件的节点
    vector<int> nodes_to_delete;
    for (int i = 1; i <= n; ++i) {
        // 删除条件:
        // 1. 非根节点 (parents[i] != -1)
        // 2. 不尊重其父节点 (respects[i] == 1)
        // 3. 所有孩子都不尊重它 (即，尊重它的孩子数量为 0)
        if (parents[i] != -1 && respects[i] == 1 && respectful_children_count[i] == 0) {
            nodes_to_delete.push_back(i);
        }
    }

    // 输出结果
    if (nodes_to_delete.empty()) {
        cout << -1 << endl;
    } else {
        // 由于我们是按 1 到 n 的顺序检查并添加，nodes_to_delete 自然就是按编号升序的
        for (size_t i = 0; i < nodes_to_delete.size(); ++i) {
            cout << nodes_to_delete[i] << (i == nodes_to_delete.size() - 1 ? "" : " ");
        }
        cout << endl;
    }
}

int main() {
    // 优化C++标准库的I/O性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solve();

    return 0;
}