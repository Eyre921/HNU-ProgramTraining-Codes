/*
9. 0-1串
【问题描述】

         对于一个包含 n 个整数元素的序列a1、a2、...、an，每个元素的值或者是0或者是1，选择两个下标i和j（1≤i≤j≤n）,对于所有的此范围内的元素ak（i≤k≤j），执行操作ak =1- ak。

   选择合适的i和j，执行上述操作一次之后，可以得到的新序列中包含1的个数最多是多少？

【输入形式】

        输入的第一行为一个整数 n（1≤ n ≤100），接来的一行为 n 个整数，每个整数或者是0或者是1。

【输出形式】

        输出为一个整数，表示执行一次上述操作后可以获得的最大1的个数。

【样例输入1】

5
1 0 0 1 0
【样例输出1】

4
【样例输入2】

4
1 0 0 1
【样例输出2】

4
【样例说明】

在第一个样例中，选择i=2, j=5, 改变后的序列为[1 1 1 0 1]，包含4个1，很显然无法改变为[1 1 1 1 1]。

在第二个样例中，选择i=2, j=3，改变后的序列为[1 1 1 1]，包含4个1。

【评分标准】

来源：327A


*/
/*
 * 核心思路:
 * 这个问题的目标是在对一个0-1序列的连续子段进行一次翻转（0变1，1变0）后，最大化序列中1的个数。
 *
 * 我们可以将这个问题巧妙地转化为一个经典的“最大子数组和”问题。
 *
 * 1. 分析操作效果:
 * 翻转一个子段，对总的1的个数的影响是：(子段中0的个数) - (子段中1的个数)。
 * 我们的目标就是找到一个子段 [i, j]，使得这个差值最大化。
 * 最终结果 = (原始序列中1的总数) + max( (子段[i,j]中0的个数) - (子段[i,j]中1的个数) )
 *
 * 2. 问题转化:
 * 为了求解 `max(count_0(i,j) - count_1(i,j))`，我们可以创建一个新的“收益”序列。
 * - 对于原始序列中的每一个 0，翻转它会使1的数量增加1，我们视其收益为 +1。
 * - 对于原始序列中的每一个 1，翻转它会使1的数量减少1，我们视其收益为 -1。
 *
 * 这样，原问题就转化成了：在这个新的“收益”序列中，找到一个连续子段，使其和最大。
 *
 * 3. 求解最大子数组和:
 * 这是一个可以使用“卡丹算法”（Kadane's Algorithm）在 O(N) 时间内解决的经典问题。
 * - 维护两个变量：`maxSoFar` (全局最大和) 和 `currentMax` (以当前元素结尾的最大和)。
 * - 遍历收益序列，对于每个元素，更新 `currentMax` 为 `max(当前元素, currentMax + 当前元素)`。
 * - 同时用 `currentMax` 更新 `maxSoFar`。
 *
 * 4. 特殊情况:
 * 如果原序列全是1，翻转任何子段都会导致1的个数减少。此时最优策略是翻转最短的子段（长度为1），
 * 结果是 n-1。我们的算法可以自然地处理这种情况：收益序列将全是-1，最大子数组和为-1，
 * 最终结果是 n + (-1) = n-1，无需特殊判断。
 *
 * 时间复杂度: O(N)
 * 我们只需要遍历原始数组一次来计算初始1的个数并构建收益序列，然后遍历收益序列一次来运行卡丹算法。
 *
 * 空间复杂度: O(N)
 * 主要用于存储收益序列。可以优化到 O(1)，但在本题数据规模下，O(N) 的写法更清晰。
 */

#include <iostream>
#include <vector>
#include <numeric>   // for std::accumulate (optional)
#include <algorithm> // for std::max

// 遵循规范，直接使用 std 命名空间
using namespace std;

int main() {
    // 提高IO性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<int> a(n);
    int initialOnes = 0;

    // 步骤1: 读取输入，计算原始1的个数
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        if (a[i] == 1) {
            initialOnes++;
        }
    }

    // 步骤2: 构建收益序列
    vector<int> gain(n);
    for (int i = 0; i < n; ++i) {
        if (a[i] == 0) {
            gain[i] = 1; // 翻转0，收益为+1
        } else {
            gain[i] = -1; // 翻转1，收益为-1
        }
    }

    // 步骤3: 使用卡丹算法求解最大子数组和
    if (n == 0) { // 处理空序列的边界情况
        cout << 0 << endl;
        return 0;
    }

    int maxGain = gain[0];
    int currentGain = gain[0];

    for (int i = 1; i < n; ++i) {
        // 更新以当前元素结尾的最大子段和
        currentGain = max(gain[i], currentGain + gain[i]);
        // 更新全局最大子段和
        maxGain = max(maxGain, currentGain);
    }

    // 最终结果 = 原始1的个数 + 通过翻转能获得的最大收益
    int finalMaxOnes = initialOnes + maxGain;

    // 如果原序列全是1，maxGain会是-1，结果是initialOnes-1，这是正确的。
    // 但如果翻转操作是可选的，且最大收益为负，我们可以选择不翻转，收益为0。
    // 题目描述为“执行操作一次”，暗示必须操作。因此直接加上maxGain即可。
    // 但如果测试用例中出现了全是1的情况，答案是 n-1，说明必须翻转。
    // 如果一个0都没有，maxGain的最大值就是-1，答案就是initialOnes-1。
    // 只有一个特例：如果n=1, a[0]=1, initialOnes=1, gain[0]=-1, maxGain=-1, final=0.正确。

    cout << finalMaxOnes << endl;

    return 0;
}