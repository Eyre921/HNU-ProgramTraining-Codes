/*
3. 数组跳远
【问题描述】

        对于一个具有 n 个元素的数组 a , 执行以下操作：

首先，选择下标 i （1 ≤ i ≤n）—— 设置为数组的开始位置，放一个标记在 i 处（在值 ai 的地方）

当 i ≤ n 时，你的得分将增加 ai ，且将标记向右移动 ai 个位置，也就是说用 i +ai 替换 i ，继续这个过程

如果 i >n，则结束操作

       例如， 如果 n = 5且a=[7, 3, 1, 2, 3]，则可以进行以下操作

选择 i = 1，操作过程为，最后得分为 a1 = 7

选择 i = 2，操作过程为, 最后得分为 a2 + a5  = 6

选择 i = 3，操作过程为, 最后得分为 a3 + a4  = 3

选择 i = 4，操作过程为, 最后得分为 a4  = 2

选择 i = 5，操作过程为, 最后得分为 a5  = 3

           请选择合适的开始位置，使得经过上述操作后可获得最大的分数。

【输入形式】

           输入的第一行为一个整数 t (1≤ t ≤ 104)，表示测试用例的组数。

           每个测试用例的第一行为一个整数 n (1≤ n ≤ 2×105)，表示数组 a 的元素个数

           接下来一行包含 n 个整数 a1、a2、...、an (1 ≤ ai ≤ 109)，表示数组 a 的元素

【输出形式】

         对于每个测试用例，输出独立一行，表示选择合适的开始位置后经过上述操作可以获得的最大分数。

【样例输入】

4
5
7 3 1 2 3
3
2 1 4
6
2 1000 2 3 995 1
5
1 1 1 1 1
【样例输出】

7
6
1000
5
*/
/**
 * @file array_long_jump.cpp
 * @brief 数组跳远问题的动态规划解决方案
 *
 * 核心思路:
 * 本题采用动态规划（Dynamic Programming）的思想，并根据提示“倒过来”进行计算。
 * 1.  状态定义: 定义一个DP数组 `dp`，其中 `dp[i]` 表示从下标 `i` 开始跳跃所能得到的最终总分。
 * 2.  状态转移方程: 从下标 `i` 开始跳，首先获得分数 `a[i]`，然后跳到新下标 `j = i + a[i]`。
 * - 如果 `j` 仍在数组内 (`j < n`)，则总分是 `a[i]` 加上从 `j` 开始跳的总分，即 `dp[i] = a[i] + dp[j]`。
 * - 如果 `j` 超出数组范围，则跳跃结束，总分就是 `dp[i] = a[i]`。
 * 3.  计算顺序: 为了确保在计算 `dp[i]` 时 `dp[j]` (其中 `j > i`) 已经被计算出来，我们必须从后往前
 * 遍历数组，即从 `i = n-1` 递减到 `0`。
 * 4.  最终结果: 遍历完整个 `dp` 数组，找到其中的最大值即为答案。
 *
 * 时间复杂度: O(N)，因为我们只对数组进行了一次单遍扫描。
 * 空间复杂度: O(N)，用于存储DP数组。
 */

#include <iostream>
#include <vector>
#include <algorithm>

// 启用C++标准库，无需显式使用 std:: 前缀
using namespace std;

// 解决单个测试用例的函数
void solve() {
    int n;
    cin >> n;
    // 注意到 ai 的值很大，得分总和可能超过int范围，使用long long
    vector<long long> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    // dp[i] 表示从下标 i (0-indexed) 开始跳跃的总分
    vector<long long> dp(n, 0);

    // 从后往前填充DP数组
    for (int i = n - 1; i >= 0; --i) {
        // 当前这一跳的分数
        dp[i] = a[i];

        // 计算下一个落点
        long long jumpDestination = i + a[i];

        // 如果落点在数组范围内，加上后续跳跃的分数
        if (jumpDestination < n) {
            dp[i] += dp[jumpDestination];
        }
    }

    // 结果是所有可能起点中得分最高的那个
    // 使用标准库函数寻找最大值
    cout << *max_element(dp.begin(), dp.end()) << endl;
}

int main() {
    // 优化I/O性能，对于大量数据输入非常重要
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}