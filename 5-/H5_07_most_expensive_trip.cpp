/*
7. 最昂贵的旅行
【问题描述】

       这个国家有 n 个城市，编号从0 ~ n-1，城市网络中没有任何环路，但可以从任意一个城市出发沿公路直接或间接到达其他城市。

        有人住在编号为0的城市里，他希望去其他的一个城市旅行，但他不想付出更多的成本，所以他想知道去哪个城市的成本是最高的。

【输入形式】

       输入的第一行为一个整数 n (3≤ n ≤100)，接下来的 n-1 行每行包括3个整数 u、v、c (0 ≤ u, v ≤ n-1，1≤  c  ≤104)，意为在城市 u 和 v 之间有公路直接相连，且旅行需要花费的成本为 c 。

【输出形式】

       输出为一个整数，表示从城市0出发去到其他的某个城市，需要付出的最大成本。

【样例输入1】

4
0 1 4
0 2 2
2 3 3
【样例输出1】

5
【样例输入2】

6
1 2 3
0 2 100
1 4 2
0 3 7
3 5 10
【样例输出2】

105
【样例输入3】

11
1 0 1664
2 0 881
3 2 4670
4 2 1555
5 1 1870
6 2 1265
7 2 288
8 7 2266
9 2 1536
10 6 3378
【样例输出3】

5551
*/
/*
 * 核心思路:
 * 题目描述了一个由 n 个城市和 n-1 条带权重的边组成的网络，且保证无环路，
 * 这正是一个树形结构。问题要求从指定的起点（城市0）出发，到其他所有城市的最长路径长度。
 *
 * 我们可以采用深度优先搜索（DFS）来系统地遍历这棵树，并在此过程中记录路径成本。
 *
 * 1. 数据结构:
 * - 使用邻接表 `vector<vector<pair<int, int>>> adj` 来存储这棵树。
 * `adj[u]` 存储一个列表，列表中的每个元素 `{v, c}` 表示城市 `u` 和 `v` 之间
 * 有一条成本为 `c` 的公路。
 *
 * 2. 深度优先搜索 (DFS) 函数:
 * - 我们设计一个递归函数 `dfs(u, parent, currentCost)`。
 * - `u`: 当前所在的城市顶点。
 * - `parent`: 我们是从哪个城市来到 `u` 的。这个参数至关重要，用于防止在树的遍历中走回头路。
 * - `currentCost`: 从起点城市0到当前城市 `u` 的累计旅行成本。
 *
 * 3. DFS 过程:
 * a. 初始化一个全局变量 `maxCost` 来记录迄今为止发现的最大成本。
 *
 * b. 从起点城市0开始调用 `dfs(0, -1, 0)`。
 * - 起点是0。
 * - 因为0是起点，它没有父节点，我们用一个无效的节点编号（如-1）来表示。
 * - 在起点的成本为0。
 *
 * c. 在 `dfs(u, ...)` 函数内部：
 * i.   首先，用当前的路径成本 `currentCost` 更新全局最大成本：
 * `maxCost = max(maxCost, currentCost)`。
 * ii.  遍历 `u` 的所有邻居 `v`（以及对应的成本 `c`）。
 * iii. 对于每一个邻居 `v`，只要它不是我们来的地方（`v != parent`），
 * 就对其进行递归调用：`dfs(v, u, currentCost + c)`。
 * 这相当于从 `u` 走向 `v`，路径成本也相应增加。
 *
 * 4. 最终结果:
 * - 当DFS遍历完所有从0可达的节点后，`maxCost` 中存储的就是最终的答案。
 *
 * 时间复杂度: O(N)
 * 因为图是树，有 N 个顶点和 N-1 条边。DFS会访问每个顶点和每条边恰好一次。
 *
 * 空间复杂度: O(N)
 * 主要由邻接表和递归调用栈的深度决定。在最坏的情况下（链状树），递归深度可达 O(N)。
 */

#include <iostream>
#include <vector>
#include <algorithm> // for std::max

// 遵循规范，直接使用 std 命名空间
using namespace std;

// 使用 pair<int, int> 来表示 {邻居节点, 边的成本}
using Edge = pair<int, int>;

// 全局变量来存储邻接表和最大成本
vector<vector<Edge>> adj;
int maxCost = 0;

// 深度优先搜索函数
void dfs(int u, int parent, int currentCost) {
    // 用当前到达 u 的成本更新全局最大成本
    maxCost = max(maxCost, currentCost);

    // 遍历 u 的所有邻居
    for (const auto& edge : adj[u]) {
        int v = edge.first;
        int cost = edge.second;

        // 如果邻居 v 不是我们来的父节点，就继续向下探索
        if (v != parent) {
            dfs(v, u, currentCost + cost);
        }
    }
}

int main() {
    // 提高IO性能
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // 调整邻接表大小以容纳 n 个城市 (0 到 n-1)
    adj.resize(n);

    // 读取 n-1 条边并构建邻接表
    for (int i = 0; i < n - 1; ++i) {
        int u, v, c;
        cin >> u >> v >> c;
        // 因为是无向边，需要在两个城市的邻接表中都添加对方
        adj[u].push_back({v, c});
        adj[v].push_back({u, c});
    }

    // 从城市 0 开始进行深度优先搜索
    // 起点是 0，父节点设为 -1 (不存在)，初始成本为 0
    dfs(0, -1, 0);

    // 输出最终找到的最大成本
    cout << maxCost << endl;

    return 0;
}