**CCF CSP** 计算机软件能力认证

CCF CSP

第 34 次认证

时间：2024 年 6 月 2 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 矩 阵 重 塑 （其一） | 矩 阵 重 塑 （其二） | 文本分词 | 货物调度 | 哥德尔机 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.5 秒 | 2.0 秒 | 5.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 1024 MiB |
| 子任务数目 | 10  | 20  | 10  | 20  | 20  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

矩阵重塑（其一）（reshape1）

【题目背景】

矩阵（二维）的重塑（reshape）操作是指改变矩阵的行数和列数， 同时保持矩阵中 元素的总数不变。

【题目描述】

矩阵的重塑操作可以具体定义为以下步骤：

设原矩阵为 M，其维度为 n × m，即有 n 行和 m 列。新矩阵为 M′，其维度为 p × q。 重塑操作要满足 n × m = p × q，这保证了元素的总数不变。

1\. 线性化原矩阵：按照行优先的顺序，将原矩阵 M 的元素转换成一个长度为 n × m 的一维数组 A。这意味着你先读取 M 的第 0 行元素，然后是第 1 行，依此类推， 直到最后一行。

2\. 填充新矩阵：使用一维数组 A 中的元素按照行优先的顺序填充新矩阵 M′ 。首先

. . . . .

填充 M′ 的第 0 行，直到该行有 q 个元素，然后继续填充第 1 行，直到所有 p 行 都被填满。

给定原矩阵中的一个元素的位置 (i, j)（0 ≤ i < n 且 0 ≤ j < m），我们可以找到这 个元素在被线性化后的一维数组 A 中的位置 k（0 ≤ k < n × m），然后确定它在新矩阵 M′ 中的位置 (i′ , j ′ )（0 ≤ i′ < p 且 0 ≤ j < q）。它们之间满足如下数学关系：

i × m + j = k = i′ × q + j′

给定 n × m 的矩阵 M 和目标形状 p 、q，试将 M 重塑为 p × q 的矩阵 M′。

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

输入的第一行包含四个正整数 n 、m 和 p 、q。

接下来依次输入原矩阵 M 的第 0 到第 n − 1 行，每行包含 m 个整数，按列下标从 0 到 m − 1 的顺序依次给出。

【输出格式】

输出到标准输出。

输出共 p 行，每行 q 个整数，表示重塑后的矩阵 M′。输出格式与输入相同， 即依 次输出 M′ 的第 0 行到第 p − 1 行；行内按列下标从 0 到 q − 1 的顺序输出，且两个整 数间仅用一个空格分隔。

【样例 1 输入】

1

2

3

2 3 3 2

1 2 3

4 5 6

【样例 1 输出】

1

2

3

1 2

3 4

5 6

【样例 2 输入】

1

2

3

1

2 2 1 4

6 6

6 6

【样例 2 输出】

6 6 6 6

【子任务】

全部的测试数据满足：

• n 、m 和 p 、q 均为正整数且 n × m = p × q ≤ 104；

• 输入矩阵中每个元素的绝对值不超过 1000。

【提示】

评测环境仅提供各语言的标准库， 特别地， 不提供任何线性代数库（如 numpy、 pytorch 等）。

矩阵重塑（其二）（reshape2）

【题目背景】

矩阵转置操作是将矩阵的行和列交换的过程。在转置过程中，原矩阵 A 的元素 aij 会移动到转置后的矩阵 AT 的 aji 的位置。这意味着 A 的第 i 行第 j 列的元素在 AT 中 成为了第 j 行第 i 列的元素。

例如，有矩阵 A 如下：

它的转置矩阵 AT 会是：

矩阵转置在线性代数中是一个基本操作，广泛应用于各种数学和工程领域。

【题目描述】

给定 n × m 的矩阵 M，试编写程序支持以下查询和操作：

1\. 重塑操作 p 、q：将当前矩阵重塑为 p × q 的形状（重塑的具体定义见上一题）；

2\. 转置操作：将当前矩阵转置；

. . . .

3\. 元素查询 i 、j：查询当前矩阵第 i 行 j 列的元素（0 ≤ i < n 且 0 ≤ j < m）。 依次给出 t 个上述查询或操作，计算其中每个查询的结果。

【输入格式】

从标准输入读入数据。

输入共 n + t + 1 行。

输入的第一行包含三个正整数 n 、m 和 t。

接下来依次输入初始矩阵 M 的第 0 到第 n - 1 行，每行包含 m 个整数，按列下标 从 0 到 m - 1 的顺序依次给出。

接下来输入 t 行，每行包含形如 op a b 的三个整数，依次给出每个查询或操作。 具体输入格式如下：

• 重塑操作： 1 p q

• 转置操作： 2 0 0

• 元素查询： 3 i j

【输出格式】

输出到标准输出。

每个查询操作输出一行，仅包含一个整数表示查询结果。

【样例 1 输入】

1

2

3

4

5

6

7

3 2 3

1 2

3 4

5 6

3 0 1

1 2 3

3 1 2

【样例 1 输出】

1

2

2

6

【样例 2 输入】

1

2

3

4

5

6

7

8

9

3 2 5

1 2

3 4

5 6

3 1 0

2 0 0

3 1 0

1 3 2

3 1 0

【样例 2 输出】

1

2

3

3

2

5

初始矩阵：  ，(1, 0) 位置元素为 3；

转置后：  位置元素为 2；

重塑后：  ，(1, 0) 位置元素为 5。

【子任务】

80% 的测试数据满足：

• t ≤ 100；

全部的测试数据满足：

• t ≤ 105 且其中转置操作的次数不超过 100；

• n 、m 和所有重塑操作中的 p 、q 均为正整数且 n × m = p × q ≤ 104；

• 输入矩阵中每个元素的绝对值不超过 1000。

【提示】

• 对于 n × m 的矩阵，虽然转置和重塑操作都可以将矩阵形态变为 m × n，但这两 种操作通常会导致不同的结果。

• 评测环境仅提供各语言的标准库，特别地，不提供任何线性代数库（如 numpy、 pytorch 等）。

文本分词（tokenizer）

【题目背景】

西西艾弗岛大数据中心正在如火如荼地开展大语言模型的研究工作。众所周知， 计 算机在执行机器学习的任务时， 更适合处理数字的数据。对于大语言文本的处理， 最好 的方式是将文本转化为数字， 然后再进行处理。通常， 对输入数据进行整理后， 需要将 其按照一定的规则进行编码，以便计算机能够更好地处理。

这一转换过程是通过词汇表进行的。词汇表是一个包含了所有可能出现的词的列 表。对于一个给定的文本， 可以按照该表格将文本转化为一个数字的序列。而词表也需 要根据文本的特点进行设计，以便更好地反映文本的特点。

【题目描述】

词汇表包括一系列的字符串， 可以用于将输入的文本转换为数字序列。这里， 我们 认为输入文本事先经过一定的处理，将字母统一转换为了小写字母。词汇表的生成过程 是一个迭代的过程。首先将文本按照一定的规则切分为单词序列， 并统计全部单词的出 现频率。然后将单词拆分为单字母字符串， 组成初始的词汇表。接下来根据词汇表中的 词汇接连出现在单词中的频率， 将词汇反复合并， 组成更长的词汇加入到词汇表中。词 汇表的具体生成过程如下：

首先，输入文本中所有的单词和其出现的频率。然后， 统计其中所有的字符， 将其 按照字典序排序， 并将这些字符作为单字母字符串加入到词汇表中。同时， 将输入的单 词相应切分为词汇序列。

例如，输入下列词组和频率：

1

2

3

4

cut 15

cute 10

but 6

execute 3

则执行完上述过程后， 词汇表中包含了 b、c、e、t、u、x 这些单字母字符串， 而 输入的词组被切分为：

1

2

3

4

c u t 15

c u t e 10 b u t 6

e x e c u t e 3

接下来，统计词汇表中， 两个词汇组成的“词汇对”相连出现的频率， 并选取出现 次数最多的那一组拼接为一个字符串加入词汇表中。如果存在多个这样的“词汇对”，则 再按照如下优先级顺序选取：

• 选取拼接后的字符串长度最短的那一组；

• 选取“词汇对”中前一个词汇长度最短的那一组；

• 选取拼接后的字符串字典序最小的那一组。

同时生成对应的合并规则（即将选出的“词汇对”合并成一个词汇）， 并按照该规 则将所有输入单词的词汇序列按从前到后的顺序依次加以合并。

例如，在上述单词列表中词汇组合 &lt;c, u&gt; 在单词 cut 、cute 和 execute 中分别 出现了 15 、10 和 3 次。相应统计全部的“词汇对”出现次数如下：

1

2

3

4

5

6

7

c u 28

u t 34

t e 13

b u 6

e x 3

x e 3

e c 3

于是，将 ut 加入词汇表中， 并生成合并规则 &lt;u, t&gt;，可得到词汇表 b、c、e、t、

u、x、ut。同时，将输入的单词切分为：

1

2

3

b ut 6

c ut 15

c ut e 10

上述过程可以重复进行。例如，继续统计“词汇对”出现的频率如下：

1

2

3

4

5

6

t

1

2

3

4

c ut 28

ut e 13 b ut 6 e x 3

x e 3

e c 3

这时，将 cut 加入词汇表中，并生成合并规则 &lt;c, ut&gt;，可得到词汇表 b、c、e、 、u、x、ut、cut。同时，将输入的单词切分为：

cut 15

cut e 10

b ut 6

e x e cut e 3

词汇表的生成， 需要重复进行上述过程， 直到词汇表达到指定的长度， 或者所有输 入的单词都被合并为一个词汇。

此外需要注意， 一种特殊情况是选取的“词汇对”由两个相同的词汇组成。例如 按“词汇对”&lt;a, a&gt; 进行合并时， 由于从前到后的顺序要求， 序列 a a a 会被合并为 aa a，而序列 a a a a 则会被合并为 aa aa。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个正整数， n 和 m，分别表示输入的单词的数量和期望的词汇 表长度。

接下来的 n 行，每行包含一个非空字符串 s 和一个正整数 f，表示输入的单词和其 出现的频率。其中， s 中只包含小写字母。

【输出格式】

输出共 m 行，每行包含一个字符串，按照加入词汇表的顺序输出词汇表中所有词 汇。

【样例 1 输入】

1

2

3

4

5

1

2

3

4

5

6

7

8

4 8

cut 15 cute 10 but 6

execute 3

【样例 1 输出】

b

c

e

t

u

x

ut

cut

【样例 1 解释】

该样例即为题目描述中所举的例子。

【子任务】

对 20% 的数据，有 n ≤ 200 ，m 恰好等于输入单词中出现的所有字母的个数。

对 40% 的数据，有 n ≤ 200 ，m ≤ 200。

对 80% 的数据，有 n ≤ 2000 ，m ≤ 2500。

对 100% 的数据，有 n ≤ 10000 ，m ≤ 5000 且大于等于输入单词中出现的所有字母 的个数，s 的长度 |s| ≤ 25，输入单词的总频率（f 的总和）不超过 106。文本取材于真 实的英文著作。

货物调度（trade）

【题目描述】

西西艾弗岛上共有 n 间物流仓库，小 P 目前有 m 件货物存放其中。为了获得至少 为 v 的现金，小 P 需要选取一些货物卖出。

已知货物信息如下，第 i 件（0 ≤ i < m）货物：

• 存放在第 ti 间仓库中（0 ≤ ti < n）；

• 价值为 ai，即选择卖出该货物可获得 ai 的现金。

但在调货出库时也需要支付一些费用，对于第 j 间（0 ≤ j < n）仓库：

• 只要调用了该仓库的货物（至少一件），就需要支付 bj 的基本费用；

• 如果调用了该仓库中共 k 件货物，则还需要支付 k × cj 的计件费用。

小 P 的最终目标是获得至少为 v 的现金， 即要求卖出的货物总价值减去总费用的 结果大于或等于 v。在满足该目标的前提下，试为小 P 规划一种花费最小的卖货方案。

【输入格式】

从标准输入读入数据。

输入的第一行包含三个正整数 n 、m 和 v。

接下来 n 行输入仓库信息，其中第 j 行（0 ≤ j < n）包含两个整数 bj 和 cj 。

接下来 m 行输入货物信息，其中第 i 行（0 ≤ i < m）包含两个整数 ai 和 ti。

【输出格式】

输出到标准输出。

仅输出一个整数，表示完成目标前提下的最小花费。

【样例 1 输入】

1

2

3

4

5

6

2 3 15

2 1

3 2

10 0

20 1

15 0

【样例 1 输出】

1

4

【样例 1 解释】

最优方案：选取货物 0 和 2，二者均在 0 号仓库，总花费为 2 + 2 × 1 = 4。 选取货物 1 也刚好能满足要求（20 − 3 − 1 × 2 ≥ 15），但花费更多。

单独选取货物 0 或 2 均不能满足要求。

【样例 2 输入】

1

2

3

4

5

6

7

8

9

5 3 15

2 1

1 1

3 2

4 2

1 5

10 1

10 1

10 1

【样例 2 输出】

1

3

【样例 2 解释】

小 P 所有货物均存放在仓库 1 中，任取两件货物卖出即可满足要求（10 + 10 − 1 − 2 × 1 ≥ 15）。

【子任务】

30% 的数据满足：

• m ≤ 15

另有 40% 的数据满足：

• ai ≤ 20

全部的数据满足：

• 0 < n, m ≤ 1000

• 0 < bj , cj ≤ 20

• 0 < ai ≤ 1000

• 0 < v ≤ 106 且保证至少存在一种可满足要求的卖货方案。

哥德尔机（Goedel）

【题目背景】

ReLU 函数是机器学习中常用的一个激活函数，其定义为： ReLU(x) = max (0, x)。

【题目描述】

在西西艾弗岛上有一台基于哥德尔机原理设计的通用人工智能机器，小 C 是负责 维修这台机器的机器人。

有一天小 C 发现这个机器在一个算法部分上遇到了计算瓶颈，这个算法是这样的：

机器内部维护了一个神经网络，这个神经网络的权重是一个二维矩阵 V ，并且权重 是一个整数。

即对于每个二维坐标 (x, y)，矩阵在该位置的权重是 V (x, y)，初始权重为 0。

神经网络会进行 n 轮学习操作，每轮学习会给出参数 x1 , x2 , y1 , y2 , v，然后对每个 满足 x1 ≤ x ≤ x2 , y1 ≤ y ≤ y2 的 (x, y)，将该位置对应的神经网络权重 V (x, y) 修改为 v + ReLU(V (x, y) - v)；

在所有学习操作之后，神经网络的参数定下来不变了，紧接着有 m 次神经网络推 理操作，每次推理操作给出 x1 , x2 , y1 , y2 ，查询对应子矩阵范围内最大的神经网络权重， 即 max V (x, y)。

x1 ≤ x ≤ x2

y1 ≤ y ≤ y2

小 C 发现机器在枚举这个问题优秀的算法时卡住了， 目前只枚举出了一个很暴力 的算法，为了让机器可以快点启动， 他决定自己写好这个问题的算法来降低其启动常数， 你能帮帮他吗？

【输入格式】

从标准输入读入数据。

输入的第一行包含两个整数 n, m；

接下来 n 行每行五个整数 x1 , x2 , y1 , y2 , v，依次表示每次学习操作的参数；

接下来 m 行每行四个整数 x1 , x2 , y1 , y2 ，依次表示每次推理操作的参数。

【输出格式】

输出到标准输出。

共 m 行，依次表示每次查询操作的答案。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

5 5

1 3 2 3 3

4 5 2 5 1

3 5 1 2 1

2 5 3 4 4

1 4 3 4 2

1 5 2 5

1 5 2 5

1 5 1 5

1 4 1 5

2 5 1 3

【样例 1 输出】

1

2

3

4

5

4

4

4

4

4

【样例 2 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

10 10

3 10 7 7 10

1 10 9 9 3

4 6 7 7 7

1 8 5 5 1

6 8 1 1 1

1 3 8 8 2

2 10 10 10 9

1 10 6 6 4

1 8 9 9 4

5 9 9 9 2

1 9 2 2

2 10 1 10

14

15

16

17

18

19

20

21

2 10 6 9

2 2 1 4

2 10 8 10

7 10 1 10

1 8 1 9

1 8 5 7

3 7 5 8

2 10 1 7

【样例 2 输出】

1

2

3

4

5

6

7

8

9

10

0

10

10

0

9

10

10

10

10

10

【子任务】

对于 10% 的数据，满足 1 ≤ n, m ≤ 100。

对于另外 10% 的数据，满足 1 ≤ n, m ≤ 103。

对于另外 20% 的数据，满足 1 ≤ n, m ≤ 104。

对于另外 20% 的数据，满足 1 ≤ n, m ≤ 5 × 104。

对于另外 10% 的数据，满足 1 ≤ n ≤ 103。

对于 100% 的数据， 满足 1 ≤ n, m ≤ 5 × 105 ，对每个修改或查询操作， 满足 1 ≤ x1 ≤ x2 ≤ n ，1 ≤ y1 ≤ y2 ≤ n 对每个修改操作， 满足 1 ≤ v ≤ n ，所有数值为整数。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 33 次认证

时间：2024 年 3 月 31 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 词频统计 | 相似度计算 | 化学方程式 配平 | 十滴水 | 文件夹合并 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 3.0 秒 | 2.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 10  | 10  | 10  | 7   | 9   |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 否   |

词频统计（tﬁdf）

【题目描述】

在学习了文本处理后， 小 P 对英语书中的 n 篇文章进行了初步整理。具体来说， 小 P 将所有的英文单词都转化为了整数编号。假设这 n 篇文章中共出现了 m 个不同的单 词，则把它们从 1 到 m 进行编号。这样，每篇文章就简化为了一个整数序列，其中每 个数都在 1 到 m 范围内。

现给出小 P 处理后的 n 篇文章，对于每个单词 i（1 ≤ i ≤ m），试统计：

1\. 单词 i 出现在了多少篇文章中？

2\. 单词 i 在全部文章中总共出现了几次？

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

输入的第一行包含两个正整数 n 和 m，分别表示文章篇数和单词编号上限。

输入的第 i + 1 行（1 ≤ i ≤ n）包含由空格分隔的若干整数， 其中第一个整数 li 表 示第 i 篇文章的长度（单词个数）；接下来 li 个整数表示对应的整数序列，序列中每个 整数均在 1 到 m 范围内，各对应原文中的一个单词。

【输出格式】

输出到标准输出。

输出共 m 行。

第 i 行（1 ≤ i ≤ m）输出由空格分隔的两个整数 xi 和 yi ，表示共有 xi 篇文章包 含单词 i，总计出现次数为 yi。

【样例输入】

**1**

**2**

**3**

**4**

**5**

**4 3**

**5 1 2 3 2 1**

**1 1**

**3 2 2 2**

**2 3 2**

【样例输出】

第 2 页 共 16 页

**1**

**2**

**3**

**2 3**

**3 6**

**2 2**

【样例解释】

单词 2 在：

• 文章 1 中出现两次；

• 文章 3 中出现三次；

• 文章 4 中出现一次。

因此 x2 = 3 、y2 = 6。

【子任务】

全部的测试数据满足 0 < n, m ≤ 100，且每篇文章至少包含一个单词、最多不超过 100 个单词（1 ≤ li ≤ 100）。

相似度计算（jaccard）

【题目背景】

两个集合的 Jaccard 相似度定义为：

即交集的大小除以并集的大小。当集合 A 和 B 完全相同时，Sim(A, B) = 1 取得最大 值；当二者交集为空时， Sim(A, B) = 0 取得最小值。

【题目描述】

除了进行简单的词频统计， 小 P 还希望使用 Jaccard 相似度来评估两篇文章的相似 性。具体来说， 每篇文章均由若干个英文单词组成， 且英文单词仅包含“大小写英文字 母”。对于给定的两篇文章， 小 P 首先需要提取出两者的单词集合 A 和 B，即去掉各自 重复的单词。然后计算出：

• |A ∩ B|，即有多少个不同的单词同时出现在两篇文章中；

• |A ∪ B|，即两篇文章一共包含了多少个不同的单词。

最后再将两者相除即可算出相似度。需要注意， 在整个计算过程中应当忽略英文字

. . . . .

母大小写的区别，比如 **the**、**The** 和 **THE** 三者都应被视作同一个单词。

试编写程序帮助小 P 完成前两步， 计算出 |A ∩ B| 和 |A ∪ B|； 小 P 将亲自完成最 后一步的除法运算。

【输入格式】

从标准输入读入数据。

输入共三行。

输入的第一行包含两个正整数 n 和 m，分别表示两篇文章的单词个数。

第二行包含空格分隔的 n 个单词，表示第一篇文章；

第三行包含空格分隔的 m 个单词，表示第二篇文章。

【输出格式】

输出到标准输出。

输出共两行。

第一行输出一个整数 |A ∩ B|，即有多少个不同的单词同时出现在两篇文章中；

第二行输出一个整数 |A ∪ B|，即两篇文章一共包含了多少个不同的单词。

【样例 1 输入】

**1**

**2**

**3**

**3 2**

**The tHe thE the THE**

【样例 1 输出】

**1**

**2**

**1**

**1**

【样例 1 解释】

A = B = A ∩ B = A ∪ B = **{the}**

【样例 2 输入】

**1**

**2**

**3**

**9 7**

**Par les soirs bleus dete jirai dans les sentiers PICOTE PAR LES BLES FOULER LHERBE MENUE**

【样例 2 输出】

**1**

**2**

**2**

**13**

【样例 2 解释】

A = **{bleus, dans, dete, jirai, les, par, sentiers, soirs}** |A| = 8 B = **{bles, fouler, les, lherbe, menue, par, picote}** |B| = 7

A ∩ B = **{les, par}** |A ∩ B| = 2

【样例 3 输入】

**1**

**2**

**15 15**

**Thou that art now the worlds fresh ornament And only herald to the**

**gaudy spring**

**3**

**Shall I compare thee to a summers day Thou art more lovely and more temperate**

【样例 3 输出】

**1**

**2**

**4**

**24**

【子任务】

80% 的测试数据满足： n, m ≤ 100 且所有字母均为小写；

全部的测试数据满足： n, m ≤ 104 且每个单词最多包含 10 个字母。

化学方程式配平（balancing）

【题目背景】

近日来，西西艾弗岛化学研究中心的研究员们向岛上的初中学生开展了化学科普活 动。在活动中发现， 初学化学的同学们十分苦恼于正确配平化学方程式。而还有一些同 学，则提出了一些稀奇古怪的方程式， 让研究员们帮忙配平。在配平之前， 研究员们需 要先判断这个方程式是否能够配平。

一个化学方程式， 也叫化学反应方程式， 是用化学式表示化学反应的式子。其等号 左右两侧分别列举了化学反应的全部反应物和生成物。每种物质都用其化学式表示。 一 个物质的化学式，列举了构成该物质的各元素的原子数目。例如，水的化学式是 H2 O， 表示水分子中含有两个氢原子和一个氧原子。化学方程式中每种物质的化学式前面都有 一个系数，表示参与反应或生成的物质的相对数目比例。例如， 方程式 2H2 + O2 = 2H2 O 表示二分子氢气和一分子氧气反应生成二分子水。我们称一个化学方程式是配平的， 是 指该方程式中的反应物和生成物中， 各元素原子总数目相等。例如上述方程式中， 左侧 氢原子、氧原子的总数目分别为 4 和 2，右侧氢原子、氧原子的总数目分别为 4 和 2， 因此该方程式是配平的。

【题目描述】

为了配平一个化学方程式， 我们可以令方程式中各物质的系数为未知数， 然后针对 涉及的每一种元素，列出关于系数的方程， 形成一个齐次线性方程组。然后求解这个方 程组，得到各物质的系数。这样， 我们就把化学方程式配平的问题， 转化为了求解齐次 线性方程组的问题。如果方程组没有非零解，那么这个方程式是不可以配平的。反之， 如果方程组有非零解， 我们就可能得到一个配平的方程式。当然， 最终得到的方程式仍 然需要结合化学知识进行检验，对此我们不再进一步考虑，仅考虑非零解的存在。

例如要配平化学方程式： Al2 (SO4 )3 + NH3 · H2 O → Al(OH)3 + (NH4 )2 SO4

首先假定所有物质在方程的同一侧，即不考虑哪个是反应物， 哪个是生成物， 分别 设这些物质的系数为 x1 , x2 , x3 , x4 ，则可以针对出现的各个元素，列出如下的方程组：

2x1 + 0x2 + x3 + 0x4 = 0 Al 3x1 + 0x2 + 0x3 + x4 = 0 S 12x1 + x2 + 3x3 + 4x4 = 0 O 0x1 + x2 + 0x3 + 2x4 = 0 N 0x1 + 5x2 + 3x3 + 8x4 = 0 H

用矩阵的形式表示为：

对系数矩阵实施高斯消元，得到系数矩阵的一个行阶梯形式：

\\0 0 0 0,

由此可见，系数矩阵的秩为 3。根据线性代数的知识，我们知道，齐次线性方程组 AX = 0 的解空间的维数等于其未知数个数减去系数矩阵的秩 rankA。而要让方程式配 平，即要求方程组存在非零解，那么就需要让解空间的维数大于 0，即系数矩阵的秩小 于未知数个数。因此， 我们可以通过判断系数矩阵的秩是否小于未知数个数， 来判断方 程式是否可以配平。如果可以配平， 则可以通过解的符号来判断反应物和生成物的位置。

本题中，我们将给出一些化学方程式，请你按照上述方法判断它们是否可以配平。 为了便于程序处理，我们用到的化学式，会被化简为只包含小写字母和数字的字符串， 不包含括号。其中连续的字母表示一种元素，随后的数字表示原子个数。原子个数为 1 时不省略数字； 一个化学式中包含的元素不重复。例如， 上述方程式中的化学式可以化 简为 **al2s3o12**、**n1h5o1**、**al1o3h3**、**n2h8s1o4**。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 n，表示需要判断的化学方程式的个数。

接下来的 n 行，每行描述了一个需要被配平的化学方程式。包含空格分隔的一个正 整数和全部涉及物质的化学式。其中， 正整数 m 表示方程式中的物质； 随后的 m 个字 符串，依次给出方程式中的反应物的化学式和生成物的化学式。

【输出格式】

输出到标准输出。

输出包含 n 行，每行包含字母 **Y** 或 **N**，表示按题设方法， 所给待配平化学方程式能 否配平。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**6**

**2 o2 o3**

**3 c1o1 c1o2 o2**

**2 n2o4 n1o2**

**4 cu1 h1n1o3 cu1n2o6 h2o1**

**4 al2s3o12 n1h5o1 al1o3h3 n2h8s1o4**

**4 c1o1 c1o2 o2 h2o1**

【样例 1 输出】

**1**

**2**

**3**

**4**

**5**

**6**

**Y**

**Y**

**Y**

**N**

**Y**

**Y**

【样例 1 解释】

输入中给出了 5 个待配平的化学方程式，其中各方程式的配平情况为：

• 3O2 = 2O3

• 2CO + O2 = 2CO2

• N2 O4 = 2NO2

• 因为缺少生成物 NO 或 NO2 ，所以不可以配平

• Al2 (SO4 )3 + 6NH3 · H2 O = 2Al(OH)3 + 3(NH4 )2 SO4

• 2CO+ O2 = 2CO2 ，本方程式对应的线性方程组求解后，得到 H2 O 的系数为 0， 说明其未参与反应， 属多余的物质。在这种情况下， 由于对应的线性方程组存在 非零解，所以我们仍然认为这个方程式是可以配平的。

【子任务】

对于 20% 的数据，每个方程中物质的个数不超过 2，每个方程中涉及的全部元素不 超过 2 种；

对于 60% 的数据，每个方程中物质的个数不超过 3，每个方程中涉及的全部元素不 超过 3 种；

对于 100% 的数据，每个方程中物质的个数不超过 40，每个方程中涉及的全部元素 不超过 40 种；且有 1 ≤ n ≤ 10，且化学式中各元素的原子个数不超过 50。

【提示】

• 对矩阵进行高斯消元的一种方法是：

1\. 考察矩阵的第一列上的元素：

**\-** 若全都为零，则对除去该列的子矩阵重复上述判断；

**\-** 若不全为零，则：

1\. 考察第一行第一列的元素：

∗ 如果其为 0，则将该行与后面的某一个第一列非 0 的行交换，使 第一行第一列的元素非 0；

2\. 令后续所有行减去第一行的适当倍数，使得后续所有行的第一列 元素为 0；

2\. 对除去第一行第一列的子矩阵重复上述操作，直至不再余下子矩阵。

• 对系数矩阵高斯消元后，不全为 0 的行的数目即为系数矩阵的秩。

• 评测环境仅提供各语言的标准库，特别地，不提供任何线性代数库。

十滴水（tendrop）

【题目描述】

十滴水是一个非常经典的小游戏。

小 C 正在玩一个一维版本的十滴水游戏。我们通过一个例子描述游戏的基本规则。

游戏在一个 1 × c 的网格上进行，格子用整数 x(1 ≤ x ≤ c) 编号，编号从左往右 依次递增。网格内 m 个格子里有 1 ~ 4 滴水，其余格子里没有水。在我们的例子中， c = m = 5，按照编号顺序，每个格子中分别有 2, 4, 4, 4, 2 滴水。

玩家可以进行若干次操作， 每次操作中， 玩家选择一个有水的格子， 将格子的水滴 数加一。任何时刻若某个格子的水滴数大于等于 5，这个格子里的水滴就会向两侧爆开。 此时，这个格子的水被清空， 同时对于左方、右方两个方向同时进行以下操作： 找到当

. .

前格子在对应方向上最近的有水的格子， 如果存在这样的格子， 将这个格子的水滴数加 一。若在某个时刻，有多个格子的水滴数大于等于 5 ，则最靠左的先爆开。

在我们的例子中，若玩家对第三格进行操作，则其水滴数变为 5，故第三格水滴爆 开，水被清空，其左侧最近的有水格子（第二格） 和右侧最近的有水格子（第四格） 的 水量增加 1，此时每个格子中分别有 2, 5, 0, 5, 2 滴水。

此时第二格和第四格的水滴数均大于等于 5，按照规则，第二格的水先爆开，爆 开后每个格子中分别有 3, 0, 0, 6, 2 滴水；最后第四格的水滴爆开，每个格子中分别有 4, 0, 0, 0, 3 滴水。

小 C 开始了一局游戏并进行了 n 次操作。小 C 在每次操作后， 会等到所有水滴数 大于等于 5 的格子里的水滴都爆开再进行下一次操作。

小 C 想知道他的水平有多高，于是他想知道每一次操作后还有多少格子里有水。 保证这 n 次操作都是合法的，即每次操作时操作的格子里都有水。

【输入格式】

从标准输入读入数据。

输入的第一行三个整数 c, m, n 分别表示网格宽度、有水的格子个数以及操作次数。 接下来 m 行每行两个整数 x, w，表示第 x 格有 w 滴水。

接下来 n 行每行一个整数 p，表示小 C 对第 p 格做了一次操作。

【输出格式】

输出到标准输出。

输出 n 行，每行一个整数表示这次操作之后网格上有水的格子数量。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**5 5 2**

**1 2**

**2 4**

**3 4**

**4 4**

**5 2**

**3**

**1**

【样例 1 输出】

**1**

**2**

**2**

**1**

【子任务】

对于所有测试数据，

• 1 ≤ c ≤ 109 ，1 ≤ m ≤ min(c, 3 × 105 ) ，1 ≤ n ≤ 4m；

• 1 ≤ x, p ≤ c ，1 ≤ w ≤ 4；

• 输入的所有 x 两两不同；

• 对于每个输入的 p，保证在对应操作时 p 内有水。

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 子任务编号 | c ≤ | m ≤ | 特殊性质 | 分值  |
| 1   | 30  | 30  | 有   | 15  |
| 2   | 3, 000 | 3, 000 |
| 3   | 无   | 10  |
| 4   | 109 | 15  |
| 5   | 3 × 105 | 3 × 105 |
| 6   | 109 | 有   |
| 7   | 无   |

特殊性质：在游戏的任意时刻（包括水滴爆开的连锁反应过程中）， 只有至多一个 格子的水滴数大于等于 5。

文件夹合并（merge）

【题目描述】

新入职西西艾弗岛有限公司的小 C 接替了刚刚升职的小 S 的项目。然而小 C 打开 项目工程时，一层层嵌套的文件夹让小 C 感到眼花缭乱。为了精简项目结构，小 C 决 定对项目的文件夹进行一些必要的合并。

项目中共有 n 个文件夹。为了方便， 我们用 1 至 n 的整数给这 n 个文件夹编号，其 中编号为 1 的文件夹为项目的根文件夹， 其他每个文件夹都有一个父文件夹，这些文件 夹构成了树形结构。除了子文件夹以外，第 i 个文件夹内还直接存储了 di 字节的数据。

小 C 进行了若干次文件夹合并操作。每次操作中小 C 会选择一个文件夹 xj ，将这 个文件夹和它的所有子文件夹合并。具体地，小 C 会进行以下操作：遍历 xj 的子文件 夹 y，将文件夹 y 包含的所有文件夹和文件移动到文件夹 xj ，然后删除文件夹 y。所有 文件和文件夹的名称是两两不同的，合并过程中不需要考虑文件或文件夹重名的情况。 在每一次合并操作后，小 C 需要知道文件夹 xj 内共有几个文件夹以及多少字节的数据。

例如，考虑以下项目：根文件夹内有文件夹 2 和文件夹 3 以及 100 字节数据，其中 文件夹 2 为空文件夹，文件夹 3 内有 200 字节数据和文件夹 4，文件夹 4 包含 300 字 节数据。对根文件夹进行一次合并后，文件夹 2 和文件夹 3 被合并至根文件夹， 此时根 文件夹下有文件夹 4 以及 300 字节数据，而文件夹 4 下也包含 300 字节数据。

在合并文件夹的过程中，小 C 常常需要访问某个文件夹 zj 下的文件。此时，小 C 会从根文件夹开始，每次进入当前文件夹的一个子文件夹。小 C 需要知道按照以上过 程，获取到文件夹 zj 下的文件至少需要经过多少个文件夹。

例如，在以上项目中， 未对根文件夹进行合并前， 访问根文件夹下的文件只需要经 过根文件夹一个文件夹，而访问文件夹 4 则需要经过根文件夹以及文件夹 3 和 4。而对 根文件夹进行合并之后，访问文件夹 4 只需要经过根文件夹和文件夹 4 了。

在整个项目中，小 C 一共进行了 m 次文件夹合并以及文件访问操作。你需要帮助 小 C 正确维护文件夹之间的关系，并在每次操作后正确回答小 C 需要的数据。

【输入格式】

从标准输入读入数据。

输入的第一行两个整数 n, m，分别表示文件夹数量以及操作次数。

第二行 (n — 1) 个整数 f2 , · · · , fn，其中 fi 表示文件夹 i 的父文件夹编号。

第三行 n 个整数 d1 , d2 , · · · , dn，其中 di 表示文件夹 i 中数据的存储量。

接下来 m 行第 j 行两个整数，第一个整数 opj 表示操作类型。若 opj = 1 则表示一 次文件夹合并操作，接下来一个整数 xj 表示合并的文件夹编号；若 opj = 2 则表示一 次文件访问操作，接下来一个整数 zj 表示访问的文件夹编号。

【输出格式】

输出到标准输出。

输出 m 行，第 j 行表示第 j 个操作中小 C 需要的数据：若 opj = 1 则输出两个整 数，依次表示文件夹 xj 的子文件夹数量以及数据的存储量；若 opj = 2 则输出一个整 数表示小 C 获取文件夹 zj 下的数据最少需要经过的文件夹个数。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**4 6**

**1 1 3**

**100 0 200 300**

**2 1**

**2 4**

**1 1**

**2 4**

**1 1**

**1 1**

【样例 1 输出】

**1**

**2**

**3**

**4**

**5**

**6**

**1**

**3**

**1 300**

**2**

**0 600**

**0 600**

【子任务】

对于所有测试数据，

• 1 ≤ n ≤ 5 × 105 , 1 ≤ m ≤ 3 × n，

• 1 ≤ fi ≤ n，输入的文件夹结构构成树形结构， • 0 ≤ di ≤ 105，

• 1 ≤ xj , zj ≤ n，每次合并操作中给出的文件夹 xj 没有被删除，每次文件访问操 作中给出的文件夹 zj 没有被删除。

|     |     |     |     |
| --- | --- | --- | --- |
| 子任务编号 | n ≤ | 特殊性质 | 分值  |
| 1   | 500 | 无   | 10  |
| 2   | 5, 000 | 15  |
| 3   | 105 |
| 4   | 5 × 105 | A   | 5   |
| 5   | B   |
| 6   | C   | 10  |
| 7   | D   | 15  |
| 8   | E   | 10  |
| 9   | 无   | 15  |

特殊性质 A：fi = (i − 1)。

特殊性质 B：fi = 1。

特殊性质 C：在文件夹合并操作中， xj = 1。

特殊性质 D：opj = 1 ，即没有文件访问操作。

特殊性质 E：opj = 2 ，即没有文件夹合并操作。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 32 次认证

时间：2023 年 12 月 10 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 仓库规划 | 因子化简 | 树上搜索 | 宝藏  | 彩色路径 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 2.0 秒 | 1.0 秒 | 1.5 秒 | 2.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 10  | 10  | 10  | 20  | 50  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

仓库规划（plan）

【题目描述】

西西艾弗岛上共有 n 个仓库，依次编号为 1 · · · n。每个仓库均有一个 m 维向量的 位置编码，用来表示仓库间的物流运转关系。

具体来说，每个仓库 i 均可能有一个上级仓库 j，满足：仓库 j 位置编码的每一维 均大于仓库 i 位置编码的对应元素。比如编码为 (1, 1, 1) 的仓库可以成为 (0, 0, 0) 的上 级，但不能成为 (0, 1, 0) 的上级。如果有多个仓库均满足该要求，则选取其中编号最小 的仓库作为仓库 i 的上级仓库；如果没有仓库满足条件， 则说明仓库 i 是一个物流中心， 没有上级仓库。

现给定 n 个仓库的位置编码，试计算每个仓库的上级仓库编号。

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

输入的第一行包含两个正整数 n 和 m，分别表示仓库个数和位置编码的维数。

接下来 n 行依次输入 n 个仓库的位置编码。其中第 i 行（1 ≤ i ≤ n）包含 m 个整 数，表示仓库 i 的位置编码。

【输出格式】

输出到标准输出。

输出共 n 行。

第 i 行（1 ≤ i ≤ n）输出一个整数，表示仓库 i 的上级仓库编号； 如果仓库 i 没有 上级，则第 i 行输出 0。

【样例输入】

1

2

3

4

5

4 2

0 0

\-1 -1

1 2

0 -1

【样例输出】

1

2

3

4

3

1

0

3

【样例解释】

对于仓库 2 : (-1, -1) 来说，仓库 1 : (0, 0) 和仓库 3 : (1, 2) 均满足上级仓库的编码 要求，因此选择编号较小的仓库 1 作为其上级。

【子任务】

50% 的测试数据满足 m = 2；

全部的测试数据满足 0 < m ≤ 10 、0 < n ≤ 1000，且位置编码中的所有元素均为绝 对值不大于 106 的整数。

因子化简（prime）

【题目背景】

质数（又称“素数”）是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他 因数的自然数。

【题目描述】

小 P 同学在学习了素数的概念后得知，任意的正整数 n 都可以唯一地表示为若干 素因子相乘的形式。如果正整数 n 有 m 个不同的素数因子 p1 , p2 , · · · , pm ，则可以表示

为：n = p1 × p2 × · · · × p 。

小 P 认为，每个素因子对应的指数 ti 反映了该素因子对于 n 的重要程度。现设定 一个阈值 k，如果某个素因子 pi 对应的指数 ti 小于 k，则认为该素因子不重要， 可以将

pi 项从 n 中除去；反之则将 pi 项保留。最终剩余项的乘积就是 n 简化后的值，如果

没有剩余项则认为简化后的值等于 1。

试编写程序处理 q 个查询：

• 每个查询包含两个正整数 n 和 k，要求计算按上述方法将 n 简化后的值。

【输入格式】

从标准输入读入数据。

输入共 q + 1 行。

输入第一行包含一个正整数 q，表示查询的个数。

接下来 q 行每行包含两个正整数 n 和 k，表示一个查询。

【输出格式】

输出到标准输出。

输出共 q 行。

每行输出一个正整数，表示对应查询的结果。

【样例输入】

1

2

3

4

3

2155895064 3

2 2

10000000000 10

【样例输出】

1

2

3

2238728

1

10000000000

【样例解释】

查询一：

• n = 23 × 32 × 234 × 107

• 其中素因子 3 指数为 2 ，107 指数为 1。将这两项从 n 中除去后，剩余项的乘积 为 23 × 234 = 2238728。

查询二：

• 所有项均被除去，输出 1。

查询三：

• 所有项均保留，将 n 原样输出。

【子任务】

40% 的测试数据满足： n ≤ 1000；

80% 的测试数据满足： n ≤ 105；

全部的测试数据满足： 1 < n ≤ 1010 且 1 < k, q ≤ 10。

树上搜索（treesearch）

【题目背景】

西西艾弗岛大数据中心为了收集用于模型训练的数据， 推出了一项自愿数据贡献的 系统。岛上的居民可以登录该系统， 回答系统提出的问题，从而为大数据中心提供数据。 为了保证数据的质量， 系统会评估回答的正确性， 如果回答正确， 系统会给予一定的奖 励。

近期，大数据中心需要收集一批关于名词分类的数据。系统中会预先设置若干个名 词类别，这些名词类别存在一定的层次关系。例如，“动物”是“生物”的次级类别，“鱼 类”是“动物”的次级类别，“鸟类”是“动物”的次级类别，“鱼类”和“鸟类”是“动 物”下的邻居类别。这些名词类别可以被按树形组织起来， 即除了根类别外， 每个类别 都有且仅有一个上级类别。并且所有的名词都可以被归类到某个类别中， 即每个名词都 有且仅有一个类别与其对应。一个类别的后代类别的定义是：若该类别没有次级类别， 则该类别没有后代类别； 否则该类别的后代类别为该类别的所有次级类别， 以及其所有 次级类别的后代类别。

下图示意性地说明了标有星号的类别的次级类别和后代类别。

**\***

次级类别

后代类别

图 1: 次级类别与后代类别

系统向用户提出问题的形式是： 某名词是否属于某类别， 而用户可以选择“是”或 “否”来回答问题。该问题的含义是：某名词是否可以被归类到某类别或其后代类别中。

例如，要确定名词“鳕鱼”的类别，系统会向用户提出“鳕鱼是否属于动物”，当用 户选择“是”时，系统会进一步询问“鳕鱼是否属于鱼类”，当用户选择“是”时，即可 确定“鳕鱼”可以被归类到“鱼类”这一类别。

此外，如果没有更具体的分类， 某一名词也可以被归类到非叶子结点的类别中。例 如，要确定“猫”的类别，系统可以向用户提出“猫是否属于动物”，当用户选择“是”

时，系统会进一步分别询问“猫”是否属于“鱼类”和“鸟类”，当两个问题收到了否定 的答案后，系统会确定“猫”的类别是“动物”。

大数据中心根据此前的经验， 已经知道了一个名词属于各个类别的可能性大小。为 了用尽量少的问题确定某一名词的类别，大数据中心希望小 C 来设计一个方法， 以减 少系统向用户提出的问题的数量。

【题目描述】

小 C 观察了事先收集到的数据， 并加以统计，得到了一个名词属于各个类别的可能 性大小的信息。具体而言， 每个类别都可以赋予一个被称为权重的值， 值越大，说明一 个名词属于该类别的可能性越大。由于每次向用户的询问可以获得两种回答，小 C 联 想到了二分策略。他设计的策略如下：

1\. 对于每一个类别，统计它和其全部后代类别的权重之和， 同时统计其余全部类别 的权重之和，并求二者差值的绝对值，计为 wδ ;

2\. 选择 wδ 最小的类别，如果有多个，则选取编号最小的那一个， 向用户询问名词 是否属于该类别；

3\. 如果用户回答“是”，则仅保留该类别及其后代类别，否则仅保留其余类别；

4\. 重复步骤 1，直到只剩下一个类别，此时即可确定名词的类别。

小 C 请你帮忙编写一个程序，来测试这个策略的有效性。你的程序首先读取到所 有的类别及其上级次级关系， 以及每个类别的权重。你的程序需要测试对于被归类到给 定类别的名词，按照上述策略提问，向用户提出的所有问题。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 n 和 m，分别表示全部类别的数量和需 要测试的类别的数量。所有的类别从 1 到 n 编号，其中编号为 1 的是根类别。

输入的第二行包含 n 个空格分隔的正整数 w1 , w2, . . . , wn，其中第 i 个数 wi 表示编 号为 i 的类别的权重。

输入的第三行包含 (n - 1) 个空格分隔的正整数 p2 , p3, . . . , pn ，其中第 i 个数 pi+1 表示编号为 (i + 1) 的类别的上级类别的编号，其中 pi ∈ \[1, n\]

接下来输入 m 行，每行一个正整数，表示需要测试的类别编号。

【输出格式】

输出 m 行，每行表示对一个被测试的类别的测试结果。表示按小 C 的询问策略， 对属于给定的被测类别的名词，需要依次向用户提出的问题。

每行包含若干空格分隔的正整数，每个正整数表示一个问题中包含的类别的编号， 按照提问的顺序输出。

【样例 1 输入】

1

2

3

4

5

5 2

10 50 10 10 20

1 1 3 3

5

3

【样例 1 输出】

1

2

2 5

2 5 3 4

【样例 1 解释】

上述输入数据所表示的类别关系如下图所示， 同时各个类别的权重也标注在了图 上。

**1, 10**

**2, 50**

**4, 10**

**3, 10**

**5, 20**

图 2: 样例输入数据所表示的类别关系

对于归类于类别 5 的某个名词，按照上述询问策略， 应当对于树上的每个节点， 都 计算 wδ 的值，对于类别 1 至 5，得到的 wδ 分别为：100 、0 、20 、80 、60。因此首先就 类别 2 提问。由于类别 5 不属于类别 2 的后代类别， 因此用户回答“否”，此时去除类 别 2 和其全部后代类别， 仅保留类别 1 、3 、4 、5。对于剩下的类别， 计算 wδ 的值，得 到的 wδ 分别为：50 、30 、30 、10。因此再就类别 5 提问。由于类别 5 就是被提问的名 词所属类别，因此用户回答“是”，此时仅保留类别 5 和其全部后代类别。我们发现， 这 个时候，只剩下类别 5 ，因此算法结束。上述过程如下图所示：

对于归类于类别 3 的某个名词，按照上述询问策略，依次对类别 2 、5 提问，过程 与前述一致。但是由于类别 3 不属于类别 2 的后代类别，用户回答“否”，此时应当去

**1, 10**

**1, 10**

**No**

**3, 10**

**2, 50**

**4, 10**

**5, 20**

**4, 10**

**3, 10**

**5, 20**

**Yes**

**5, 20**

图 3: 算法执行过程 1

掉类别 5 和其后代类别，仅保留类别 1 、3 、4。分别计算 wδ 得：30 、10 、10。此时应 当选择编号较小的类别 3 提问。由于类别 3 就是被提问的名词所属类别， 因此用户回答 “是”，此时仅保留类别 3 和其全部后代类别。我们发现， 这个时候，并非只剩下一个类 别， 因此算法还应继续进行。剩下的类别有 3 、4，分别计算 wδ 得：20 、0。因此再就类 别 4 提问。由于类别 3 不属于类别 4 的后代类别，用户回答“否”，此时应当去掉类别 4 和其后代类别，仅保留类别 3。我们发现，这个时候，只剩下类别 3 ，因此算法结束。 上述过程如下图所示：

**1, 10**

**1, 10**

**No**

**3, 10**

**2, 50**

**4, 10**

**5, 20**

**5, 20**

**3, 10**

**4, 10**

**1, 10**

**No**

**3, 10**

**4, 10**

**No**

**Yes**

**3, 10**

**3, 10**

**4, 10**

图 4: 算法执行过程 2

【子任务】

对 20% 的数据，各个类别的权重相等，且每个类别的上级类别都是根类别；

对另外 20% 的数据，每个类别的权重相等，且每个类别至多有一个下级类别； 对 60% 的数据，有 n ≤ 100，且 m ≤ 10；

对 100% 的数据，有 n ≤ 2000 ，m ≤ 100，且 wi ≤ 107。

宝藏（treasure）

【题目描述】

西西艾弗岛上埋藏着一份宝藏，小 C 根据藏宝图找到了宝藏的位置。藏有宝藏的 箱子被上了锁，旁边写着一些提示：

• 给定 n 条指令，编号为 1 ~n，其中每条指令都是对一个双端队列的操作，队列 中的元素均为 2 × 2 的矩阵；

• 在某些时刻，某一条指令可能会改变；

• 在某些时刻，密码可以由以下方式计算： 对于给定的指令区间 \[l, r\]，对初始为空 的队列依次执行第 l ~r 条指令，将得到的队列里的所有矩阵从头到尾相乘，并 将乘积矩阵中的所有元素对 998244353 取模，得到的矩阵即为密码； 特别地，若 队列为空， 则密码为单位矩阵；如果能分别计算出这些时刻的密码， 将能够打开

. . . .

箱子的锁，从而获得宝藏。

经过小 C 的观察，每条指令的形式均为以下三种之一：

1\. 给定 2 × 2 的矩阵 A，将 A 插入队列的头部；

2\. 给定 2 × 2 的矩阵 B，将 B 插入队列的尾部；

3\. 若队列非空，删除队列中最晚被插入的矩阵。

. .

小 C 将所有的时刻发生的事件均记录了下来。具体地，共有 m 个时刻，每个时刻 可能会发生两种事件：

1\. 第 i 条指令改变，改变后的指令仍为以上三种形式之一；

2\. 给定指令区间 \[l, r\]，求依次执行第 l ~r 条指令得到的密码。

由于小 C 并不会这个问题，他向你发起了求助。你需要帮助小 C 求出所有类型为 2 的事件所对应的密码。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个正整数 n, m。

接下来 n 行，按顺序给出初始时刻的每条指令：

• 输入的第一个正整数 v 描述这条指令的形式，保证 v 为 1, 2, 3 中的一种。

• 若 v = 1，接下来给出四个非负整数 A1, 1 , A1,2 , A2, 1 , A2,2 ，表示操作为将 2 × 2 的 矩阵 A 插入队列的头部；

• 若 v = 2，接下来给出四个非负整数 B1, 1 , B1,2 , B2, 1 , B2,2 ，表示操作为将 2 × 2 的 矩阵 B 插入队列的尾部；

• 若 v = 3，表示操作为若队列非空，删除队列中最晚被插入的矩阵；

接下来 m 行，按顺序给出每个时刻发生的事件：

• 输入的第一个正整数 v 描述这个事件的类型，保证 v 为 1, 2 中的一种。

• 若 v = 1，接下来给出一个正整数 i 与一条指令，表示将第 i 条指令更新为当前 输入的指令，指令的输入格式与初始时刻指令的输入格式相同。

• 若 v = 2，接下来给出两个正整数 l, r，你需要求出依次执行第 l ~r 条指令得到 的密码。

【输出格式】

输出到标准输出。

对于所有类型为 2 的事件，输出一行四个非负整数 C1, 1 , C1,2 , C2, 1 , C2,2，表示该时刻 的密码 C。

【样例 1 输入】

1

2

3

4

5

6

7

8

1

2

3 4

1 2 3 9 3

2 6 9 4 2

2 2 8 2 1

2 2 3

1 2 1 3 1 0 1

1 3 3

2 1 3

【样例 1 输出】

30 57 12 34

2 3 9 3

【样例 1 解释】

第一次事件发生时，

依次执行第 2 ~ 3 条指令，得到的队列为  则密码为

第四次事件发生时，

• 第 1 条指令为在序列头部插入矩阵 ；

• 第 2 条指令为在序列头部插入矩阵 ；

• 第 3 条指令为若队列非空，删除队列中最晚被插入的矩阵。

依次执行第 1 ~ 3 条指令，得到的队列为  则密码为 。

【样例 2】

见题目目录下的 **_2.in_** 与 **_2.ans_**。

该样例满足测试数据 1 ~ 3 的限制。

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

该样例满足测试数据 4 ~ 7 的限制。

【样例 4】

见题目目录下的 **_4.in_** 与 **_4.ans_**。

该样例满足测试数据 8, 9 的限制。

【样例 5】

见题目目录下的 **_5.in_** 与 **_5.ans_**。

该样例满足测试数据 10, 11 的限制。

【样例 6】

见题目目录下的 **_6.in_** 与 **_6.ans_**。

该样例满足测试数据 12 ~ 15 的限制。

【样例 7】

见题目目录下的 **_7.in_** 与 **_7.ans_**。

该样例满足测试数据 16, 17 的限制。

【子任务】

对于所有测试数据，满足 1 ≤ n, m ≤ 105，0 ≤ Ai,j , Bi,j < 998244353，1 ≤ l ≤ r ≤ n。

|     |     |     |
| --- | --- | --- |
| 测试点编号 | n, m ≤ | 特殊性质 |
| 1 ~ 3 | 102 | 无   |
| 4 ~ 7 | 103 |
| 8, 9 | 5 × 104 | 所有指令的形式均为 1 |
| 10, 11 | 所有指令的形式均为 1 或 2 |
| 12 ~ 15 | 所有事件的类型均为 2 |
| 16, 17 | 无   |
| 18 ~ 20 | 105 |

彩色路径（path）

【题目描述】

西西艾弗岛的路线图可以看作是一个具有 N 个节点和 M 条有向边的图。第 i 个节 点（0 ≤ i < N）有一个颜色标签 C\[i\] ∈ {0, 1, · · · , K - 1}，第 j 条边（0 ≤ j < M）从 节点 U\[j\] 指向节点 V \[j\]，长度为 D\[j\]。

对于游客顿顿来说，理想的观光路线应满足以下条件：

• 是一条从节点 0 到节点 N - 1 的简单路径；

• 是一条彩色路径，即路径上每个节点的颜色标签均不相同；

. . . .

• 并且包含的节点数小于或等于 L。

具体而言，理想的观光路线是一个节点序列， 例如 (t0 , t1 , · · · , tq- 1 )，满足以下所有 要求：

• 对于每个 i（0 ≤ i < q - 1），存在一条从节点 ti 到节点 ti+1 的有向边。

• t0 = 0 且 tq- 1 = N - 1

• 对于每对 i, j（0 ≤ i < j < q），都有 C\[ti \]  C\[tj \]。

• q ≤ L

一条路径的长度定义为边的总长度。你的任务是找到满足游客顿顿所有要求的最长

. .

观光路线。

【输入格式】

从标准输入读入数据。

输入共五行。

输入的第一行包含四个正整数 N 、M 、L 和 K，分别表示图的节点数、边数、理想 观光路线的节点数上限和颜色标签范围。

输入的第二行包含 N 个整数 C\[0\], C\[1\], · · · , C\[N - 1\]，表示图中每个节点的颜色标 签。

接下来输入边的信息。

输入的第三行包含 M 个整数 U\[0\], U\[1\], · · · , U\[M - 1\] ，表示每条有向边的起点；

输入的第四行包含 M 个整数 V \[0\], V \[1\], · · · , V \[M - 1\] ，表示每条有向边的终点；

输入的第五行包含 M 个整数 D\[0\], D\[1\], · · · , D\[M - 1\] ，表示每条有向边的长度。

输入数据保证不存在起点终点相同的边，如 (u, u)；每条有向边 (u, v) 仅会出现一 次，但不排除 (u, v) 和 (v, u) 可能同时存在。

【输出格式】

输出到标准输出。

输出一个数，表示理想观光路线的最大长度。

【样例输入】

1

2

3

4

5

6 9 4 10

0 2 2 3 3 9

0 0 0 1 1 1 2 3 4

1 2 4 3 4 5 4 5 5

1 2 4 3 2 8 5 3 1

【样例输出】

1

9

以下是示例图，其中黑色和红色数字分别表示节点编号和边的长度。

【样例解释】

0

1 3

3

3

1

2

8

2

1

4

5

2 4

5

图 5: 样例解释

如下表所示，在不超过四个节点的限制下，共有五条从节点 0 到节点 5 的彩色路 径。其中最长的一条是 (0, 1, 5)，长度为 9。

|     |     |     |
| --- | --- | --- |
| 彩色路径 | 节点数 | 长度  |
| (0, 1, 3, 5) | 4   | 7   |
| (0, 1, 4, 5) | 4   |
| (0, 2, 4, 5) | 8   |
| (0, 1, 5) | 3   | 9   |
| (0, 4, 5) | 5   |

【子任务】

20% 的测试数据满足： 对于每个 i（0 ≤ i < N - 1），有 C\[i\] ≤ C\[i + 1\]，以及对于 每个 j（0 ≤ j < M），有 U\[j\] < V \[j\]。

另有 30% 测试数据满足： K ≤ 15。

全部的测试数据满足：

• 2 ≤ N ≤ 100

• 1 ≤ M ≤ 5000

• 2 ≤ L ≤ 9 ≤ K ≤ 30

• C\[0\] = 0 且 C\[N - 1\] = K - 1

• 对于每个 i（1 ≤ i ≤ N - 2）：

1 ≤ C\[i\] ≤ K - 2

• 对于每个 j（0 ≤ j < M）：

0 ≤ U\[j\], V \[j\] < N C\[U\[j\]\]  C\[V \[j\]\]

1 ≤ D\[j\] ≤ 106

• 至少存在一条从节点 0 到节点 N - 1 的彩色路径，节点数不超过 L。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 31 次认证

时间：2023 年 9 月 17 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 坐 标 变 换 （其一） | 坐 标 变 换 （其二） | 梯度求解 | 阴阳龙 | 阻击  |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 2.0 秒 | 1.0 秒 | 2.0 秒 | 2.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 1024 MiB | 512 MiB |
| 子任务数目 | 10  | 20  | 10  | 4   | 25  |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 是   |

坐标变换（其一）（sum）

【题目描述】

对于平面直角坐标系上的坐标 (x, y)，小 P 定义了一个包含 n 个操作的序列 T = (t1 , t2 , · · · , tn )。其中每个操作 ti（1 ≤ i ≤ n）包含两个参数 dxi 和 dyi，表示将坐标 (x, y) 平移至 (x + dxi , y + dyi ) 处。

现给定 m 个初始坐标，试计算对每个坐标 (xj , yj )（1 ≤ j ≤ m）依次进行 T 中 n 个操作后的最终坐标。

【输入格式】

从标准输入读入数据。

输入共 n + m + 1 行。

输入的第一行包含空格分隔的两个正整数 n 和 m，分别表示操作和初始坐标个数。

接下来 n 行依次输入 n 个操作，其中第 i（1 ≤ i ≤ n）行包含空格分隔的两个整数 dxi 、dyi。

接下来 m 行依次输入 m 个坐标，其中第 j（1 ≤ j ≤ m）行包含空格分隔的两个整 数 xj 、yj 。

【输出格式】

输出到标准输出。

输出共 m 行，其中第 j（1 ≤ j ≤ m）行包含空格分隔的两个整数，表示初始坐标 (xj , yj ) 经过 n 个操作后的位置。

【样例输入】

1

2

3

4

5

6

3 2

10 10

0 0

10 -20

1 -1

0 0

【样例输出】

1

2

21 -11

20 -10

【样例解释】

第一个坐标 (1, -1) 经过三次操作后变为 (21, -11)；第二个坐标 (0, 0) 经过三次操 作后变为 (20, -10)。

【子任务】

全部的测试数据满足： n, m ≤ 100，所有输入数据（x, y, dx, dy）均为整数且绝对值 不超过 105。

坐标变换（其二）（product）

【题目描述】

对于平面直角坐标系上的坐标 (x, y)，小 P 定义了如下两种操作：

1\. 拉伸 k 倍：横坐标 x 变为 kx，纵坐标 y 变为 ky；

2\. 旋转 θ：将坐标 (x, y) 绕坐标原点 (0, 0) 逆时针旋转 θ 弧度（0 ≤ θ < 2π)。易知 旋转后的横坐标为 x cos θ - y sin θ,纵坐标为 x sin θ + y cos θ。

设定好了包含 n 个操作的序列 (t1 , t2 , · · · , tn ) 后，小 P 又定义了如下查询：

• i j x y：坐标 (x, y) 经过操作 ti , · · · , tj （1 ≤ i ≤ j ≤ n）后的新坐标。

对于给定的操作序列，试计算 m 个查询的结果。

【输入格式】

从标准输入读入数据。

输入共 n + m + 1 行。

输入的第一行包含空格分隔的两个正整数 n 和 m，分别表示操作和查询个数。

接下来 n 行依次输入 n 个操作，每行包含空格分隔的一个整数（操作类型）和一 个实数（k 或 θ),形如 1 k （表示拉伸 k 倍）或 2 θ （表示旋转 θ)。

接下来 m 行依次输入 m 个查询，每行包含空格分隔的四个整数 i 、j 、x 和 y，含 义如前文所述。

【输出格式】

输出到标准输出。

输出共 m 行，每行包含空格分隔的两个实数，表示对应查询的结果。

【样例输入】

1

2

3

4

5

6

7

8

9

10

10 5

2 0.59

2 4.956

1 0.997

1 1.364

1 1.242

1 0.82

2 2.824

1 0.716

2 0.178

11

12

13

14

15

16

2 4.094

1 6 -953188 -946637

1 9 969538 848081

4 7 -114758 522223

1 9 -535079 601597

8 8 159430 -511187

【样例输出】

1

2

3

4

5

\-1858706.758 -83259.993 -1261428.46 201113.678 -75099.123 -738950.159

\-119179.897 -789457.532 114151.88 -366009.892

【样例解释】

第五个查询仅对输入坐标使用了操作八：拉伸 0.716 倍。

横坐标： 159430 × 0.716 = 114151.88

纵坐标： —511187 × 0.716 = —366009.892

由于具体计算方式不同， 程序输出结果可能与真实值有微小差异， 样例输出仅保留 了三位小数。

【子任务】

80% 的测试数据满足： n, m ≤ 1000；

全部的测试数据满足：

• n, m ≤ 105；

• 输入的坐标均为整数且绝对值不超过 106；

• 单个拉伸操作的系数 k ∈ \[0.5, 2\]；

• 任意操作区间 ti , · · · , tj （1 ≤ i ≤ j ≤ n） 内拉伸系数 k 的乘积在 \[0.001, 1000\] 范 围内。

【评分方式】

如果你输出的浮点数与参考结果相比，满足绝对误差不大于 0.1 ，则该测试点满分， 否则不得分。

【提示】

• C/C++：建议使用 double 类型存储浮点数，并使用 scanf("%lf", &x); 进 行输入，printf("%f", x); 输出，也可以使用 cin 和 cout 输入输出浮点数；

#include &lt;math.h&gt; 后可使用三角函数 cos() 和 sin()。

• Python：直接使用 print(x) 即可输出浮点数 x；from math import cos, sin 后可使用相应三角函数。

• Java：建议使用 double 类型存储浮点数，可以使用 System.out.print(x); 进 行输出；可使用 Math.cos() 和 Math.sin() 调用三角函数。

梯度求解（gradient）

【题目背景】

西西艾弗岛运营公司近期在大力推广智能化市政管理系统。这套系统是由西西艾弗 岛信息中心研发的。它的主要目的是， 通过详细评估岛上各处的市政设施的状况， 来指 导市政设施的维护和更新。这套系统的核心是一套智能化的传感器网络， 它能够自动地 对岛上的市政设施进行评估。对市政设施的维护是需要一定成本的， 而年久失修的市政 设施也可能给岛上的居民造成损失。为了能够平衡成本和收益， 信息中心研发了一款数 学模型，描述这些变量和损益之间的复杂数学关系。要想得到最优化的成本， 就要依靠 梯度下降算法来求解。

梯度下降算法中，求解函数在一点处对某一自变量的偏导数是十分重要的。小 C 负 责实现这个功能， 但是具体的技术实现， 他还是一头雾水，希望你来帮助他完成这个任 务。

【题目描述】

设被求算的函数 u = f (x1 , x2, . . . , xn )，本题目要求你求出 u 对 xi 在 (a1 , a2, . . . , an ) 处的偏导数 

求算多元函数在一点处对某一自变量的偏导数的方法是： 将函数的该自变量视为单 一自变量，其余自变量认为是常数， 运用一元函数求导的方法求出该偏导数表达式， 再 代入被求算的点的坐标即可。

例如，要求算 u = x1 · x1 · x2 对 x1 在 (1, 2) 处的偏导数，可以将 x2 视为常数，依

次应用求导公式。先应用乘法的求导公式： (x1 · (x1 · x2 ))′ = x(x1 · x2 ) + x1 (x1 · x2 )′ ；再

应用常数与变量相乘的求导公式， 得到 x · x1 · x2 + x1 · x2 · x；最后应用公式 x′ = 1 得

到 1 · x1 · x2 + x1 · x2 · 1 。整理得  再代入 (1, 2) 得到 

常见的求导公式有：

• c′ = 0（c是常数）

• x′ = 1

• (u + v)′ = u′ + v′

• (cu)′ = cu′（c是常数）

• (u — v)′ = u′ — v′

• (uv)′ = u′ v + uv′

本题目中，你需要求解的函数 f 仅由常数、自变量和它们的加法、减法、乘法组 成。且为程序识读方便， 函数表达式已经被整理为逆波兰式（后缀表达式） 的形式。例 如，x1 · x1 · x2 的逆波兰式为 x1 x1 \* x2 \*。逆波兰式即为表达式树的后序遍历的结 果。若要从逆波兰式还原原始计算算式， 可以按照这一方法进行：假设存在一个空栈 S， 依次读取逆波兰式的每一个元素，若读取到的是变量或常量， 则将其压入 S 中；若读取 到的是计算符号，则从 S 中取出两个元素，进行相应运算，再将结果压入 S 中。最后，

若 S 中存在唯一的元素，则该表达式合法，其值即为该元素的值。例如对于逆波兰式 x1 x1 \* x2 \*，按上述方法读取，栈 S 的变化情况依次为（左侧是栈底，右侧是栈顶）：

1\. x1；

2\. x1 ，x1；

3\. (x1 · x1 )；

4\. (x1 · x1 ) ，x2；

5\. ((x1 · x1 ) · x2 )。

【输入格式】

从标准输入读入数据。

输入的第一行是由空格分隔的两个正整数 n 、m，分别表示要求解函数中所含自变 量的个数和要求解的偏导数的个数。

输入的第二行是一个逆波兰式，表示要求解的函数 f。其中，每个元素用一个空格 分隔，每个元素可能是：

• 一个自变量 xi ，用字符 x 后接一个正整数表示，表示第 i 个自变量，其中 i = 1, 2, . . . , n。例如，x1 表示第一个自变量 x1。

• 一个整常数，用十进制整数表示，其值在 —105 到 105 之间。

• 一个运算符，用 + 表示加法， - 表示减法， \* 表示乘法。

输入的第三行到第 m + 2 行，每行有 n + 1 个用空格分隔的整数。其中第一个 整数是要求偏导数的自变量的编号 i = 1, 2, . . . , n，随后的整数是要求算的点的坐标 a1 , a2, . . . , an。输入数据保证，对于所有的 i = 1, 2, . . . , n ，ai 都在 —105 到 105 之间。

【输出格式】

输出到标准输出。

输出 m 行，每行一个整数，表示对应的偏导数对 109 + 7 取模的结果。即若结果为 y，输出为 k，则保证存在整数 t，满足 y = k + t · (109 + 7) 且 0 ≤ k < 109 + 7。

【样例 1 输入】

1

2

3

4

2 2

x1 x1 x1 \* x2 + \*

1 2 3

2 3 4

【样例 1 输出】

1

2

15

3

【样例 1 解释】

读取逆波兰式，可得被求导的式子是： u = x1 · (x1 · x1 + x2 )，即 u = x + x1 x2。

对 x1 求偏导得  = 3x + x2 。代入 (2, 3) 得到 (2, 3) = 15。

对 x2 求偏导得  = x1 。代入 (3, 4) 得到 (3, 4) = 3。

【样例 2 输入】

1

2

3

4

5

6

7

3 5

x2 x2 \* x2 \* 0 + -100000 -100000 \* x2 \* -

3 100000 100000 100000

2 0 0 0

2 0 -1 0

2 0 1 0

2 0 100000 0

【样例 2 输出】

1

2

3

4

5

0

70

73

73

999999867

【样例 2 解释】

读取逆波兰式， 可得被求导的式子是： u = x2 · x2 · x2 + 0 — (—105 ) · (—105 ) · x2 ，即 u = x — 1010 x2。

因为 u 中实际上不含 x1 和 x3 ，对这两者求偏导结果均为 0。

对 x2 求偏导得  = 3x — 1010。

【子任务】

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点 | n   | m   | 表达式的性质 |
| 1, 2 | \= 1 | ≤ 100 | 仅含有 1 个元素 |
| 3, 4 | 仅含有一个运算符 |
| 5, 6 | ≤ 10 | 含有不超过 120 个元素，且不含乘法 |
| 7, 8 | 含有不超过 120 个元素 |
| 9, 10 | ≤ 100 |

【提示】

C++ 中可以使用 std::getline(std::cin, str) 读入字符串直到行尾。

当计算整数 n 对 M 的模时，若 n 为负数，需要注意将结果调整至区间 \[0, M) 内。

阴阳龙（dragon）

【题目描述】

西西艾弗岛的下方是一个庞大的遗迹群，神兽“阴阳龙”栖居在这个遗迹群中。

为了得到这件宝物，西西艾弗遗迹探索有限公司（以下简称“公司”）派遣了 p 名 员工前往遗迹群，这些员工依次编号为 1 到 p。

遗迹可以视为一个大小为 n × m 的网格，左下角坐标 (1, 1)，右上角坐标 (n, m)。初 始时，第 i 名员工所在的位置是 (xi , yi ) 。保证所有员工初始所在的位置两两不同。

作为神兽， 阴阳龙有着特殊之处。当其在 p = (u, v) 位置以强度 t ∈ \[1, 7\] 现身时， 会导致遗迹群的环境发生阴和阳的变转，从而导致在遗迹中的人的位置发生变化。

具体来说， 阴阳龙首先观察右、右上、上、左上、左、左下、下和右下这八个方向， 并在这八个方向找到和阴阳龙“距离”最近的员工（不包括 p）的“距离”。其中， 垂直 和水平方向的“距离”是指员工和阴阳龙连线的长度； 斜线方向的“距离”是指员工和 阴阳龙连线在水平方向上投影的长度。设想从阴阳龙的位置同时出发， 分别向这 8 个方 向前进，每一单位时间运动 1 个“距离”。如果在某一时刻，在某一方向刚好遇到一位 员工，则此时前进的距离即被记为 k；否则，如果在某一时刻，在某一方向上刚好到达 遗迹的边界，但是在此之前任何方向上都没有遇到员工，则令 k = 0。形式化描述上述 确定 k 的方法是：

记 d0 到 d7 依次为向量 (1, 0), (1, 1), (0, 1), (−1, 1), (−1, 0), (−1, −1), (0, −1), (1, −1)， 令：

K1 ={k ∈ N+ | ∃i ∈ \[0, 7\], j ∈ \[1, p\], s.t. (xj , yj ) = p + kdi }

K2 ={k ∈ N+ | ∀i ∈ \[0, 7\], (p + kdi ) ∈ \[1, n\] × \[1, m\] } 其中：

• (xi , yi ) 为第 i 名员工在此次阴阳龙现身前的位置（这个位置可能和其初始位置不 同，但为了方便起见，我们使用同一个记号）；

• K1 为所有员工到阴阳龙距离组成的集合；

• K2 为从阴阳龙出发直至在某一方向抵达边界所包括全部的距离组成的集合。

若 K = K1 ∩ K2 = ∅,则令 k = 0；否则令 k = minK > 0。

例如，参考下图中的例子，其中左下角为 (1, 1)，右上角为 (7, 7)，共有 8 名员工， 位置如图。

若 p = (4, 4)，那么员工 1 刚好在阴阳龙所在位置，不计入；员工 3 不在阴阳龙的 8 个方向上，不计入；员工 2 、4 、5 、6 与阴阳龙“距离”是 2；员工 7 、8 、9 与阴阳龙 “距离”是 3，因此有 K1 = {2, 3}。由于与阴阳龙“距离”为 3 就到达了遗迹的边界， 所 以有 K2 = {1, 2, 3}。因此 k = 2。

若 p = (2, 2)，那么员工 2 、3 、7 、8 、9 都不在阴阳龙的 8 个方向上，不计入；员工 1、6 与阴阳龙的“距离”是 2；员工 4、5 与阴阳龙的“距离”是 4，因此有 K1 = {2, 4}。

由于与阴阳龙“距离”为 1 时，就在向下、向左、向左下三个方向上到达了遗迹的边界， 所以有 K2 = {1}。因此 k = 0。

图 1: 变化前各员工位置

如果 k > 0，则将八个方向上的距离为 k 的位置上的员工以 p 为中心逆时针旋转 t 倍的八分之一个圆周的角度。形式化地：

• 若 k = 0 ，则什么也不会发生。

• 否则， ∀i ∈ \[0, 7\]，若 p + kdi 位置上有员工， 那么其该员工会被移动到 p + kd(i+t) mod 8。

易知在所有员工移动结束后， 每个位置上仍至多有一个员工。例如， 在上图所示的 例子中取 p = (4, 4), t = 1 ，则变化后各员工所在位置如下图所示。

图 2: 变化后各员工位置

在全部员工进入遗迹群后，西西艾弗遗迹探索有限公司总共探测到 q 次阴阳龙的 现身。很不幸的是， 由于来自东方神秘力量的干扰， 这 q 次阴阳龙的现身后， 西西艾弗 遗迹探索有限公司失去了所有员工的位置信息， 因此他希望你帮他计算出所有员工的位 置。

【输入格式】

从标准输入读入数据。

第一行四个正整数 n, m, p, q；

接下来 p 行，第 i 行两个正整数 (xi , yi ) 表示第 i 名员工的初始位置。

保证所有员工初始所在的位置两两不同。

. . . . . . . . . . . . . . . . .

接下来 q 行，第 i 行三个正整数 ui , vi , ti 表示西西艾弗遗迹探索有限公司探测到的 第 i 次阴阳龙现身的位置和强度。

【输出格式】

输出到标准输出。

为了减少输出量，设 q 次阴阳龙的现身后所有员工的位置为 (x1 , y1 ), . . . , (xp , yp )，则 你只需要输出：

p

其中 ⊕ 表示按位异或，即 C/C++ 中的 ^ 运算符。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

3 3 9 1

1 1

1 2

1 3

2 1

2 2

2 3

3 1

3 2

3 3

2 2 1

【样例 1 输出】

1

20

【样例 1 解释】

阴阳龙现身前，每个员工所在的位置如下：

1

2

3

3 6 9

2 5 8

1 4 7

阴阳龙现身一次后，每个员工所在位置如下：

1

2

3

6 9 8

3 5 7

2 1 4

【数据范围】

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 子任务编号 | n ≤ | m ≤ | p ≤ | q ≤ | 子任务分值 |
| 1   | 103 | 103 | 105 | 105 | 40  |
| 2   | 109 | 109 | 103 | 103 | 15  |
| 3   | 105 | 105 | 105 | 105 | 25  |
| 4   | 109 | 109 | 20  |

对于全部数据：

1 ≤ n, m ≤ 109 , 1 ≤ p, q ≤ 1 × 105 , 1 ≤ xi , u ≤ n, 1 ≤ yi , v ≤ m, 1 ≤ ti ≤ 7。 保证所有员工初始所在的位置两两不同。

. . . . . . . . . . . . . . . . .

阻击（block）

【题目描述】

上回提到，西西艾弗岛下方有一个庞大的遗迹群， 栖息着一种名为“阴阳龙”的神 兽。然而隔壁的狄迪吉岛盯上了西西艾弗岛， 决定发动一场战争，试图从遗迹群中掠夺 有价值的宝物。由此， 西西艾弗岛不得不陷入一场漫长的阻击战中， 史称“阴阳龙阻击 战”。

狄迪吉岛拥有胜过西西艾弗岛的科技实力和武装水平， 西西艾弗岛很快发现形势不 妙：全歼敌军似乎是不可能的， 唯一的策略是凭借主场作战的优势和人海战术， 尽可能 给敌军带来损失，当敌军发现发动进攻的损失明显超过收益时，就会无趣而归。

具体而言，西西艾弗岛共有 n 座城市，有 n — 1 条道路连接这些城市， 使得所有城 市之间均可以通过道路互相到达。容易发现， 任意两座城市之间都有唯一一条不经过重 复城市的路径。

由于缺乏城市巷战的实力， 西西艾弗岛决定将防御重心放在道路上。在每条道路上 均派遣了一定的军队防守， 当敌军经过时对其发动阻击。虽然由于实力的差距， 并不能 阻止敌军通过道路，但仍然可以对敌军造成一定的损失。

然而，敌军具有更强的科技， 可以趁机对道路附近的遗迹进行探索， 并掠夺其中的 宝物——这也正是敌军发动战争的意义所在。如此，敌军通过一条道路时，“发掘宝物 的收益”w 和“受到阻击的损失”b 两个值是独立的。

西西艾弗岛事先在狄迪吉岛中安插了一系列间谍， 得到的情报消息如下： 敌军将选 择西西艾弗岛的两座城市作为进攻的“起点”和“终点”，并派遣军队在进攻起点城市登 陆，沿两座城市间唯一的路径进攻至终点城市。同时， 间谍还背负着另外一个重要的使 命：影响敌军对于起点和终点城市的决策， 使得敌军受到的总损失尽可能大， 其中“总 损失”定义为敌军经过的每条道路上的“受到阻击的损失”减去“发掘宝物的收益”之 和，即 总损失 = ∑e是路径上的每条边(be — we )。

此外，遗迹中宝物的价值与所处的环境属性密切相关， 而阴阳龙的“现身”会使得 环境的阴阳属性发生变化， 这会使得敌军通过现身位置处的某一条道路时“发掘宝物的 收益”w 发生变化。

这样的“阴阳龙现身”事件共会发生 m 次，你的任务就是帮助间谍计算出在所有 事件前及每次事件后， 敌军对于起点和终点城市的决策应当怎样改变， 以最大化敌军的 总损失。

【输入格式】

从标准输入读入数据。

第 1 行，两个非负整数 n, m，分别表示西西艾弗岛的城市数和“阴阳龙现身”事件 数。

接下来 n — 1 行，每行 4 个非负整数 ui , vi , wi , bi ，表示第 i 条道路连接城市 ui 和 vi，敌军在这条道路上“发掘宝物的收益”为 wi，“受到阻击的损失”为 bi。

接下来 m 行，每行 2 个非负整数 xi , yi ，表示一次“阴阳龙现身”事件，使得第 xi 条道路的“发掘宝物的收益”变为 yi。

【输出格式】

输出到标准输出。

输出 m + 1 行，每行一个非负整数， 分别表示在所有事件前及每次事件后， 对敌军 造成的最大总损失。

【样例 1 输入】

1

2

3

4

5

6

7

8

5 3

1 2 6 4

2 3 2 1

3 4 5 3

3 5 8 5

3 2

4 3

1 1

【样例 1 输出】

1

2

3

4

0

1

3

4

【样例 1 解释】

在最初， 由于敌人攻打每一条道路都会有正收益， 因此间谍最好的策略就是将进攻 起点和终点选为同一座城市，这样敌军的总损失为 0。

第 1 次事件后，间谍可以将进攻起点和终点分别选在城市 3 和 4，这样敌军的总损 失为 3 — 2 = 1。

第 2 次事件后，间谍可以将进攻起点和终点分别选在城市 4 和 5，这样敌军的总损 失为 (3 — 2) + (5 — 3) = 3。

第 3 次事件后，间谍可以将进攻起点和终点分别选在城市 1 和 5，这样敌军的总损 失为 (4 - 1) + (1 - 2) + (5 - 3) = 4。

【数据范围】

对于所有测试数据保证：2 ≤ n ≤ 105 , 0 ≤ m ≤ 105 , 1 ≤ ui , vi ≤ n, 1 ≤ xi ≤ n - 1, 0 ≤ wi , bi , yi ≤ 109。

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点编号 | n ≤ | m ≤ | 特殊性质 |
| 1   | 20  | 20  | 无   |
| 2   | 300 | 300 |
| 3 ~ 4 | 3000 | 3000 | A   |
| 5 ~ 6 | B   |
| 7 ~ 9 | 无   |
| 10  | 105 | 0   | A   |
| 11  | B   |
| 12  | 无   |
| 13 ~ 15 | 105 | A   |
| 16 ~ 18 | B   |
| 19 ~ 21 | C   |
| 22 ~ 25 | 无   |

特殊性质 A：ui = i, vi = i + 1。

特殊性质 B：0 ≤ wi , yi ≤ 108 ≤ bi。

特殊性质 C：保证任意两座城市均可在经过不超过 100 条道路的前提下互相到达。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 30 次认证

时间：2023 年 5 月 28 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 重复局面 | 矩阵运算 | 解压缩 | 电力网络 | 闪耀巡航 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 5.0 秒 | 5.0 秒 | 1.0 秒 | 5.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 10  | 20  | 10  | 10  | 20  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

重复局面（chess）

【题目背景】

国际象棋在对局时， 同一局面连续或间断出现 3 次或 3 次以上，可由任意一方提出 和棋。

【题目描述】

国际象棋每一个局面可以用大小为 8 × 8 的字符数组来表示，其中每一位对应棋盘 上的一个格子。六种棋子王、后、车、象、马、兵分别用字母 **k**、**q**、**r**、**b**、**n**、**p** 表示， 其中大写字母对应白方、小写字母对应黑方。棋盘上无棋子处用字符 **\*** 表示。两个字符 数组的每一位均相同则说明对应同一局面。

现已按上述方式整理好了每步棋后的局面，试统计每个局面分别是第几次出现。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 n，表示这盘棋总共有 n 步。

接下来 8 × n 行，依次输入第 1 到第 n 步棋后的局面。具体来说每行包含一个长度 为 8 的字符串，每 8 行字符串共 64 个字符对应一个局面。

【输出格式】

输出到标准输出。

输出共 n 行，每行一个整数，表示该局面是第几次出现。

【样例输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**12**

**13**

**14**

**15**

**16**

**17**

**18**

**19**

**20**

**21**

**22**

**23**

**24**

**25**

**26**

**27**

**28**

**29**

**30**

**31**

**32**

**33**

**34**

**35**

**8**

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*r\*p p\*pQ\*\*\*\* \*\*\*\*\*\*\*\***

**\*\*b\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*r\*p p\*pQ\*\*\*\***

**\*b\*\*\*\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*r\*p p\*p\*\*\*\*\***

**\*b\*\*Q\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*k\***

**\*\*\*\*\*\*p\***

**\*\*\*\*\*r\*p p\*p\*\*\*\*\***

**\*b\*\*Q\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*k\***

**\*\*\*\*\*\*p\***

**36**

**37**

**38**

**39**

**40**

**41**

**42**

**43**

**44**

**45**

**46**

**47**

**48**

**49**

**50**

**51**

**52**

**53**

**54**

**55**

**56**

**57**

**58**

**59**

**60**

**61**

**62**

**63**

**64**

**65**

**\*\*\*\*\*r\*p p\*pQ\*\*\*\***

**\*b\*\*\*\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*r\*p p\*pQ\*\*\*\***

**\*b\*\*\*\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*r\*p p\*p\*\*\*\*\***

**\*b\*\*Q\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

**\*\*\*\*\*\*\*\***

**\*\*\*\*\*\*pk**

**\*\*\*\*\*\*rp p\*p\*\*\*\*\***

**\*b\*\*Q\*\*\***

**\*\*\*\*B\*PP**

**\*\*\*\*qP\*\***

**\*\*R\*\*\*K\***

【样例输出】

**1**

**2**

**3**

**4**

**1**

**1**

**1**

**1**

**5**

**6**

**7**

**8**

**1**

**2**

**2**

**1**

【样例解释】

第 6 、7 步后的局面分别与第 2 、3 步后的局面相同。第 8 步后的局面与上图相对 应。

【子任务】

输入数据满足 n ≤ 100。

【提示】

判断重复局面仅涉及字符串比较，无需考虑国际象棋实际行棋规则。

矩阵运算（matrix）

【题目背景】

Softmax( ) × V 是 Transformer 中注意力模块的核心算式， 其中 Q 、K 和 V 均 是 n 行 d 列的矩阵，KT 表示矩阵 K 的转置， × 表示矩阵乘法。

【题目描述】

为了方便计算，顿顿同学将 Softmax 简化为了点乘一个大小为 n 的一维向量 W：

(W · (Q × KT )) × V

点乘即对应位相乘，记 W(i) 为向量 W 的第 i 个元素，即将 (Q × KT ) 第 i 行中的每个 元素都与 W(i) 相乘。

现给出矩阵 Q 、K 和 V 和向量 W，试计算顿顿按简化的算式计算的结果。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 n 和 d，表示矩阵的大小。

接下来依次输入矩阵 Q 、K 和 V。每个矩阵输入 n 行，每行包含空格分隔的 d 个 整数，其中第 i 行的第 j 个数对应矩阵的第 i 行、第 j 列。

最后一行输入 n 个整数，表示向量 W。

【输出格式】

输出到标准输出。

输出共 n 行，每行包含空格分隔的 d 个整数，表示计算的结果。

【样例输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**3 2**

**1 2**

**3 4**

**5 6**

**10 10**

**\-20 -20**

**30 30**

**6 5**

**4 3**

**10**

**11**

**1**

**2**

**3**

**2 1**

**4 0 -5**

【样例输出】

**480 240**

**0 0**

**\-2200 -1100**

【子任务】

70% 的测试数据满足： n ≤ 100 且 d ≤ 10；输入矩阵、向量中的元素均为整数， 且 绝对值均不超过 30。

全部的测试数据满足：n ≤ 104 且 d ≤ 20；输入矩阵、向量中的元素均为整数，且 绝对值均不超过 1000。

【提示】

请谨慎评估矩阵乘法运算后的数值范围，并使用适当数据类型存储矩阵中的整数。

解压缩（decompress）

【题目背景】

西西艾弗岛运营公司是一家负责维护和运营岛上基础设施的大型企业。在公司内， 有许多分管不同业务的部门都需要使用到服务器设施。为了便于管理， 同时降低公司运 行成本，西西艾弗岛运营公司建设了一套私有云系统。这套私有云系统除了能提供托管 的虚拟机服务外，还能提供一些其他的服务。其中， 最受好评的当属日志服务。此前， 各 个业务系统的日志都是分散存放在各自的服务器上的， 这样不仅不方便查看和分析而且 也有丢失的风险。而日志服务则能够将各个业务系统的日志统一收集起来， 方便查看和 管理。

日志服务器收集到的日志都是纯文本， 且高度格式化。这意味着日志数据可以被压 缩得非常小。但是日志数据量非常大， 且对处理效率的要求较高， 因此可以牺牲一定的 压缩率，使用高效的压缩算法来压缩日志数据。小 C 被安排来实现解压缩日志的程序， 给定一段被压缩的日志数据，他需要将其解压缩。

【题目描述】

这种压缩算法产生的数据流， 可以被视为是一系列的元素。元素分为两种： 字面量 和回溯引用。字面量包含一系列的字节，对其进行解压缩时， 直接将这些字节输出即可。 回溯引用则是将此前已经解压缩得到的数据流的一部分重复输出。回溯引用可以表示为 ⟨o, l⟩, 包含两个数字，分别为偏移量 o 和长度 l。偏移量表示从当前位置向前回溯的距 离，长度表示需要重复输出的字节数。其中要求 o, l > 0。若已经解压缩了 p 字节， 当

o ≥ l 时，表示重复输出自偏移量 (p — o) （首个字节偏移量为 0）开始的 l 个字节。例如， 已经解压缩的数据流是 **abcde**，则回溯引用 ⟨3, 2⟩ 表示输出 **cd**。当 o < l 时，表示重复 输出自偏移量 (p — o) 开始的的 o 个字节，然后继续反复输出这 o 个字节，直到共输出 l 个字节。例如，已经解压缩的数据流是 **abcde**，则回溯引用 ⟨2, 5⟩ 表示输出 **deded**。

被压缩的数据格式分为两部分： 导引域和数据域。其中导引域保存了原始数据的长 度。设原始数据长度为 n。则 n 可以表示为  其中 0 ≤ ck < 128 ，且 cd  0。导引域的长度为 (d + 1) 字节，依次保存 c0 + 128, c1 + 128, · · · , cd- 1 + 128, cd。 即每个字节用低 7 位保存 ck ，除了最后一个字节的最高位为 0，其余字节的最高位为 1。 例如，原始数据的长度为 1324，那么 ck 依次为：44 、10，即 16 进制的 **0x2C**、**0x0A**。因 此引导区的长度为 2，字节序列为 **0xAC 0x0A**。

数据域保存了被压缩后的数据， 是连续存储的元素的序列。每个元素的第一个字节 的最低两位表示了元素的类型。当最低两位为 0 时，表示这是一个字面量。如果字面量 包含的字节个数为 l，且 l ≤ 60，那么第一个字节的高 6 位表示 (l — 1)。随后的 l 字节 即为字面量所包含的原始字节。例如字节 **0xE8**，其二进制为 **1110 1000**，低二位是 0， 表示这是一个字面量。高六位是 **111010**，表示数字 58，即表示该字面量包含 59 个字 节。因此，该字节后面的 59 个字节即为字面量所包含的原始字节。如果 l > 60，那么

图 1: 被压缩的数据格式

则将 (l - 1) 用小端序的 1 至 4 个字节表示，存储于第一个字节的后面。第一个字节的 高六位存储的值为 60 、61 、62 或 63 时，分别代表 (l - 1) 用 1 、2 、3 或 4 个字节表示。 例如，字节序列 **0xF4 0x01 0x0A** 中，首字节的二进制为 **1111 0100**，低二位是 0，表 示这是一个字面量。高 6 位是 **111101**，表示数字 61，即表示随后有两个字节存储了字 面量的长度。随后的两个字节 **0x01 0x0A**，按小端序组成了十六进制数 **0x0A01**，即十 进制 2561，表示该字面量包含 2562 个字节。随后的 2562 个字节即为字面量所包含的 原始字节。

图 2: 字面量，长度不超过 60 字节

图 3: 字面量，长度超过 60 字节

当元素首字节的最低两位是 **01** 时，表示这是一个回溯引用 ⟨o, l〉，且 4 ≤ l ≤ 11, 0 <

o ≤ 2047。此时，o 占 11 位，其低 8 位存储于随后的字节中，高 3 位存储于首字节的 高 3 位中。(l - 4) 占 3 位，存储于首字节的 2 至 4 位中。如下图所示：

**1**

**2**

**3**

**4**

**7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 +-----+-----+-+-+ +----------------+ |o(h3)| l-4 |0|1| |o (lower 8 bits)| +-----+-----+-+-+ +----------------+**

例如，字节 **0x2D 0x1A**，其首字节的二进制为 **001 011 01**，其最低两位为 **01**，表 示这是一个回溯引用，其中 2 至 4 位是 **011**，表示数字 3，意味着 (l - 4) = 3，即 l = 7。 其高 3 位是 **001**，与随后的字节 **0x1A** 组成了十六进制数 **0x11A**，即十进制 282，表示

o = 282。因此，该回溯引用是 ⟨282, 7〉。

图 4: 回溯引用，形式 1

当元素首字节的最低两位是 **10** 时，表示这是一个回溯引用 ⟨o, l〉，且 1 ≤ l ≤ 64, 0 <

o ≤ 65535。此时， o 占 16 位，以小端序存储于随后的两个字节中。 (l - 1) 占 6 位，存储 于首字节的高 6 位中。例如， 字节 **0x3E 0x1A 0x01**，其首字节的二进制为 **0011 1110**， 其最低两位为 **10**，表示这是一个回溯引用，其中高 6 位是 **001111**，表示数字 15，即 (l - 1) = 15，即 l = 16。随后的两个字节 **0x1A 0x01**，按小端序组成了十六进制数 **0x011A**，即十进制 282，表示 o = 282。因此，该回溯引用是 ⟨282, 16〉。

我们规定，元素的首字节的最低两位不允许是 **11**。如果出现了这种情况， 那么这个 数据域就是非法的。

压缩后的数据为合法的，当且仅当以下条件都满足：

1\. 引导区的长度不超过 4 字节；

2\. 引导区能被正确恢复为原始数据的长度；

3\. 每个元素的首字节的最低两位不是 **11**；

4\. 每个元素都能按照规则被恢复为原始数据；

5\. 得到的原始数据长度恰好等于引导区中编码的原始数据长度。

图 5: 回溯引用，形式 2

【输入格式】

从标准输入读入数据。

输入包含有若干行，第一行是一个正整数 s，表示输入被解压缩数据的字节数。

接下来有「⌉ 行，表示输入的被解压缩的数据。每行只含有数字或字母 **a** 至 **f**，每 两个字符组成一个十六进制数字，表示一个字节。除了最后一行，每行都恰有 8 个字节。 输入数据保证是合法的。

【输出格式】

输出到标准输出。

输出解压缩后的数据， 每行连续输出 8 个字节，每个字节由两位十六进制数字（数 字或字母 **a** 至 **f**）表示；但最后一行可以不满 8 个字节。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**81**

**8001240102030405**

**060708090af03c00**

**0102030405060708**

**090a0b0c0d0e0f01**

**0203040506070809**

**0a0b0c0d0e0f0102**

**030405060708090a**

**0b0c0d0e0f010203**

**0405060708090a0b**

**0c0d0e0fc603000d**

**78**

【样例 1 输出】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**12**

**13**

**14**

**15**

**16**

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**0102030405060708**

**090a000102030405**

**060708090a0b0c0d**

**0e0f010203040506**

**0708090a0b0c0d0e**

**0f01020304050607**

**08090a0b0c0d0e0f**

**0102030405060708**

**090a0b0c0d0e0f0d**

**0e0f0d0e0f0d0e0f**

**0d0e0f0d0e0f0d0e**

**0f0d0e0f0d0e0f0d**

**0e0f0d0e0f0d0e0f**

**0d0e0f0d0e0f0d0e**

**0f0d0e0f0d0e0f0d**

**0e02030405060708**

【样例 1 解释】

上述输入数据可以整理为：

**80 01**

**24 0102030405060708090a**

**f0 3c**

**000102030405060708090a0b0c0d0e0f**

**0102030405060708090a0b0c0d0e0f**

**0102030405060708090a0b0c0d0e0f**

**0102030405060708090a0b0c0d0e0f**

**c6 0300**

**0d 78**

首先读入第一字节 **80**，其最高位为 1，于是继续读入第二字节 **01**，其最高位为 0， 因此读入引导区结束。得到 c0 = 0，c1 = 1，原始数据长度为：0 × 1280 + 1 × 1281 = 128。

**12**

然后继续读入字节 **24**，其二进制是 **0010 0100**，最低两位为 **00**，表示这是一个字 面量，取其高六位，是十进制数字 9，表示这个字面量的长度为 10。接下来读入 10 个 字节，得到字面量 **0102030405060708090a**。

然后继续读入字节 **f0**，其二进制是 **1111 0000**，最低两位为 **00**，表示这是一个字 面量，取其高六位，是十进制数字 60，表示此后的一个字节是字面量的长度减 1。继续 读入字节 **3c**，得到数字 60，表示这个字面量的长度是 61，接下来读入 61 个字节。

然后继续读入字节 **c6**，其二进制是 **1100 0110**，最低两位为 **10**，表示这是一个回 溯引用，取其高六位，是十进制数字 49，表示回溯引用的长度 l 是 50。随后继续读入 两个字节 **0300**，按小端序组成十六进制数 **0x0003**，即十进制 3，表示回溯引用的偏移 量 o 是 3。因此， 这个回溯引用是 ⟨3, 50〉。由于 50 = 16 × 3 + 2，将此时缓冲区中最后 三个字节 **0d 0e 0f** 重复输出 16 次，然后继续输出 **0d 0e**，补足共 50 个字节。

然后继续读入字节 **0d**，其二进制是 **0000 1101**，最低两位为 **01**，表示这是一个回 溯引用，取其位 2 至 4，是 **011**，是十进制数字 3，表示回溯引用的长度 l 是 7。随后读入 一个字节 **78**，其二进制是 **0111 1000**，与本元素首字节 **0d** 的最高三位 **000** 拼合得到 **000 0111 1000**，是十进制数字 120，表示回溯引用的偏移量 o 是 120。因此， 这个回溯 引用是 ⟨120, 7〉。此前已经输出了 121 字节，此时从缓冲区开始的偏移量 121 − 120 = 1 的位置开始输出 7 个字节，即 **02030405060708**。

此时，输入已经处理完成， 共输出了 10 + 61 + 50 + 7 = 128 字节，与从引导区中读 入的原始数据长度一致，因此解压缩成功。

【子任务】

对于 10% 的输入，解压缩后的数据长度不超过 127 字节，且仅含有字面量，每个 字面量元素所含数据的长度不超过 60 字节；

对于 20% 的输入，解压缩后的数据长度不超过 1024 字节，且仅含有字面量， 每个 字面量元素所含数据的长度不超过 60 字节；

对于 40% 的输入，解压缩后的数据长度不超过 1024 字节，且仅含有字面量；

对于 60% 的输入，解压缩后的数据长度不超过 1024 字节，且包含的回溯引用的首 字节的最低两位都是 **01**；

对于 80% 的输入，解压缩后的数据长度不超过 4096 字节；

对于 100% 的输入，解压缩后的数据长度不超过 2MiB（2×220 字节），且 s ≤ 2×106， 且保证是合法的压缩数据。

电力网络（powergrid）

【题目描述】

西西艾弗岛电力公司需要修建一套电网对岛上的众多城镇进行供电。电网设施包括 建造在城镇中的变电站， 与建造在城镇间的输电线路。根据前期的考察结果， 电力公司 已经确定了哪些城镇之间需要建造输电线路， 以使得所有城镇能够被连接成一个电力网 络。每座城镇只需要建造一个变电站， 却都向电力公司提供了多个建造候选地址。对于 每个城镇，不同候选地址的变电站造价不同； 对于城镇间的输电线路， 其造价也会随着 两端变电站的候选地址的变化而变化。因此， 电力公司想要知道， 在所有候选地址的组 合中，电网的总造价（变电站造价加上输电线路造价）最低是多少。

【输入格式】

从标准输入读入数据。

输入的第一行包括三个正整数 N 、M 、K。表示一共有 N 座城镇，需要建造 M 条 输电线路，每座城镇都提供了 K 个变电站候选地址。

接下来输入 N 行，每行表示一个城镇。每行包含 K 个整数，表示该城镇不同候选 地址的变电站造价。

接下来 M 行，每行表示一条输电线路，包含 K2 + 2 个整数。前两个整数表示该输 电线路两端的城镇， 范围是 \[0, N)。第三个整数开始是大小为 K × K 的矩阵 T 的行主 序存储形式。Tij 表示当输电线路的第一个端点选择候选地址 i，第二个端点选择候选地 址 j 时的线路造价。

【输出格式】

输出到标准输出。

输出包含一行，这一行有一个整数，表示电网的最低总造价。

【样例输入】

**1**

**2**

**3**

**4**

**1**

**2 1 2**

**1 2**

**3 4**

**0 1 1 2 3 4**

【样例输出】

**5**

【样例解释】

城镇 0 与城镇 1 均选择了 0 号地址建造变电站。

【子任务】

对于全部数据， 保证由城镇与输电线路构成的图是无向无重边无自环的连通图， 保 证单个变电站与单条线路的造价均不超过 1000。

对于 20% 的数据，保证 N ≤ 6 ，K ≤ 10。

对于另外 20% 的数据，保证 N ≤ 104 ，K ≤ 10 ，M = N - 1。

对于另外 20% 的数据，保证 N ≤ 104 ，K ≤ 10 ，M = N。

对于另外 20% 的数据，保证 N ≤ 104 ，K ≤ 10。图中存在两个节点 S 、D，保证全 图去除 D 节点和与 D 节点相连的边后， 可以构成以 S 节点为根的一棵树，而且所有与 D 相连的节点都属于这棵树的叶子节点。

对于最后 20% 的数据，保证 N ≤ 104 ，K ≤ 10，且度数大于 2 的节点数量 ≤ 6。

闪耀巡航（cruise）

【题目描述】

西西艾弗岛旅游公司最近推出了一系列环绕西西艾弗岛的闪耀游轮航线。普通的航 线通常是一条环线， 以便乘客在漫长的旅途之后回到出发点； 而闪耀航线则多为有惊无 险的单程。因此， 西西艾弗岛旅游公司也允许乘客自己选择一些能够返回起点的航线组 合。具体而言，西西艾弗岛旅游公司推出的航线可以用仅包含小写字母的字符串表示， 其中每一种字母代表航线中途经的一个目的地。例如， 航线 **aqua** 表示从 **a** 出发，途经 **q** 和 **u**，最终返回 **a** 的航线。西西艾弗岛旅游公司目前运营着 N 条这样的航线，分别用 字符串 s1 , s2 , · · · , sN 表示。我们定义， 一条航线的长度为相应的字符串长度减 1，如航 线 **aqua** 的长度为 3。

西西艾弗岛旅游公司为了鼓励乘客乘坐其游轮， 推出了一项集章活动。乘坐其游轮 途经部分目的地（可以是搭乘的航线的起点或终点） 时，可以获得一枚印章。我们用字 符串 t 表示所有参与集章活动的目的地。当乘客集齐 t 中所有字母对应的印章时， 有机 会抽取免费住宿豪华酒店等幸运大奖。

为了确定集章活动给公司带来的预期利润， 西西艾弗岛旅游公司想知道： 对于每条 航线 si ，从 si 的起点出发搭乘 si 到达 si 的终点，再经过多条航线（可以是 0 条）完成 集章后返回 si 的起点，需要乘坐的航线组合的最小总长度。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 N 和一个字符串 t，保证 1 ≤ N ≤ 105 ，1 ≤ |t| ≤ 10， 且 t 仅包含不重复的小写字母。

接下来 N 行，每行包含一个字符串 si ，表示第 i 条航线。保证 2 ≤ |si | ≤ 106， 

【输出格式】

输出到标准输出。

输出包含 N 行，每行输出一个正整数表示对应航线组合的最小总长度，或者输出

**\-1** 表示不存在满足要求的航线组合。

【样例 1 输入】

**1**

**2**

**3**

**6 au**

**aqua glass**

**4**

**5**

**6**

**7**

**hug**

**shiny**

**sparkling**

**youth**

【样例 1 输出】

**1**

**2**

**3**

**4**

**5**

**6**

**3**

**14**

**14**

**14**

**26**

**14**

【样例 2 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**7 i**

**nonstop perfect rocket**

**thrilling train**

**trapper tripper**

【样例 2 输出】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**16**

**16**

**11**

**\-1**

**16**

**22**

**11**

【子任务】

对于 10% 的数据，保证 1 ≤ N ≤ 10 ，1 ≤ |t| ≤ 5。

对于另外 10% 的数据，保证 1 ≤ N ≤ 1000 ，|t| = 1。

对于另外 20% 的数据，保证 1 ≤ |t| ≤ 5。

对于 100% 的数据，保证 1 ≤ N ≤ 105，1 ≤ |t| ≤ 10，2 ≤ |si | ≤ 106， |si | ≤ 106， si 和 t 仅包含小写字母，且 t 中字母不重复。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 29 次

时间：2023 年 3 月 19 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 田地丈量 | 垦田计划 | LDAP | 星际网络 II | 施肥  |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 12.0 秒 | 2.0 秒 | 2.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 1024 MiB | 1024 MiB |
| 子任务数目 | 10  | 20  | 10  | 20  | 20  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

田地丈量（farm1）

【题目描述】

西西艾弗岛上散落着 n 块田地。每块田地可视为平面直角坐标系下的一块矩形区 域， 由左下角坐标 (x1 , y1 ) 和右上角坐标 (x2 , y2 ) 唯一确定，且满足 x1 < x2 、y1 < y2。 这 n 块田地中，任意两块的交集面积均为 0 ，仅边界处可能有所重叠。

最近，顿顿想要在南山脚下开垦出一块面积为 a × b 矩形田地，其左下角坐标为 (0, 0)、右上角坐标为 (a, b)。试计算顿顿选定区域内已经存在的田地面积。

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

输入的第一行包含空格分隔的三个正整数 n 、a 和 b，分别表示西西艾弗岛上田地 块数和顿顿选定区域的右上角坐标。

接下来 n 行，每行包含空格分隔的四个整数 x1 、y1 、x2 和 y2 ，表示一块田地的位 置。

【输出格式】

输出到标准输出。

输出一个整数，表示顿顿选定区域内的田地面积。

【样例输入】

1

2

3

4

5

1

4 10 10

0 0 5 5

5 -2 15 3

8 8 15 15

\-2 10 3 15

【样例输出】

44

【样例解释】

如图所示，选定区域内田地（绿色区域）面积为 44。

【子任务】

全部的测试数据满足 n ≤ 100，且所有输入坐标的绝对值均不超过 104。

垦田计划（farm2）

【题目描述】

顿顿总共选中了 n 块区域准备开垦田地， 由于各块区域大小不一，开垦所需时间也 不尽相同。据估算，其中第 i 块（1 ≤ i ≤ n）区域的开垦耗时为 ti 天。这 n 块区域可 以同时开垦，所以总耗时 tTotal 取决于耗时最长的区域，即：

tTotal = max{t1 , t2 , · · · , tn }

为了加快开垦进度，顿顿准备在部分区域投入额外资源来缩短开垦时间。具体来说：

• 在第 i 块区域每投入 ci 单位资源，便可将其开垦耗时缩短 1 天；

• 耗时缩短天数以整数记，即第 i 块区域投入资源数量必须是 ci 的整数倍；

• 在第 i 块区域最多可投入 ci × (ti — k) 单位资源，将其开垦耗时缩短为 k 天；

• 这里的 k 表示开垦一块区域的最少天数， 满足 0 < k ≤ min{t1 , t2 , · · · , tn }；换言 之，如果无限制地投入资源，所有区域都可以用 k 天完成开垦。

现在顿顿手中共有 m 单位资源可供使用，试计算开垦 n 块区域最少需要多少天？

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

输入的第一行包含空格分隔的三个正整数 n、m 和 k，分别表示待开垦的区域总数、 顿顿手上的资源数量和每块区域的最少开垦天数。

接下来 n 行，每行包含空格分隔的两个正整数 ti 和 ci ，分别表示第 i 块区域开垦 耗时和将耗时缩短 1 天所需资源数量。

【输出格式】

输出到标准输出。

输出一个整数，表示开垦 n 块区域的最少耗时。

【样例 1 输入】

1

2

3

4

5

4 9 2

6 1

5 1

6 2

7 1

【样例 1 输出】

1

5

【样例 1 解释】

如下表所示，投入 5 单位资源即可将总耗时缩短至 5 天。此时顿顿手中还剩余 4 单 位资源，但无论如何安排，也无法使总耗时进一步缩短。

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| i   | 基础耗时 ti | 缩减 1 天所需资源 ci | 投入资源数量 | 实际耗时 |
| 1   | 6   | 1   | 1   | 5   |
| 2   | 5   | 1   | 0   | 5   |
| 3   | 6   | 2   | 2   | 5   |
| 4   | 7   | 1   | 2   | 5   |

【样例 2 输入】

1

2

3

4

5

4 30 2

6 1

5 1

6 2

7 1

【样例 2 输出】

1

2

【样例 2 解释】

投入 20 单位资源，恰好可将所有区域开垦耗时均缩短为 k = 2 天；受限于 k，剩 余的 10 单位资源无法使耗时进一步缩短。

【子任务】

70% 的测试数据满足： 0 < n, ti , ci ≤ 100 且 0 < m ≤ 106；

全部的测试数据满足： 0 < n, ti , ci ≤ 105 且 0 < m ≤ 109。

LDAP（ldap）

【题目背景】

西西艾弗岛运营公司是一家负责维护和运营岛上基础设施的大型企业， 拥有数千名 员工。公司内有很多 IT 系统。为了能够实现这些 IT 系统的统一认证登录， 公司 IT 部 门决定引入一套 LDAP 系统来管理公司内的用户信息。轻型目录访问协议（Lightweight Directory Access Protocol ，LDAP）是一种用于访问和维护目录服务的应用层协议，基 于它的数据库可以用树形结构来组织和存储数据。每一笔数据，都包含了一个唯一的标 识符（DN ，Distinguished Name），以及一系列的属性（Attribute）。

不同的 IT 系统，允许访问的用户是不相同的。每个信息系统都有一个表达式，用 来描述允许访问的用户。这个表达式可以按照某一个属性的值作为条件来匹配用户， 也 可以用多个条件的逻辑组合来匹配用户。小 C 被安排来实现这样一个算法，给定一个 IT 系统的匹配表达式，找到所有与之匹配的用户的 DN。

【题目描述】

为了简化该问题， 我们约定，每个用户的 DN 是一个正整数，且不会重复。有若干 种用户的属性， 用正整数编号。每个用户可以具有这些属性中的若干个， 且每个属性只 能有一个值。每个属性的值也是一个正整数。例如， 假定有两个用户： 用户 1 和用户 2， 他们的 DN 分别是 1 和 2 。一共有 3 种属性。用户 1 具有属性 1 和属性 2，且属性 1 的 值为 2，属性 2 的值为 3；但不具有属性 3。用户 2 具有属性 2 和属性 3，且属性 2 的 值为 3，属性 3 的值为 1；但不具有属性 1 。如下表所示：

|     |     |     |     |
| --- | --- | --- | --- |
| DN  | 属性 1 | 属性 2 | 属性 3 |
| 1   | 2   | 3   | N/A |
| 2   | N/A | 3   | 1   |

一个匹配表达式可以是一个属性的值，也可以是多个匹配表达式的逻辑组合。只匹配

一个属性的值的表达式称为原子表达式，原子表达式的形式为 &lt;属性编号&gt;&lt;操作符&gt;&lt;属性值&gt;。

其中操作符有两种：断言与反断言。断言操作符为 :，表示匹配具有该属性且值与之相 等的用户；反断言操作符为 ~，表示匹配具有该属性且值与之不等的用户。例如，表达 式 1:2 可以与上述用户 1 相匹配，但不能与用户 2 相匹配；而表达式 3~1 则不能与任 何一个用户相匹配。

表达式可以进行逻辑组合， 其语法是：&lt;操作符&gt;(表达式 1)(表达式 2)。其中操作 符有两种：与（&）和或（|）。如果操作符为与， 则当且仅当两个表达式都与某一用户相 匹配时，该表达式与该用户相匹配； 如果操作符为或， 则当且仅当两个表达式中至少有 一个与某一用户相匹配时，该表达式与该用户相匹配。例如，表达式 &(1:2)(2:3) 可

以与用户 1 相匹配，但不能与用户 2 相匹配；而表达式 |(1:2)(3:1) 则可以与两个用 户都相匹配。

形式化地，上述语法用 BNF 范式表示如下：

1

2

3

4

5

6

7

8

9

10

11

12

13

NON_ZERO_DIGIT = "1" / "2" / "3" / "4" /

"5" / "6" / "7" / "8" / "9"

DIGIT = "0" / NON_ZERO_DIGIT

NUMBER = NON_ZERO_DIGIT / (NON_ZERO_DIGIT DIGIT\*)

ATTRIBUTE = NUMBER

VALUE = NUMBER

OPERATOR = ":" / "~"

BASE_EXPR = ATTRIBUTE OPERATOR VALUE

LOGIC = "&" / "|"

EXPR = BASE_EXPR / (LOGIC "(" EXPR ")" "(" EXPR ")")

EASY_EXPR = BASE_EXPR /

(LOGIC "(" BASE_EXPR ")" "(" BASE_EXPR ")")

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 n，表示用户的数目。

接下来 n 行，每行包含空格分隔的若干个正整数， 第一个正整数表示该用户的 DN， 第二个正整数表示该用户具有的属性个数， 此后的每两个正整数表示该用户具有的一个 属性及其值。这些属性按照属性编号从小到大的顺序给出。

接下来一行包含一个正整数 m，表示匹配表达式的数目。

接下来 m 行，每行包含一个匹配表达式。

【输出格式】

输出到标准输出。

输出 m 行，每行包含零个或多个正整数，用空格分隔，表示与对应的匹配表达式 相匹配的用户的 DN，由小到大排序。

【样例 1 输入】

1

2

3

2

1 2 1 2 2 3

2 2 2 3 3 1

4

5

6

7

8

4

1:2

3~1

&(1:2)(2:3) |(1:2)(3:1)

【样例 1 输出】

1

2

3

4

1

1

1 2

【样例 1 解释】

本组输入是题目描述中的例子。

【子任务】

对于 20% 的输入，有 1 ≤ n ≤ 100 ，1 ≤ m ≤ 10，每个用户的属性个数不超过 10， 全部属性编号不超过 100，且表达式是原子表达式，即符合 BNF 语法 BASE_EXPR。

对于 40% 的输入，有 1 ≤ m ≤ 100，每个用户的属性个数不超过 10，全部属性 编号不超过 100，且表达式中至多含有两个原子表达式的逻辑组合， 即符合 BNF 语法 EASY_EXPR。

对于 70% 的输入，有全部属性编号不超过 500。

对于全部输入，有 1 ≤ n ≤ 2500 ，1 ≤ m ≤ 500，每个用户的属性个数不超过 500， 全部属性编号和属性值均不超过 109 ，每个表达式语句都符合题设语法，且语句字符长 度不超过 2000。

星际网络 II（network）

【题目描述】

随着星际网络的进一步建设和规模的增大，一个新的问题出现在网络工程师面前 ——地址空间不够用了！原来，星际网络采用了传统的 IPv6 协议，虽然有 2128 级别的 可用地址数量， 但面对广袤无垠的宇宙和爆炸式增长的网络用户数， 如此庞大的地址空 间也面临了用尽的那一天。

新的通信协议的研发工作交给了著名的网络科技圣地——西西艾弗星。最终， 经过 2333 年的不懈努力，西西艾弗星的工程师们设计出了一种新的协议——“西西艾弗 IP 协议”，又称 IPxxaf。

在 IPxxaf 协议中，一个地址由 n 位二进制位组成，其中n 是 16 的倍数。日常表示一 个地址时，采用类似 IPv6 协议的十六进制表示法，每 4 位用 : 隔开。如 n = 32 时，地址 为 2a00:0001 ，即表示一个二进制为 0010 1010 0000 0000 0000 0000 0000 0001

的地址。注意不会出现 IPv6 中省略每组的前导 0 或用 :: 省略一段 0 的情况。

为方便起见，记 num(s) 为地址 s 按高位在前、低位在后组成的 n 位二进制数，称 一段“连续的地址“为 num(s) 成一段连续区间的一系列地址。

西西艾弗星的网络管理员负责地址的分配与管理。最开始， 整个地址空间都是未分 配的。用户可以随时向管理员申请一些地址：

1 id l r：表示用户 id 申请地址在 l ~r 范围内（包含 l 和 r，下同）的一段连续 地址块。

在地址申请操作中， 管理员需要先检查地址是否可用。如果用户申请的地址全部未 被分配，则检查通过；若地址中存在已经分配给其他用户的地址，则检查失败。

但有一种特殊情况： 申请的地址中没有已经分配给其他用户的地址， 但含有一些先 前已分配给该用户本人的地址。此时可以认为检查通过， 但若申请的地址先前已全部分 配给该用户则检查失败。

如果上述检查通过， 则管理员向用户返回 YES，并将申请的地址分配给该用户； 若 不通过，则向用户返回 NO，同时不改变现有的地址分配。

网络管理员要定期检查地址的分配情况，具体而言有如下两种操作：

2 s：检查地址 s 被分配给了哪个用户。若未被分配，则结果为 0。

3 l r：检查 l ~ r 范围内的所有地址是否完整地分配给了某个用户。若是， 回答 该用户的编号；若否，回答 0。

在整个网络的运行过程中， 共出现了 q 次申请地址和检查地址分配的操作。作为西 西艾弗星的一名重要的网络技术顾问， 你要帮网络管理员依次处理每个操作， 并回答相 应的结果。

【输入格式】

从标准输入读入数据。

第一行，2 个正整数 n, q。

接下来 q 行，每行一个操作，格式如上所述，其中的 id 为正整数，l, r, s 均为 IPxxaf 地址串，其中十六进制均用数字和小写字母表示。

【输出格式】

输出到标准输出。

输出 q 行，每行一个非负整数或字符串，表示此次操作的结果。

其中，对于操作 1 ，输出 YES 或 NO；对于操作 2, 3，输出一个非负整数。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

32 12

1 1 0001:8000 0001:ffff

2 0001:a000

3 0001:c000 0001:ffff

1 2 0000:0000 000f:ffff

2 0000:1000

1 1 0001:8000 0001:8fff

1 2 0000:0000 0000:ffff

2 0000:1000

1 1 0002:8000 0002:ffff

3 0001:8000 0002:ffff

1 1 0001:c000 0003:ffff

3 0001:8000 0002:ffff

【样例 1 输出】

1

2

3

4

5

6

7

8

9

10

YES

1

1

NO

0

NO

YES

2

YES

0

11

12

YES

1

【样例 1 解释】

第 4 个操作时，由于用户 2 申请的部分地址已被分配给用户 1 ，因此申请不通过；

第 6 个操作时，由于用户 1 申请的全部地址已被分配给用户 1 ，因此申请不通过；

第 11 个操作时，用户 1 申请的部分地址已被分配给用户 1 ，其余地址尚未被分配， 申请通过；

【数据范围】

对于所有数据， n ≤ 512, q ≤ 5 × 104 ，n 为 16 的倍数，id ≤ q，对于操作 1, 3 保证 num(l) ≤ num(r)。

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点编号 | n ≤ | q ≤ | 特殊性质 |
| 1 ~ 4 | 16  | 200 | 无   |
| 5 ~ 6 | 64  |
| 7 ~ 9 | 512 |
| 10 ~ 11 | 16  | 20000 |
| 12 ~ 13 | 64  | 50000 |
| 14 ~ 16 | 512 | 所有操作 1 的 id 互不相同 |
| 17 ~ 20 | 无   |

施肥（fertilize）

【题目描述】

春天到了，西西艾弗岛上的 n 块田地需要施肥了。n 块田地编号为 1, 2, · · · , n，按 照编号从小到大的顺序排成一列。

为了给田地施肥，顿顿准备了 m 辆施肥车。但是由于土地的松软程度不同，施肥 车的质量不一，不一定每一辆施肥车都能给每一块田地施肥。其中， 第 i 辆施肥车只能 恰好从第 li 块田地开到第 ri 块田地，并给编号在 li 与 ri 之间的田地（包含 li 和 ri ）都 施一遍肥。其中 1 ≤ li < ri ≤ n。

顿顿希望制定一个施肥的计划。首先， 他将选定二元组 (L, R)(1 ≤ L < R ≤ n)，并 选择只给编号在 L, R 之间（包含 L, R）的田地施肥。接着， 他会从使用这 m 辆施肥车 中的一部分（或全部） 对田地施肥。他想要保证：编号在 L 和 R 之内的田地至少被某

. . . . . . . . . . . . .

一辆施肥车施了一次肥，且编号范围外的田地都没有被施过肥。

. . . . . . . . . . . . . . . . . . . . . . . . . .

现在，他想知道，他能够选择多少种不同的二元组 (L, R) 作为施肥范围，使得可以 选出一部分（或全部）施肥车，完成他的目标。

【输入格式】

从标准输入读入数据。

第一行输入两个正整数 n, m，表示田地的块数和施肥车的辆数。数据保证 2 ≤ n ≤ 2 · 105 , 1 ≤ m ≤ 2 · 105。

接下来 m 行，第 i 行输入两个正整数 li , ri ，表示第 i 辆施肥车的施肥范围从第 li 块田地到第 ri 块田地。数据保证 1 ≤ li < ri ≤ n。

【输出格式】

输出到标准输出。

输出一个正整数，表示顿顿能够选择多少种不同的二元组 (L, R) 作为施肥范围，使 得他可以选出一部分（或全部）施肥车，完成他的目标。

【样例 1 输入】

1

2

3

4

4 3

1 2

3 4

2 3

【样例 1 输出】

1

6

【样例 1 解释】

在这组样例中，顿顿可以选择 6 种不同的二元组 (L, R)。

第一种：选择 (L, R) = (1, 2)，并只选取第 1 个施肥车施肥。

第二种：选择 (L, R) = (3, 4)，并只选取第 2 个施肥车施肥。

第三种：选择 (L, R) = (2, 3)，并只选取第 3 个施肥车施肥。

第四种：选择 (L, R) = (1, 4)，并选取第 1 个和第 2 个施肥车施肥。

第五种：选择 (L, R) = (1, 3)，并选取第 1 个和第 3 个施肥车施肥。

第六种：选择 (L, R) = (2, 4)，并选取第 2 个和第 3 个施肥车施肥。

【样例 2】

见题目目录下的 **_2.in_** 与 **_2.ans_**。

这个样例满足 n, m ≤ 18。

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

这个样例满足 n, m ≤ 50。

【样例 4】

见题目目录下的 **_4.in_** 与 **_4.ans_**。

这个样例满足 n, m ≤ 400。

【样例 5】

见题目目录下的 **_5.in_** 与 **_5.ans_**。

这个样例满足 n, m ≤ 3000。

【样例 6】

见题目目录下的 **_6.in_** 与 **_6.ans_**。

这个样例满足特殊性质 A。

【样例 7】

见题目目录下的 **_7.in_** 与 **_7.ans_**。 这个样例满足 n, m ≤ 200000。

【子任务】

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点编号 | n ≤ | m ≤ | 特殊性质 |
| 1   | 18  | 18  |     |
| 2   | 18  | 18  |     |
| 3   | 18  | 18  |     |
| 4   | 50  | 50  |     |
| 5   | 50  | 50  |     |
| 6   | 400 | 400 |     |
| 7   | 400 | 400 |     |
| 8   | 3000 | 3000 |     |
| 9   | 3000 | 3000 |     |
| 10  | 3000 | 3000 |     |
| 11  | 3000 | 3000 |     |
| 12  | 3000 | 3000 |     |
| 13  | 200000 | 200000 | A   |
| 14  | 200000 | 200000 | A   |
| 15  | 200000 | 200000 | A   |
| 16  | 200000 | 200000 |     |
| 17  | 200000 | 200000 |     |
| 18  | 200000 | 200000 |     |
| 19  | 200000 | 200000 |     |
| 20  | 200000 | 200000 |     |

特殊性质 A：保证任意两个施肥车的施肥范围不存在相互包含的关系，也就是说， 对任意 1 ≤ i &lt; j ≤ m ，li < lj , ri < rj 或 li &gt; lj , ri > rj 。

**CCF CSP** 软件能力认证

第 28 次

时间：2022 年 12 月 18 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 现值计算 | 训练计划 | JPEG 解码 | 聚集方差 | 星际网络 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 2.0 秒 | 3.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 1024 MiB |
| 子任务数目 | 10  | 10  | 10  | 6   | 25  |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 是   |

现值计算（pv）

【题目描述】

评估一个长期项目的投资收益， 资金的时间价值是一个必须要考虑到的因素。简单 来说，假设银行的年利率为 5%，那么当前的 100 元一年后就会变成 105 元，两年后变 成 110.25 元。因此， 现在收到 100 元比两年后收到 100 元收益更多，两年后再支出 100 元会比立刻支出 100 元更加划算。

基于上述分析，我们使用如下的模型来衡量时间价值：假设银行的年利率为 i，当 前（第 0 年）的 x 元就等价于第 k 年的 x × (1 + i)k 元；相应的，第 k 年的 x 元的当前 价值实际为 x × (1 + i)-k 元。

现给出某项目未来 n 年的预计收入支出情况， 在将所有款项转换为当前价值后， 试 计算该项目的总收益。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的一个正整数 n 和一个实数 i，分别表示年数和银行年 利率。

输入的第二行包含空格分隔的 n + 1 个整数，依次表示该项目第 0, 1, · · · , n 年的预 计收入（正数）或支出（负数）。

【输出格式】

输出到标准输出。

输出一个实数，表示该项目在当前价值标准下的总盈利或亏损。

【样例 1 输入】

1

2

1

2 0.05

\-200 100 100

【样例 1 输出】

\-14.059

【样例 1 解释】

该项目当前支出 200 元，在接下来两年每年收入 100 元。虽然表面看起来收支相 抵，但计算当前价值可知总共亏损了约 14.059 元。

【子任务】

全部的测试数据满足 0 < n ≤ 50 ，0 < i < 1 且 i 的有效数字不多于 3 位，每年预 计收入（正数）或支出（负数）的绝对值不大于 1000。

【评分方式】

如果你输出的浮点数与参考结果相比，满足绝对误差不大于 0.1 ，则该测试点满分， 否则不得分。

【提示】

• C/C++：建议使用 double 类型存储浮点数，并使用 scanf("%lf", &x); 进行 输入，printf("%f", x); 进行输出。

• Python：直接使用 print(x) 进行输出即可。

• Java：建议使用 double 类型存储浮点数，可以使用 System.out.print(x); 进 行输出。

训练计划（plan）

【题目背景】

西西艾弗岛荒野求生大赛还有 n 天开幕！

【题目描述】

为了在大赛中取得好成绩，顿顿准备在 n 天时间内完成“短跑”、“高中物理”以 及“核裂变技术”等总共 m 项科目的加强训练。其中第 i 项（1 ≤ i ≤ m）科目编号为 i，也可简称为科目 i。已知科目 i 耗时 ti 天，即如果从第 a 天开始训练科目 i，那么第 a + ti - 1 天就是该项训练的最后一天。

大部分科目的训练可以同时进行， 即顿顿在同一天内可以同时进行多项科目的训 练，但部分科目之间也存在着依赖关系。如果科目 i 依赖科目 j，那么只能在后者训练 结束后，科目 i 才能开始训练。具体来说， 如果科目 j 从第 a 天训练到第 a + tj - 1 天， 那么科目 i 最早只能从第 a + tj 天开始训练。还好，顿顿需要训练的 m 项科目依赖关 系并不复杂， 每项科目最多只依赖一项别的科目， 且满足依赖科目的编号小于自己。那 些没有任何依赖的科目，则可以从第 1 天就开始训练。

对于每一项科目，试计算：

1）最早开始时间：该科目最早可以于哪一天开始训练？

2）最晚开始时间：在不耽误参赛的前提下（n 天内完成所有训练），该科目最晚可 以从哪一天开始训练？

n 天内完成所有训练，即每一项科目训练的最后一天都要满足 ≤ n。需要注意，顿 顿如果不能在 n 天内完成全部 m 项科目的训练，就无法参加大赛。这种情况下也就不 需要再计算“最晚开始时间”了。

【输入格式】

从标准输入读入数据。

输入共三行。

输入的第一行包含空格分隔的两个正整数 n 和 m，分别表示距离大赛开幕的天数 和训练科目的数量。

输入的第二行包含空格分隔的 m 个整数，其中第 i 个（1 ≤ i ≤ m）整数 pi 表示科 目 i 依赖的科目编号，满足 0 ≤ pi < i ；pi = 0 表示科目 i 无依赖。

输入的第三行包含空格分隔的 m 个正整数，其中第 i 个（1 ≤ i ≤ m）数 ti 表示训 练科目 i 所需天数，满足 1 ≤ ti ≤ n。

【输出格式】

输出到标准输出。

输出共一行或两行。

输出的第一行包含空格分隔的 m 个正整数，依次表示每项科目的最早开始时间。

如果顿顿可以在 n 天内完成全部 m 项科目的训练，则继续输出第二行，否则输出 到此为止。

输出的第二行包含空格分隔的 m 个正整数，依次表示每项科目的最晚开始时间。

【样例 1 输入】

1

2

3

1

2

10 5

0 0 0 0 0

1 2 3 2 10

【样例 1 输出】

1 1 1 1 1

10 9 8 9 1

【样例 1 解释】

五项科目间没有依赖关系，都可以从第 1 天就开始训练。

10 天时间恰好可以完成所有科目的训练。其中科目 1 耗时仅 1 天，所以最晚可以 拖延到第 10 天再开始训练；而科目 5 耗时 10 天，必须从第 1 天就开始训练。

【样例 2 输入】

1

2

3

1

10 7

0 1 0 3 2 3 0

2 1 6 3 10 4 3

【样例 2 输出】

1 3 1 7 4 7 1

【样例 2 解释】

七项科目间的依赖关系如图所示，其中仅科目 5 无法在 10 天内完成训练。

具体来说，科目 5 依赖科目 2、科目 2 又依赖于科目 1，因此科目 5 最早可以从第 4 天开始训练。

1 2 3 4 5 6 7

【样例 3 输入】

1

2

3

1

10 5

0 1 2 3 4

10 10 10 10 10

【样例 3 输出】

1 11 21 31 41

【子任务】

70% 的测试数据满足：顿顿无法在 n 天内完成全部 m 项科目的训练，此时仅需输 出一行“最早开始时间”；

全部的测试数据满足 0 < n ≤ 365 且 0 < m ≤ 100。

JPEG 解码（jpeg）

【题目背景】

四年一度的世界杯即将画上尾声。在本次的世界杯比赛中，视频助理裁判（Video Assistant Referee, VAR）的应用可谓是大放异彩。VAR 使用视频回放技术帮助主裁判 作出正确判罚决定。西西艾弗岛足球联赛的赛场上也引入了一套 VAR 设备。作为技术 供应商的技术主管小 C，需要存储和编码 VAR 产生的图像数据。小 C 分析比较发现， JPEG 编码算法可以达到较好的压缩效果， 并且质量损失是可以接受的。因此， 小 C 决 定使用 JPEG 编码算法来存储和传输图像数据。JPEG 是一种常用的图片有损压缩算 法，它的压缩率高， 但是压缩后的图片质量下降较多。 JPEG 图片的压缩率一般在 10:1 到 20:1 之间，一般用于存储照片等图片质量要求不高的场景。

为了简化问题，我们以灰度图片为例，介绍 JPEG 编码算法的过程。一张灰度图片， 可以被视为由多个像素点组成。每个像素点对应一个 0 到 255 之间的数值，用于表示像 素点的亮度。JPEG 编码算法将图片分割为 8 × 8 的小块，每个小块被称作一个最小编 码单元。对每个小块进行如下的计算：

1\. 将每个像素点的数值减去 128，使得每个像素点的数值都在 -128 到 127 之间。

2\. 将每个小块的像素点排成一个 8 × 8 的矩阵，并对矩阵进行离散余弦变换（DCT）。 进行离散余弦变换后， 仍然得到一个 8 × 8 的矩阵，矩阵中的每个元素都是实数， 并且所得矩阵的左上方的数字的绝对值较大， 右下方的数字的绝对值较小， 甚至 接近 0。

3\. 对矩阵进行量化操作。量化操作是指将矩阵中的每个元素都除以一个数字，并取 整数。量化操作的目的是为了减少矩阵中的数据，从而减少编码后的文件大小。 量化操作的数字越大，矩阵中的数据就越少，但是压缩后的图片质量也会越差。

4\. 对矩阵进行 Z 字形扫描。Z 字形扫描是指从左上角开始，沿着 Z 字形的路径扫 描矩阵中的元素，将扫描到的元素依次排成一个数组，由于 Z 字形扫描的路径是 从左上角到右下角，数组结尾处可能存在着连续的 0，为了节省空间，可以不存 储这些连续的 0 。得到的数据被称为扫描数据。

最后，将得到的各个小块的扫描数据采用哈夫曼编码进行压缩， 并置于必要的数据 结构中，就能得到一张 JPEG 图片了。

【题目描述】

在本题中，你需要实现一个能够解码 JPEG 图片的一个最小编码单元的程序。解码 的步骤与上述编码的步骤相反，具体的步骤是：

1\. 读入量化矩阵 Qi,j，其中 i, j 的取值范围为 0 ~ 7。

2\. 初始化一个 8 × 8 的矩阵 M，令 Mi,j = 0。

3\. 读入扫描数据，将扫描数据按照这样的顺序写入矩阵 M：从左上角 M0,0 开始， 接下来填充它的右侧相邻的元素 M0, 1 ，然后依次向左下方填充直至 M1,0 ，接下

来从它下侧相邻的元素 M2,0 开始，依次向右上方填充直至 M0,2 ，依次类推，循 环往复，直至填充满整个矩阵或用尽所有扫描数据，如图所示。

|     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |

图 1: 填充顺序

4\. 将矩阵 M 中的每个元素都乘以量化矩阵 Q 中的对应元素。

5\. 对矩阵 M 进行离散余弦逆变换， 得到一个 8 × 8 的矩阵 M′。其中， 逆变换的公 式如下：

其中 

6\. 将矩阵 M′ 中的每个元素都加上 128，并取最接近的整数（四舍五入）。如果得到 的整数大于 255，则取 255；如果得到的整数小于 0，则取 0。得到的矩阵即为解 码后的图片。

例如，假设给定的量化矩阵是：

I I

**I** 14 13 16 24 40 57 69 56 **I**

**I** 14 17 22 29 51 87 80 62 **I**

I I

**I** 18 22 37 56 68 109 103 77 **I** I I

I 24 35 55 64 81 104 113 92 I

I I

**I** 49 64 78 87 103 121 120 101 **I** l72 92 95 98 112 100 103 99 」

给出的扫描数据是： -26, -3, 0, -3, -2, -6, 2, -4, 1, -3, 1, 1, 5, 1, 2, -1, 1, -1, 2, 0, 0, 0, 0, 0, -1 -1，那么填充后的矩阵 M 是：

I I

**I** \-3 1 5 -1 -1 0 0 0**I**

**I** \-3 1 2 -1 0 0 0 0**I**

I I

**I** 1 0 0 0 0 0 0 0 **I** I I

I 0 0 0 0 0 0 0 0 I

I I

与量化矩阵逐项相乘后的矩阵是：

「-416 -33 -60 32 48 -40 0 01

**I** 0 -24 -56 19 26 0 0 0**I**

I I

**I** \-42 13 80 -24 -40 0 0 0**I**

**I** \-42 17 44 -29 0 0 0 0**I**

I I

**I** 18 0 0 0 0 0 0 0 **I** I I

I 0 0 0 0 0 0 0 0 I

I I

经过离散余弦逆变换后的矩阵 M′ 是：

I I

**I** \-70.40 -78.12 -68.13 -17.40 19.72 -14.45 -60.84 -63.38 **I**

**I** \-63.00 -73.21 -61.78 -7.56 26.97 -13.59 -60.21 -57.75 **I**

I I

**I** \-58.02 -65.09 -61.36 -27.06 -6.29 -40.45 -67.70 -50.14 **I**

I I

I -57.26 -57.09 -64.34 -57.62 -48.02 -65.58 -72.36 -47.25 I

经过加 128 后并取整的矩阵是：

I I

**I** 58 50 60 111 148 114 67 65 **I I** 65 55 66 120 155 114 68 70 **I** I I

**I** 70 63 67 101 122 88 60 78 **I** I I

I 71 71 64 70 80 62 56 81 I

I I

【输入格式】

从标准输入读入数据。

输入的前 8 行，每行有空格分隔 8 个正整数，是量化矩阵。

接下来的 1 行是 1 个正整数 n，表示扫描数据的个数。

接下来的 1 行是 1 个数字 T，取值为 0 、1 或 2 ，表示要进行的任务。

接下来的 1 行，有空格分隔的 n 个整数，是扫描数据。

【输出格式】

输出到标准输出。

输出共 8 行，每行有 8 个空格分隔的整数，表示一个图像矩阵。

当 T 取 0 时，输出填充（步骤 3）后的图像矩阵；当 T 取 1 时，输出量化（步骤 4）后的图像矩阵；当 T 取 2 时，输出最终的解码结果。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

16 11 10 16 24 40 51 61

12 12 14 19 26 58 60 55

14 13 16 24 40 57 69 56

14 17 22 29 51 87 80 62

18 22 37 56 68 109 103 77

24 35 55 64 81 104 113 92

49 64 78 87 103 121 120 101

72 92 95 98 112 100 103 99

26

2

\-26 -3 0 -3 -2 -6 2 -4 1 -3 1 1 5 1 2 -1 1 -1 2 0 0 0 0 0 -1 -1

【样例 1 输出】

1

2

3

4

5

6

7

8

62 65 57 60 72 63 60 82

57 55 56 82 108 87 62 71

58 50 60 111 148 114 67 65

65 55 66 120 155 114 68 70

70 63 67 101 122 88 60 78

71 71 64 70 80 62 56 81

75 82 67 54 63 65 66 83

81 94 75 54 68 81 81 87

【样例 1 解释】

本组样例即为题目描述中的样例。

【子任务】

对于 20% 的数据，有 T = 0；

对于 40% 的数据，有 T = 0 或 1；

对于 100% 的数据，有 T ∈ {0, 1, 2}，且 n ∈ \[0, 64\]，并且量化矩阵中的各个元素 qi,j 满足 0 < qi,j < 256，扫描序列中的各个元素 mi 满足 -256 < mi < 256。

【提示】

在 C/C++ 语言中，可以通过包含 math.h（C 语言）或 cmath（C++ 语言）来使 用数学函数。 π 的值可以通过表达式 acos(-1) 获得。

在 Python 语言中，可以通过 from math import pi 引入 π。 在 Java 语言中，可以使用 Math.PI 来获取 π 的值.

聚集方差（D）

【题目背景】

通常而言，对一组数据 A = {a1, ..., an }，可以使用方差  来衡量其离散程度  为平均值），或者说“整体聚集 ”的程度。然 而，现实生活中的数据有时是“分组聚集”的——它们可以被分为若干组，每一组都是 相对“聚集”的，但不同组间差距较大， 因此整体相对离散。此时， 方差无法反映这种 分组聚集的性质， 而人为指定分组的情况则使计算复杂。为此， 可以提出一种简单的衡 量方式：称一组数据 A = {a1 , a2, ..., an } 的“聚集方差”为：

特别的，当 n = |A| = 1 时，规定 G(A) = 0。

例如，对 A = {0, 0, 0, 4, 4, 4, 7, 8, 9}，则方差  说明若 A 按 {0, 0, 0}, {4, 4, 4}, {7, 8, 9} 的方式分组，则相对与整体而言， 每一组内都相 对聚集。

【题目描述】

考虑这样一个模型：现实中一个公司的结构可以用一棵有根树来描述， 其中每个点 对应一位员工，其父节点（如果有的话） 代表了他的直属上司， 而其自子树中的点（包 括这个点本身） 则代表所有可被他支配的员工（广义的讲， 人可以支配自己， 因此人可 以视为自己的员工，因此此处“员工”的概念包括他自己本人）。

一般地，假定该公司内有 n 位员工，编号从 1 到 n；对编号为 x 的员工，记 T (x) 为其子树内所有点的编号的集合（包括 x 本身）。

对 x > 1，记 px 为其父节点的编号，并假定总有 1 ≤ px < x（从而编号为 1 的员 工是该公司唯一的老板）。

我们说明“聚集方差”可以作为一种统计方式帮助该公司的老板了解他的公司， 例 如，假定每个员工每年都有一小时的可以自主选择时间的带薪年假， 那么可以根据历史 数据，统计出每位员工偏好的时间；对第 x （1 ≤ x ≤ n）位员工，可以用一个非负整 数 ax 表示其偏好的时间。

记 A(x) = {ay : y ∈ T (x)} 为编号为 x 的点的子树内所有点（包括 x）对应员工的 偏好时间的可重集合（从而 |A(x)| = |T (x)|）。那么，对于一位编号为 x 的员工，若其 可支配的员工偏好的时间的聚集方差  较 小，那么说明他可能需要担心会因在某个时间有较多的员工请假而导致工作任务受到影 响，从而应该调整工作日程以避免这一问题；反之则说明他不太需要过多关注这一点。

因此该公司的老板想了解， 对每个 x ∈ \[1, n\] ，G(A(x)) 是多少？ 当然，为了避免精 度误差，你只需要输出 Vx = |T (x)|G(A(x))。容易验证 Vx 总是整数。

【输入格式】

从标准输入读入数据。

第一行输入一个正整数 n 表示树的大小；

接下来一行输入 n − 1 个正数依次表示 p2 , ..., pn ； 接下来一行输入 n 个非负整数依次表示 a1 , ..., an。

【输出格式】

输出到标准输出。

输出 n 行，其中第 i 行包含一个非负整数表示 Vi。

【样例 1 输入】

1

2

3

2

1

0 1

【样例 1 输出】

1

2

2

0

|     |     |     |     |
| --- | --- | --- | --- |
| 子任务编号 | n ≤ | 特殊性质 | 子任务分值 |
| 1   | 300 | /   | 15  |
| 2   | 3, 000 | 25  |
| 3   | 3 × 105 | A   | 15  |
| 4   | B   |
| 5   | C   | 10  |
| 6   | /   | 20  |

特殊性质 A：∀i ∈ (1, n\] ，pi = i − 1。

特殊性质 B：∀i ∈ (1, n\] ，pi = 。

特殊性质 C：∀i, j ∈ \[1, n\] ，i  j ⇒ ai  aj 。

对于所有的数据保证：2 ≤ n ≤ 3 × 105，∀i ∈ (1, n\], pi ∈ \[1, i); ∀i ∈ \[1, n\], ai ∈ \[0, 109 \]。

星际网络（starnet）

【题目描述】

23333 年，在经过长时间的建设后，一个庞大的星际网络终于初具规模。星际网络 共接入了 n 颗星球， 由 m 颗中继卫星来实现星球之间的互联互通。所有星球之间的通 信都必须经由一颗或多颗中继卫星来实现， 星球本身也可以起到中继的作用， 如果两颗 星球的距离很远，数据可以沿“星球——中继卫星——星球——中继卫星——...——星 球”的模式进行传输。

对于每一颗中继卫星而言， 可以与多颗距离上较为接近的星球通信， 但由于卫星结 构的设计原因，通信只能单向进行。具体而言， 第 i 颗中继卫星可以接收编号在 \[l1i, r1i\] 范围内的星球发送来的数据，并向编号在 \[l2i, r2i\] 范围内的星球发送数据。

数据在星际之间传输的延迟当然是惊人的。为简单起见， 我们假设这一延迟只由数 据经过的中继卫星决定， 即数据从不同的星球发出， 经同一个中继卫星， 到达不同的星 球，所需的延迟时间总是相同的。对于第 i 颗中继卫星，数据经由该中继卫星传输所 需的延迟时间约为 Ti 秒。由于这个数字实在太过巨大，而且对于星际间通信的延迟估 计总是充满了各种不准确因素， 我们只关心其若干位有效数字， 具体而言将给出二元组 (ai , bi ) ，表示 Ti = ai × 2bi 。我们假设数据在其他位置的延迟均可忽略。实际传输中， 数 据从源星球发出， 经由很多颗中继卫星和星球最终到达目的星球， 则总延迟为过程中经 过的所有中继卫星的延迟之和。

数据从某个星球出发到达另一个星球，其在中继卫星和星球之间所经过的传输路径 可能是多种多样的。与普通的计算机网络类似， 我们需要设计相应的路由算法来选择合 适的传输路径。 一种直观的方案是最小延迟原则， 即数据总是会选择总延迟时间最小的 传输路径。

星际网络建成后，工程师们希望通过类似于计算机网络中 ping 的方法来测试该网 络。从星球 A 向星球 B 发起一次 ping 的经过如下：首先从星球 A 发送请求数据，数 据经星际网络传输至星球 B，星球 B 随即发送回复数据，经星际网络传输至星球 A，星 球 A 计算从它发出请求到收到回复的所经时间，称为此次 ping 的响应时间。如果星际 网络结构有缺陷，使得星球 A 发出的请求无法到达星球 B，或星球 B 发出的回复无法 到达星球 A，则星球 A 在等待足够长时间后会得到“请求超时”的结果。

现在需要从 1 号星球向其他所有星球依次发起一次 ping，假设所有数据的传输均 遵循最小延迟原则，请你计算出每次 ping 的响应时间。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个正整数 n, m。

接下来 m 行：每行包含 6 个非负整数 l1i, r1i, l2i, r2i, ai , bi ，描述一颗中继卫星，具 体含义如上所述。

【输出格式】

输出到标准输出。

输出一行包含 n - 1 个整数，第 i 个整数表示星球 1 向星球 i + 1 发起 ping 的响应 时间，答案对 109 + 7 取模后输出。

特别地，如果某次 ping 的结果为请求超时，请输出 -1。

【样例 1 输入】

1

2

3

4

5

6

5 5

1 2 2 3 1 2

2 2 1 1 3 0

2 3 4 5 1 1

3 3 4 4 1 0

4 4 1 2 1 0

【样例 1 输出】

1

7 6 6 -1

【样例 1 解释】

从 1 号星球到 2 号星球的请求数据最小延迟为 4 ，2 号星球的回复数据最小延迟为 3。

从 1 号星球到 3 号星球的请求数据最小延迟为 4 ，3 号星球的回复数据最小延迟为 2。

从 1 号星球到 4 号星球的请求数据最小延迟为 5 ，4 号星球的回复数据最小延迟为 1。

从 1 号星球到 5 号星球的请求数据最小延迟为 6 ，5 号星球的回复数据无法到达 1 号星球。

【样例 2 输入】

1

2

3

3 2

1 2 1 2 999999999 34

2 3 2 3 987654321 12

【样例 2 输出】

1

122094981 986235983

【数据范围】

对于所有数据保证：n ≤ 105 , m ≤ 105 , 1 ≤ l1i ≤ r1i ≤ n, 1 ≤ l2i ≤ r2i ≤ n, 1 ≤ ai ≤ 109 , 0 ≤ bi ≤ 105。

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 测试点编号 | n ≤ | m ≤ | bi ≤ | 特殊性质 |
| 1   | 10  | 10  | 0   | 无   |
| 2 ~ 3 | 100 | 100 |
| 4 ~ 5 | 1000 | 1000 |
| 6 ~ 8 | 105 | 105 | l1i = r1i, l2i = r2i |
| 9 ~ 10 | l1i = r1i |
| 11 ~ 13 | 无   |
| 14 ~ 15 | 100 | 100 | 100 |
| 16 ~ 17 | 1000 | 1000 | 1000 |
| 18 ~ 20 | 105 | 105 | 105 | l1i = r1i, l2i = r2i |
| 21 ~ 22 | l1i = r1i |
| 23 ~ 25 | 无   |

**CCF CSP** 计算机软件能力认证

CCF CSP

第 27 次

时间：2022 年 9 月 18 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 如此编码 | 何以包邮？ | 防疫大数据 | 吉祥物投票 | 高维亚空间<br><br>超频物质变 压缩技术 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 1024 MiB | 1024 MiB |
| 子任务数目 | 20  | 20  | 10  | 20  | 4   |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 否   |

如此编码（code）

【题目背景】

某次测验后，顿顿老师在黑板上留下了一串数字 23333 便飘然而去。凝望着这个神 秘数字，小 P 同学不禁陷入了沉思 ……

【题目描述】

已知某次测验包含 n 道单项选择题，其中第 i 题（1 ≤ i ≤ n）有 ai 个选项，正确 选项为 bi ，满足 ai ≥ 2 且 0 ≤ bi < ai。比如说， ai = 4 表示第 i 题有 4 个选项，此时正 确选项 bi 的取值一定是 0 、1 、2 、3 其中之一。

顿顿老师设计了如下方式对正确答案进行编码， 使得仅用一个整数 m 便可表示 b1 , b2 , · · · , bn。

首先定义一个辅助数组 {ci }，表示数组 {ai } 的前缀乘积。当 1 ≤ i ≤ n 时，满足：

ci = a1 × a2 × · · · × ai

特别地，定义 c0 = 1。

于是 m 便可按照如下公式算出：

 (1)

\= c0 × b1 + c1 × b2 + · · · + cn- 1 × bn (2)

易知，0 ≤ m < cn，最小值和最大值分别当 bi 全部为 0 和 bi = ai — 1 时取得。

试帮助小 P 同学，把测验的正确答案 b1 , b2 , · · · , bn 从顿顿老师留下的神秘整数 m 中恢复出来。

【输入格式】

从标准输入读入数据。

输入共两行。

第一行包含用空格分隔的两个整数 n 和 m，分别表示题目数量和顿顿老师的神秘 数字。

第二行包含用空格分隔的 n 个整数 a1 , a2 , · · · , an ，依次表示每道选择题的选项数 目。

【输出格式】

输出到标准输出。

输出仅一行，包含用空格分隔的 n 个整数 b1 , b2 , · · · , bn ，依次表示每道选择题的正 确选项。

【样例 1 输入】

1

2

15 32767

2 2 2 2 2 2 2 2 2 2 2 2 2 2 2

【样例 1 输出】

1

1

2

1

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

【样例 2 输入】

4 0

2 3 2 5

【样例 2 输出】

0 0 0 0

【样例 3 输入】

1

2

7 23333

3 5 20 10 4 3 10

【样例 3 输出】

1

2 2 15 7 3 1 0

【样例 3 解释】

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
| i   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ai  | 3   | 5   | 20  | 10  | 4   | 3   | 10  |
| bi  | 2   | 2   | 15  | 7   | 3   | 1   | 0   |
| ci- 1 | 1   | 3   | 15  | 300 | 3000 | 12000 | 36000 |

【子任务】

50% 的测试数据满足： ai 全部等于 2，即每道题均只有两个选项，此时 ci = 2i；

全部的测试数据满足：1 ≤ n ≤ 20 ，ai ≥ 2 且 cn ≤ 109（根据题目描述中的定义 cn 表示全部 ai 的乘积）。

【提示】

对任意的 1 ≤ j ≤ n，因为 cj+1, cj+2 , · · · 均为 cj 的倍数，所以 m 除以 cj 的余数具 有如下性质：

其中 % 表示取余运算。令 j 取不同的值，则有如下等式：

m % c1 = c0 × b1 (3)

m % c2 = c0 × b1 + c1 × b2 (4)

m % c3 = c0 × b1 + c1 × b2 + c2 × b3 (5)

· · · (6)

何以包邮？（promotion）

【题目描述】

新学期伊始，适逢顿顿书城有购书满 x 元包邮的活动，小 P 同学欣然前往准备买些 参考书。一番浏览后， 小 P 初步筛选出 n 本书加入购物车中， 其中第 i 本（1 ≤ i ≤ n） 的价格为 ai 元。考虑到预算有限， 在最终付款前小 P 决定再从购物车中删去几本书（也 可以不删），使得剩余图书的价格总和 m 在满足包邮条件（m ≥ x）的前提下最小。

试帮助小 P 计算，最终选购哪些书可以在凑够 x 元包邮的前提下花费最小？

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 n 和 x，分别表示购物车中图书数量和包 邮条件。

接下来输入 n 行，其中第 i 行（1 ≤ i ≤ n）仅包含一个正整数 ai ，表示购物车中 第 i 本书的价格。输入数据保证 n 本书的价格总和不小于 x。

【输出格式】

输出到标准输出。

仅输出一个正整数，表示在满足包邮条件下的最小花费。

【样例 1 输入】

1

2

3

4

5

4 100

20

90

60

60

【样例 1 输出】

1

110

【样例 1 解释】

购买前两本书（20 + 90）即可包邮且花费最小。

【样例 2 输入】

1

2

3

4

3 30

15

40

30

【样例 2 输出】

1

30

【样例 2 解释】

仅购买第三本书恰好可以满足包邮条件。

【样例 3 输入】

1

2

3

1

2 90

50

50

【样例 3 输出】

100

【样例 3 解释】

必须全部购买才能包邮。

【子任务】

70% 的测试数据满足： n ≤ 15；

全部的测试数据满足： n ≤ 30，每本书的价格 ai ≤ 104 且 x ≤ a1 + a2 + · · · + an。

【提示】

对于 70% 的测试数据，直接枚举所有可能的情况即可。

防疫大数据（healthcode）

【题目背景】

近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾 弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要 功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。 具体而言，在每天夜里， 西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地 区的信息， 以及当天疫情风险地区的信息。数据中心需要根据这些信息， 生成一份存在 风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。

【题目描述】

为了简化和便于处理问题，我们用连续的整数来表示日期，例如 -1 、0 、1 、2 就是 连续的 4 个日期。每日收到的漫游数据分为若干条， 每条表示某一个用户在某日到访过 某地区，记为：⟨d, u, r〉，其中，u 表示用户，r 表示地区，它们都是一个正整数；d 表示 日期，是一个整数。每日收到的漫游数据中， 可能会有这样的数据， 需要在处理的过程 中考虑：

• 延迟数据： 即在某日收到的漫游数据中， 日期小于当日的日期。例如， 在 2 日收 到的某条漫游数据，内容是某用户在 1 日到访过某地区；

• 重复数据：即在某日收到的漫游数据中，可能存在两条完全相同的数据；

• 多地访问数据：即在某日收到的漫游数据中， 存在两条数据，其日期和用户相同， 但地区不同。

每日收到的疫情风险地区的信息， 是一个列表，列表中的每个元素表示某个地区在 某日被列为疫情风险地区。收到该消息的当日起 7 日内，该地区处于风险状态。即对于 地区 r，我们称 r 在 d 日处于风险状态，当且仅当存在一个日期 d0 ∈ (d - 7, d\]，在 d0 日收到地区 r 的风险信息。例如， 在 1 日收到地区 1 的风险信息，表示自 1 日（包含） 至 8 日（不包含）地区 1 处于风险状态。如果分别在 1 日和 6 日收到地区 1 的风险信 息，那么意味着地区 1 自 1 日（包含）至 13 日（不包含）持续处于风险状态。

每日生成的存在风险的手机用户的名单， 是一个列表，列表中的每个元素表示某个 用户被认为存在疫情风险。我们认为， 同时满足下列条件的用户， 会被列入当日生成的 风险名单：

• 该用户在近 7 日内曾经出现在接收到的漫游数据中，并且近 7 日内有到访某个 地区的记录；

• 该用户在近 7 日内到访的地区在到访的那一日处于风险状态；

• 上述存在风险的地区自到访日至生成名单当日持续处于风险状态。

形式化地，在 d 日生成的风险名单中，用户 u 被列入风险名单，当且仅当：

存在一个日期 d0 ∈ (d - 7, d\]，存在一条 d0 日收到的漫游数据 ⟨d1 , u, r〉，使得

• d1 ∈ (d - 7, d\]，并且

• 对于任意的 D ∈ \[d1 , d\]，地区 r 在 D 日处于风险状态。

例如，在第 0 日收到下列漫游数据：

⟨0, 1, 1〉； ⟨-1, 1, 1〉； ⟨-1, 2, 1〉； ⟨0, 2, 2〉

又在第 0 日收到了 1 号地区为风险地区的消息， 那么此后第 0 日（包含）至第 7 日 （不包含）， 1 号地区都处于风险状态。

在第 0 日生成的风险名单中，用户 1 被列入风险名单， 因为用户 1 在第 0 日到访 了 1 号地区。用户 2 不被列入风险名单， 因为用户 2 在第 0 日到访了 2 号地区，但是 在第 0 日 2 号地区不是风险地区； 虽然用户 2 在第 -1 日到访了 1 号地区，但是在第 -1 日 1 号地区不是风险地区。

假设在第 1 日，又收到下列漫游数据：

⟨0, 3, 1〉； ⟨1, 2, 2〉； ⟨1, 3, 2〉

同时没有收到新的风险地区的消息， 那么在第 1 日生成的风险名单中，用户 1 和 3 被列入风险名单， 因为刚收到的信息显示用户 3 在第 0 日到访了 1 号地区，而用户 1 在第 0 日到访了 1 号地区，且在第 1 日 1 号地区仍处于风险状态，虽然第 1 日没有收 到用户 1 的漫游数据，但是仍然将用户 1 列入风险名单。

假设后续没有收到更多漫游数据和风险地区信息， 直到第七日，收到下列漫游数据： ⟨5, 4, 1〉

同时没有收到新的风险地区的消息， 此时，没有用户被列入风险名单。例如对于用 户 4，虽然在第 5 日到访了 1 号地区，但是生成风险名单的当日，1 号地区已经不是风 险地区。

假设在第 8 日，没有收到更多的漫游数据，但是收到了 1 号地区为风险地区的消 息，那么在第 8 日生成的风险名单中，也没有用户被列入风险名单。因为在第 7 日，地 区 1 不处于风险状态， 用户 4 在第 5 日到访了 1 号地区，虽然第 5 日和本日（第 8 日） 地区 1 处于风险状态，但是，由于不满足持续处于风险状态的条件， 用户 4 不被列入风 险名单。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 n，表示总共输入数据的天数。

接下来是 n 组数据，依次表示自第 0 日开始每一天的输入数据。

对于第 i 日的一组数据，其第一行内，包含空格分隔的两个非负整数 ri 、mi ，以及 ri 个正整数 pi;j （i = 0, 1, . . . , (n - 1), j = 1, 2, ..., ri），分别表示当日收到的风险地区信 息的数量、当日收到的漫游数据的条目数量，以及当日收到的风险地区的列表。

每组数据接下来有 mi 行，每行包含空格分隔的一个整数和两个正整数 di;j 、ui;j 、 ri;j （j = 1, 2, . . . , mi），分别表示一条漫游数据中的日期、用户和地区。

【输出格式】

输出到标准输出。

输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格 分隔的若干整数。其中第一个整数表示当天的日期， 接下来的各个整数为按从小到大排 序的存在风险的用户列表。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

|     |     |     |
| --- | --- | --- |
| 9<br><br>1 4 1<br><br>0 1 1<br><br>\-1 1 1<br><br>\-1 2 1 |     |     |
| 0<br><br>0<br><br>0<br><br>1<br><br>1<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>5<br><br>1 | 2<br><br>3<br><br>3<br><br>2<br><br>3<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>1<br><br>4<br><br>0 | 2<br><br>1<br><br>2<br><br>2<br><br>1<br><br>1 |

【样例 1 输出】

1

2

3

4

5

6

7

8

0 1

1 1 3

2 1 3

3 1 3

4 1 3

5 1 3

6 1 3

7

9

8

【样例 1 解释】

本样例数据即为题目描述中所叙述的情况。

【子任务】

对于前 20% 的数据，有 ri = mi = 0, (i = 1, 2, . . . (n - 1))；

对于前 40% 的数据，有 ri = 0, (i = 1, 2, . . . (n - 1))；

对于前 70% 的数据，对所有的 i 与 j，都有 pi;j ≤ 400 ，ui;j ≤ 400，且 ri;j ≤ 400； 并且对所有的 i，都有 ri ≤ 300，且 mi ≤ 300；

对于 100% 的数据，对所有的 i 与 j，都有 1 ≤ pi;j ≤ 109，1 ≤ ui;j ≤ 109，1 ≤ ri;j ≤ 109， 且 -105 ≤ di;j ≤ i；对所有的 i ∈ \[0, n)，都有 0 ≤ ri ≤ 1000，且 0 ≤ mi ≤ 1000；并且 0 ≤ n ≤ 1000；对所有的 i ∈ \[0, n)，和任意的 j1 , j2 ∈ \[1, ri \], j1  j2 ，都有 pi;j1  pi;j2 。

吉祥物投票（vote）

【题目描述】

为了促进西西艾弗岛上的旅游业发展， 当地决定设计一个吉祥物形象。活动吸引了 众多设计领域的大师和爱好者参加， 经过初步筛选，共选出了 m 个作品，编号为 1 ~m， 进行最终的投票角逐。

活动还吸引了西西艾弗岛上的 n 名投票者参与， 编号为 1 ~n，每人都在最终的投 票环节拥有投一票的权利， 也可以放弃投票。我们定义每个人的投票意愿 ai (1 ≤ i ≤ n) 为一个 0 ~m 的整数，若 ai = 0 表示这个人目前没有支持的作品，打算放弃投票，否 则表示这个人支持第 ai 号作品并有意愿将票投给它。

最初，由于所有人对参与竞选的作品都不了解， 因此投票意愿 ai 均为 0。接下来是 紧张刺激的拉票环节， 作品的设计者们要想方设法给自己的作品拉票， 这一过程中可能 出现如下若干种事件：

1 l r x：编号为 x 的作品开展了一场拉票活动，成功地吸引了编号为 l ~r 的投 票者的兴趣，使得他们的投票意愿全部改为 x。

2 x w：编号为 x 的作品需要经历一次大规模修改， 所以需要暂时退出竞选。由于 x 与 w 两个作品的风格较为相近， 因此原先投票意愿为 x 的投票者的投票意愿变为了 w。特别地， 若 w = 0，表示这些投票者暂时找不到新的支持的作品。需要注意的是， 作 品 x 退出竞选只是暂时的，因此后续的事件中作品 x 仍可能出现。

3 x y：主办方发现自己的统计出现了失误， 将编号为 x 和 y 的作品弄颠倒了。发 布勘误后，所有原先投票意愿为 x 的投票者的投票意愿变为了 y，所有原先投票意愿为 y 的投票者的投票意愿变为了 x。

4 w：主办方决定进行一次调查：希望知道所有投票者中， 当前投票意愿为 w 的有 多少人。若 w  0 ，相当于调查有多少投票者目前支持作品 w ，否则相当于调查有多 少投票者目前没有支持的作品。

5：主办方决定进行一次调查：若以现在的投票意愿进行最终的投票， 获胜的作品是 哪一个。规定得票数至少为 1 且最多的作品获胜，得票数相同则编号较小的作品获胜。 特别地，若所有作品均无得票，认为不存在获胜作品。

从拉票开始到结束， 共出现了 q 次如上的事件。由于参选的作品数和投票人数实在 太多，单凭活动主办方的能力难以全面统计，现在请你编写一个程序来处理这些事件， 并求出每次调查的结果。

【输入格式】

从标准输入读入数据。

第 1 行，3 个正整数 n, m, q。

接下来 q 行，每行 1 ~ 4 个非负整数，描述一个事件。

【输出格式】

输出到标准输出。

对于每个 4 或 5 事件输出一行，一个非负整数表示此次调查的结果。其中事件 5 若 不存在获胜作品则输出0。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

10 2 15

5

1 2 4 1

1 4 7 2

4 1

5

1 3 4 1

5

1 7 9 1

3 1 2

4 2

2 1 2

4 2

2 2 0

4 2

5

【样例 1 输出】

1

2

3

4

5

6

7

8

0

2

2

1

6

8

0

0

【数据范围】

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 测试点编号 | n ≤ | m ≤ | q ≤ | 特殊性质 |
| 1 ~ 4 | 10000 | 2000 | 2000 | 无   |
| 5 ~ 7 | 109 |
| 8 ~ 9 | 2 × 105 | 1   | 105 |
| 10 ~ 11 | 105 | r − l ≤ 10，只有事件 1, 4, 5 |
| 12 ~ 14 | r − l ≤ 10 |
| 15 ~ 17 | 无   |
| 18 ~ 20 | 109 |

对于所有的数据， 满足 1 ≤ n ≤ 109 ，1 ≤ m, q ≤ 105 ，1 ≤ l ≤ r ≤ n ，1 ≤ x, y ≤ m， 0 ≤ w ≤ m。保证事件 2 中 x  w，事件 3 中 x  y。

高维亚空间超频物质变压缩技术（zipex）

【题目描述】

西西艾弗岛上有 n 块黄金，人们希望把这些黄金打包运出去， 于是他们给这些黄金 依次编号为 1, 2, . . . , n，第 i 块黄金的体积为 vi。

由于现在是 2202 年，人们掌握高维亚空间超频物质变压缩技术。具体来说，人们 需要将这些黄金按编号划分为若干段， 使得每段内的黄金编号连续， 并且每块黄金属于 恰好一段。这种变压缩技术可以将每一段黄金的体积变为一个常数 L，成本是 (s — L)2， 其中 s 为这一段的黄金的体积之和。注意， 并不要求必须有 s ≤ L 或者 s > L 。一种划 分方案的成本是每一段的成本之和。

但由于人们发明变压缩技术时受到了来自虚境神秘伟大存在的莫名低语的影响， 第 i 块黄金被赋予了一个神秘学质量 mi，而变压缩技术要求每段内编号最大的黄金的神秘 学质量严格递增。也就是说， 假定顺次划分了 k 段，每段内编号最大的黄金的神秘学质

量依次是 m , ..., m，那么必须满足 m < · · · < m。

现在西西艾弗岛上的人们想知道，在满足上述条件的前提下，最小的成本是多少？ 注意到总是可以把所有的黄金都压成一段，因此满足上述条件的划分一定存在。

形式化地，给定 n ∈ N+ , L ∈ N, {vi  , {mi  N，求：

min {Fn ({bi  其中：

An ({mi i  In ({mi  **I**∀j ∈ \[1, bn ), ∆Mn ({mi i 

Fn ({bi i  ∑ ∑ δ(bi — j) · vi )2

其中， δ : R → {0, 1} 为单位元函数，即：

另外，有：

In ({mi 

以及 ∀{bi  In ({mi  , j ∈ \[1, bn )，有：

∆Mn ({mi i  mmax{i∈\[1,n\]|bi =j+1} — mmax{i∈\[1,n\]|bi =j}

容易验证：

∀{bi 

因此 丫{bi  I ({mi  , j ∈ \[1, bn \]，mmax{i∈\[1,n\]|bi =j} 是良定义的，从而 丫{bi 

In ({mi  , j ∈ \[1, bn ) ，∆Mn ({mi i  是良定义的。

此外，易见 丫{mi  C N，总有 {1, 1, ..., 1} ∈ An ({mi n ({mi   ϕ , 因此 (\*) 式也是良定义的。

（注：如果你看不懂以上形式化定义也无妨，直接阅读上面的文字叙述题意即可。）

【输入格式】

从标准输入读入数据。

第一行两个正整数 n, L；

接下来一行 n 个正整数表示 v1 , ..., vn；

接下来一行 n 个正整数表示 m1 , ..., mn。

【输出格式】

输出到标准输出。

一行一个整数表示答案。

【样例 1 输入】

1

2

3

1

3 2

2 1 1

1 2 2

【样例 1 输出】

0

【样例 1 解释】

把第 1 块黄金划为一段，第 2 ~ 3 块黄金划为一段。由于 m1 = 1 < m3 = 2，这么 划分是符合要求的；又因为每一段黄金的体积之和都等于 2 ，因此无需代价。

另一种划分方案是把第 1 ~ 3 块黄金划为一段，但这样需要 4 的代价；除此之外其 余的划分方案都是不符合要求的。

形式化地，记 v = {vi  = {mi 。

可以验证：

In (m) = {b1 = {1, 1, 1}, b2 = {1, 1, 2}, b3 = {1, 2, 2}, b4 = {1, 2, 3}}

An (m) = {b1 , b3 }

b2 ∈/ An (m) 是由于，令 j = 1 ∈ \[1, 2)，则 j + 1 = 2 ∈ \[1, 2\] ，Mn (m; b2 ; j + 1) = m3 = 2, Mn (m; b2 ; j) = m2 = 2，而 2 > 2 不成立。b4 ∈/ An (m) 是类似的，请自行验证。

又由于：

Fn (b1 ; v; 2) = (2 — (1 · v1 + 1 · v2 + 1 · v3 ))2 = 4

Fn (b3 ; v; 2) = (2 — (1 · v1 + 0 · v2 + 0 · v3 ))2 + (2 — (0 · v1 + 1 · v2 + 1 · v3 ))2 = 0 因此答案是 0。

【数据范围】

|     |     |     |     |
| --- | --- | --- | --- |
| 子任务编号 | n   | ∀i ∈ \[1, n\], mi = i | 子任务分值 |
| 1   | 18  | 否   | 10  |
| 2   | 2,000 | 30  |
| 3   | 105 | 是   |
| 4   | 否   |

对于所有数据： 1 ≤ n ≤ 105 , 1 ≤ vi ≤ 104 , 1 ≤ mi ≤ n, 1 ≤ L ≤ 109 , (1 ≤ i ≤ n)

【提示】

请注意答案可能的取值范围。

**CCF CSP** 计算机软件能力认证

CCF CSP

第 26 次

时间：2022 年 6 月 12 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 归一化处理 | 寻宝！大冒 险！ | 角色授权 | 光线追踪 | PS 无限版 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 0.5 秒 | 0.5 秒 | 5.0 秒 | 2.0 秒 | 10.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 2048 MiB |
| 子任务数目 | 10  | 10  | 10  | 20  | 7   |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 否   |

归一化处理（batchnorm）

【题目背景】

在机器学习中， 对数据进行归一化处理是一种常用的技术。将数据从各种各样分布 调整为平均值为 0、方差为 1 的标准分布，在很多情况下都可以有效地加速模型的训练。

【题目描述】

这里假定需要处理的数据为 这组数据的平均值：

方差：

n 个整数 a1 , a2 , · · · , an。

使用如下函数处理所有数据，得到的 n 个浮点数 f(a1 ), f(a2 ), · · · , f(an ) 即满足平 均值为 0 且方差为 1：

【输入格式】

从标准输入读入数据。

第一行包含一个整数 n，表示待处理的整数个数。

第二行包含空格分隔的 n 个整数，依次表示 a1 , a2 , · · · , an。

【输出格式】

输出到标准输出。

输出共 n 行，每行一个浮点数，依次表示按上述方法归一化处理后的数据 f(a1 ), f(a2 ), · · · , f(an )。

【样例输入】

1

2

7

\-4 293 0 -22 12 654 1000

【样例输出】

1

2

3

4

5

6

7

\-0.7485510379073613 0.04504284674812264 -0.7378629047806881 -0.7966476369773906 -0.7057985054006686

1.0096468614303775 1.9341703768876082

【样例解释】

平均值：  ≈ 276.14285714285717

方差：D(a) ≈ 140060.69387755104

标准差： √D(a) ≈ 374.24683549437134

【子任务】

全部的测试数据保证 n, |ai | ≤ 1000，其中 |ai | 表示 ai 的绝对值。

且输入的 n 个整数 a1 , a2 , · · · , an 满足：方差 D(a) ≥ 1。

【评分方式】

如果你输出的每个浮点数与参考结果相比， 均满足绝对误差不大于 10-4，则该测试 点满分，否则不得分。

【提示】

• C/C++：建议使用 double 类型存储浮点数，并使用 printf("%f", x); 进行 输出。

• Python：直接使用 print(x) 进行输出即可。

• Java：建议使用 double 类型存储浮点数，可以使用 System.out.print(x); 进 行输出。

寻宝！大冒险！（adventure）

【题目背景】

暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留 在西西艾弗岛上度过一个略显单调的假期 …… 直到 ……

某天，小 P 获得了一张神秘的藏宝图。

【题目描述】

西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。简单地说， 西 西艾弗岛绿化图可以视作一个大小为 (L + 1) × (L + 1) 的 01 矩阵 A，地图左下角（坐 标 (0, 0)）和右上角（坐标 (L, L)）分别对应 A\[0\]\[0\] 和 A\[L\]\[L\]。其中 A\[i\]\[j\] = 1 表示坐 标 (i, j) 处种有一棵树，A\[i\]\[j\] = 0 则表示坐标 (i, j) 处没有树。换言之， 矩阵 A 中有且 仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。

传说，大冒险家顿顿的宝藏就埋藏在某棵树下。并且， 顿顿还从西西艾弗岛的绿化 图上剪下了一小块，制作成藏宝图指示其位置。具体来说， 藏宝图可以看作一个大小为 (S + 1) × (S + 1) 的 01 矩阵 B（S 远小于 L）， 对应着 A 中的某一部分。理论上，绿 化图 A 中存在着一处坐标 (x, y)（0 ≤ x, y ≤ L — S）与藏宝图 B 左下角 (0, 0) 相对应， 即满足：对 B 上任意一处坐标 (i, j)（0 ≤ i, j ≤ S），都有 A\[x + i\]\[y + j\] = B\[i\]\[j\]。当 上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x, y)、右上角为 (x + S, y + S) 的区域。

实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x, y) 很可 能存在多个。请结合西西艾弗岛绿化图中 n 棵树的位置， 以及小 P 手中的藏宝图，判 断绿化图中有多少处坐标满足条件。

特别地，藏宝图左下角位置一定是一棵树，即 A\[x\]\[y\] = B\[0\]\[0\] = 1，表示了宝藏埋 藏的位置。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的三个正整数 n 、L 和 S，分别表示西西艾弗岛上树的 棵数、绿化图和藏宝图的大小。

由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图； 即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标， 满足 0 ≤ x, y ≤ L 且同 一坐标不会重复出现。

最后 (S + 1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0 ≤ i ≤ S）包含空格 分隔的 (S + 1) 个 0 和 1，表示 B\[S — i\]\[0\] · · · B\[S — i\]\[S\] 。需要注意，最先输入的是 B\[S\]\[0\] · · · B\[S\]\[S\] 一行，B\[0\]\[0\] · · · B\[0\]\[S\] 一行最后输入。

【输出格式】

输出到标准输出。

输出一个整数，表示绿化图中有多少处坐标可以与藏宝图左下角对应， 即可能埋藏 着顿顿的宝藏。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

5 100 2

0 0

1 1

2 2

3 3

4 4

0 0 1

0 1 0

1 0 0

【样例 1 输出】

1

3

【样例 1 解释】

绿化图上 (0, 0) 、(1, 1) 和 (2, 2) 三处均可能埋有宝藏。

【样例 2 输入】

1

2

3

4

5

6

7

8

9

5 4 2

0 0

1 1

2 2

3 3

4 4

0 0 0

0 1 0

1 0 0

【样例 2 输出】

1

0

【样例 2 解释】

如果将藏宝图左下角与绿化图 (3, 3) 处对应，则藏宝图右上角会超出绿化图边界， 对应不成功。

【子任务】

40% 的测试数据满足： L ≤ 50；

70% 的测试数据满足： L ≤ 2000；

全部的测试数据满足： n ≤ 1000 、L ≤ 109 且 S ≤ 50。

【提示】

实际测试数据中不包括答案为 0 的用例。

角色授权（rabc）

【题目背景】

为了响应国家发展新基建的倡议， 西西艾弗岛上兴建了西西艾弗数据中心， 并以此 为基础运营了西西艾弗云。作为数据中心的运营和维护方， 西西艾弗云公司十分重视西 西艾弗云的网络安全管理工作。众所周知， 安全性和便捷性难以兼得， 同时，一个混乱 的权限模型可能会导致人员被授予不必要的权限， 从而造成安全风险。因此在西西艾弗 云公司的网络安全部工作的小 C 专门设计了一种科学的权限模型。

这种安全模型将验证流程分为两个步骤。第一步是验证用户的身份（鉴别）， 第二 步是验证用户的权限（授权）。在第一步，首先验证一个用户是否是该用户所声称的那 个身份。例如， 通过验证用户提供的口令（Password）是否正确，或者通过验证用户提 供的智能卡是否合法有效。接下来， 在授权的步骤中， 权限策略会被检索以便判断来访 的用户是否能够操作系统中的某个资源。

为了能够灵活地表达用户和授权之间的关系， 西西艾弗云公司设计了一种简洁而灵 活的授权模型： 基于角色的授权模型。它的思路是： 首先设定若干角色， 每个角色中指 明了一个清单，表明允许访问的资源的种类、资源的名称和对资源的操作； 然后将被前 一步骤已经鉴别过的用户和一个或多个角色相关联。某个用户能够执行的操作， 即为与 其关联的全部角色中允许的操作的并集。

小 C 将实现授权模型的工作交给了你，希望你能够把它们实现出来。

【题目描述】

用户表示授权模型中的一个已识别的主体， 该识别过程由此前的鉴别过程完成。 一

. .

个用户具有下列要素：

• 名称：是一个字符串，用于唯一标识一个用户；

• 用户组：是一个数组，包含若干个字符串，表示该用户所属的用户组。

一个待授权的行为，包括下列要素：

• 主体：是一个用户，包括试图进行该行为的用户的名称和该用户所属的用户组；

• 操作：是一个字符串， 一般是一个动词，例如 Read、Open、Close 等；

• 资源：表示该行为的操作对象， 由资源种类和资源名称描述。资源种类例如 Door、 File 等；在一个特定的资源种类中，资源名称唯一确定了一个资源。

需要注意的是， 一个待授权的行为的主体信息， 即用户名称和所属用户组， 是由前 一步骤的鉴别过程完成的。因此， 每次授权过程中， 每个待授权的行为都会包含主体用 户和其关联的用户组的信息。由于鉴权过程中的其它因素， 同一个名称的用户在先后两 次待授权的行为中所属的用户组可能有区别，不能存储或记忆此前每个待授权的行为 中，用户与用户组的关联情况，而是要按照每次待授权的行为中给出的信息独立判断。

角色是这种授权模型的基本单位， 它指明了一个用户可以执行的操作， 角色的清单

. .

中描述了角色所允许的操作。 一个角色包含下列要素：

• 名称，是一个字符串，用于唯一标识一个角色；

• 操作清单，是一个数组，包含一个或多个操作，表示该角色允许执行的操作集合；

• 资源种类清单， 是一个数组，包含一个或多个资源种类， 表示该角色允许操作的 资源的种类集合；

• 资源名称清单， 是一个数组，包含若干个资源名称， 表示该角色允许操作的资源 的名称集合。

判断一个角色能否对某个资源执行某个操作的过程是：

1\. 检查该角色的操作清单， 如果该角色的操作清单中不包含该操作， 且该角色的操 作清单中也不包含字符串 \*，那么不能执行该操作；

2\. 检查该角色的资源种类清单，如果该角色的资源种类清单中不包含该资源的种 类，且该角色的资源种类清单中也不包含字符串 \*，那么不能执行该操作；

3\. 检查该角色的资源名称清单，如果该角色的资源名称清单中不包含该资源的名 称，且该角色的资源名称清单不是空数组，那么不能执行该操作；

4\. 允许执行该操作。

例如，假设有某个角色 Doorman，其允许执行的操作有 Open 和 Close，其允许操 作的资源类型有 Door，其允许操作的资源名称有 FrontDoor 和 BackDoor。如果某用 户与这个角色关联， 那么该用户可以对名为 FrontDoor 的 Door 执行 Open 操作，但是 不能对 BackDoor 的 Door 执行 Delete 操作。同时，一个角色能允许进行的操作可以 用通配符来表示。例如， 另有一个角色 Admin，其允许执行的操作有 \*，允许操作的资 源类型是 \*，其允许操作的资源名称列表为空，那么与该角色关联的所有用户可以执行 任何操作。值得注意的是， 一个角色的操作清单， 只能用允许列表的方式列举该角色允 许进行的操作，而不能禁止角色进行某个操作。

角色关联指明了一个用户和一个或多个角色之间的关系。 一个角色关联包含下列要

. . . .

素：

• 角色名称，是一个字符串，用于指明一个角色；

• 授权对象清单， 是一个数组，包含一个或多个用户名称或者用户组名称， 表示该 角色关联的用户和用户组的集合。

判断一个用户能否执行某个操作的过程是：

1\. 检查所有的角色关联的授权对象清单， 如果清单中包含该用户的名称， 或者该清 单中包含该用户所属的某一个用户组的名称，那么选取该角色关联所关联的角 色；

2\. 对于所有被选取的角色， 判断这些角色是否能对该资源执行该操作， 如果所有角 色都不能执行该操作，那么不能执行该操作；

3\. 允许执行该操作。

由此可见，一个角色关联可以将一个角色与多个用户或用户组关联起来。例如， 如 果有一个角色关联，其关联的角色名称为 Doorman，其关联的用户和用户组清单为用户 foo1、用户 foo2、用户组 bar。那么这些用户会与 Doorman 角色关联：

• 名为 foo1 的用户，属于用户组 bar；

• 名为 foo2 的用户，属于用户组 barz；

• 名为 foo3 的用户，属于用户组 bar 和 barz。

但是，属于用户组 barz 的名为 foo4 的用户不能与 Doorman 的角色关联。

从上述判断规则可以知道， 一个用户可能与多个角色相关联， 在这种情况下， 该用 户允许进行的操作是这些角色被允许进行的操作集合的并集。

. .

【输入格式】

从标准输入读入数据。

输入的第一行包含三个正整数 n 、m 、q，分别表示角色数量、角色关联数量和待检 查的操作数量。

输入接下来的 n 行中，每行表示一个角色，包括空格分隔的若干元素，依次为：

• 一个字符串，表示该角色的名称；

• 一个正整数 nv，表示操作清单中包含的操作数量；

• nv 个字符串，依次表示操作清单中的操作；

• 一个正整数 no，表示资源种类清单中包含的资源种类的数量；

• no 个字符串，依次表示资源种类清单中的资源种类；

• 一个非负整数 nn，表示资源名称清单中包含的资源名称的数量；

• nn 个字符串，依次表示资源名称清单中的资源名称。

输入接下来的 m 行中，每行表示一个角色关联，包括空格分隔的若干元素，依次 为：

• 一个字符串，表示该角色关联的角色名称；

• 一个正整数 ns，表示授权对象清单中包含的授权对象的数量；

• 2ns 个字符串，每两个表示授权对象清单中的授权对象， 前一个字符串为 u 或 g， 分别表示这个授权对象是一个用户名称或者用户组名称， 后一个字符串为用户名 称或者用户组名称。

输入接下来的 q 行中，每行表示一个待授权的行为， 包括空格分隔的若干元素， 依 次为：

• 一个字符串，表示执行该操作的用户名称；

• 一个正整数 ng，表示该用户所属的用户组的数量；

• ng 个字符串，依次表示该用户所属的用户组的名称；

• 一个字符串，表示待查操作的名称；

• 一个字符串，表示被操作的资源种类；

• 一个字符串，表示被操作的资源名称。

【输出格式】

输出到标准输出。

输出 q 行，每行表示一个操作是否可以被执行， 0 表示不能执行， 1 表示可以执行。

【样例输入】

1

2

3

4

5

6

7

1 2 3

op 1 open 1 door 0

op 1 g sre

op 1 u xiaop

xiaoc 2 sre ops open door room302

xiaop 1 ops open door room501

xiaoc 2 sre ops remove door room302

【样例输出】

1

2

3

1

1

0

【样例解释】

在本例中，定义了一个名为 op 的角色，授予了对任意 door 类型的对象的 open 操作的权限， 同时定义了两个指向 op 的角色关联。注意，可以针对一个角色定义多于 一个角色关联。本例给出了三个待授权的行为。其中， 第一个行为，授权的主体用户是 xiaoc，该用户所属的用户组 sre 被关联 op 角色， 因此可以执行开门动作。第二个行 为中，授权的主体用户是 xiaop，该用户被直接关联了 op 角色， 因此也可以执行开门 动作。第三个行为中，授权的主体用户仍是 xiaoc，关联的角色仍为 op。但是， 由于 op 角色并未被授予 remove 操作的权限，因此该动作被拒绝。

【子任务】

对于 20% 的数据，有 n = m = 1，且给出的角色类似于题目正文中用于举例的 Admin，允许执行任何操作，且 nv = no = ns = ng = 1 、nn = 0。

对于 40% 的数据，有 1 ≤ n, m ≤ 50，且 nv = no = ns = 1 、ng ≤ 40 、nn = 0。

对于 70% 的数据，有 1 ≤ n, m ≤ 50，且 nv, no, ns, ng ≤ 40 、nn ≤ 400。

对于 100% 的数据，有：

• 1 ≤ n, m ≤ 500；

• 1 ≤ q ≤ 5000；

• 1 ≤ nv, no, ns, ng ≤ 400；

• 0 ≤ nn ≤ 400；

• 全部字符串或为 \*，或仅包含大写字母、小写字母、数字（A-Za-z0-9），且字符 数目不超过 10。

光线追踪（light）

【题目描述】

光线追踪是计算机图形学领域的一个重要算法，其原理是追踪一束从光源发出的 光，经过不同的反射面，最终到达摄像机处的过程。

在这道问题中，你需要实现一段程序来处理一个简易的光线追踪模型。

在平面中有一些反射面，为方便起见，我们设这些反射面都是线段， 与坐标轴成 45 度角摆放，且两个端点的坐标均为整数。为进一步简化问题， 我们假设所有的反射表面

. .

都是镜面反射。任何一束光线照射到反射面上（为避免讨论，假设反射面不含端点）时，

. . . . . . . .

都会改变方向为相应的镜面反射方向。注意，反射面的两侧都可以反射光线。

平面中还有一些激光光源， 每个光源位于一个坐标为整数的点上，会向某个水平或

. . . . .

竖直的方向发射一定强度的激光。

. .

所有的反射面都不是完美的， 每个反射面有一个折损系数 a ，当强度为 I 的光线照 射上去时，反射光线的强度会变成 aI 。为了便于处理，你可以认为所有反射面的材质 均不算太好也不算太糟，因此所有的 a 均在 0.2 ~ 0.8 的范围内。

在一些超高速摄影问题中， 有时甚至连光速都要考虑在内。在这个问题中， 我们不 妨假设激光在 1 单位时间内恰好移动 1 单位距离。然而， 超高速摄影带来的往往是采样 精度的损失， 因此对于一束激光，最终采样到的光线强度都是向下取整后的数值。特别

. . . .

地，当一束激光的强度小于 1 时，认为其已经完全耗散。

问题的最开始，平面上没有反射面也没有光源。接下来你需要处理若干个操作， 每 个操作形如：

1 x1 y1 x2 y2 a：在平面上插入一个分别以 (x1, y1) 和 (x2, y2) 为端点，反射系 数为 a 的反射面，保证反射面与坐标轴成 45 度角摆放，且不与先前已经存在、且还没 有被删除的反射面在非端点处相交； 另外受到渲染效率的影响， 问题中的所有反射面的 总长度（可以理解为所有的 |x1 — x2| 之和）不会太大。

2 k：删除第 k 个操作插入的反射面， 保证第 k 个操作发生在当前操作之前且为一 个插入操作，且这个反射面还没有被删除；

3 x y d I t：在 (x, y) 位置放置一个光源，发射光线的方向为 d ，强度为 I ，求 其所经 t 时刻后光线到达的坐标以及采样得到的光线强度。其中 d 的含义为：d = 0 表 示沿 x 坐标增加的方向，d = 1 表示沿 y 坐标增加的方向，d = 2 表示沿 x 坐标减小的 方向，d = 3 表示沿 y 坐标减小的方向。另外，保证光源不位于当前存在的某个反射面 （不含端点）上。注意： 如果 t 时刻后光线刚好到达某个反射面， 则其强度取反射后的强 度。

【输入格式】

从标准输入读入数据。

第 1 行，一个正整数 m 表示操作的总数量。

接下来 m 行，每行描述一个操作，格式如题目描述。

其中，除了所有的 a 和 I 以外的输入均为绝对值不超过 109 的整数，其中 k 和 t 为 正整数；a 和 I 均为小数点后不超过 6 位的正实数，其中 a 在 0.2 ~ 0.8 之间，I ≤ 109。

【输出格式】

输出到标准输出。

对于每个查询操作输出一行，3 个整数，形如 x y I 表示激光最终到达的位置为 (x, y) ，采样得到的光线强度为 I 。特别地，如果采样到的光线强度为 0 （即光线已耗 散），你也就无需关心最终到达的坐标，而只需要输出0 0 0即可。

题目数据保证，你可以在计算时直接使用 64 位浮点数的运算和取整操作，而无需 担心可能的精度误差问题。

【样例 1 输入】

1

2

3

4

5

6

7

8

1

2

3

4

7

1 0 4 2 2 0.4

1 2 2 0 0 0.45

3 -1 3 0 6 5

3 1 5 3 2.4 5

3 0 2 0 3 4

2 1

3 1 5 3 2.4 5

【样例 1 输出】

0 1 1

0 0 0

4 2 3

0 1 1

【数据范围】

|     |     |     |
| --- | --- | --- |
| 测试点编号 | m ≤ | 特殊性质 |
| 1 ~ 3 | 1000 | 所有光线的 t ≤ 1000 ，所有输入坐标的绝对值 ≤ 1000 |
| 4 ~ 7 | 无   |
| 8 ~ 10 | 105 | 所有光线的 t ≤ 10 |
| 11 ~ 13 | 所有 1 操作在所有 3 操作之前，且无 2 操作 |
| 14 ~ 16 | 所有光线的 I = 1 |
| 17 ~ 20 | 无   |

对于 100% 的数据，保证 m ≤ 105 ，所有反射面的 |x1 — x2| 之和不超过 3 \* 105 。

PS 无限版（PSI）

【题目背景】

众所周知， PS 是一款图片编辑软件，编辑图片的本质是操作各像素。

但是，传统的图片编辑只能对有限个像素进行操作， 而这对于一名数学系学生是不 可忍受的——竟然不能把有限的、离散的问题推广到无穷的、连续的问题， 这真是不可 忍受。

正如在线性代数的理论我们为了将有限维线性空间推广到无穷维线性空间所做的 那样，现在我们可以假定一张图片是一个无穷大的二维平面（方便起见， 我们假定它是 一个平面直角坐标系），其上的每个像素可以用 (a, b) 表示（注意，a, b 是实数）。类似于 线性代数无穷维线性空间关于基的讨论， 我们实际上不关心所有的像素， 而只关注于其 中的有限个像素，通过对每一组有限大小的像素集的刻画来描述图片整体的编辑情况。

当然，尽管在原理上成功的把 PS 升级成了 PSI(PS Infinite)，但就结论而言， 我们 应当讨论传统 PS 中的各种操作在 PSI 上的推广和实现。出于简单起见， 我们只考虑平 移、旋转、放缩、对称和投影这些基本的编辑操作。

【题目描述】

给定正整数 n 平面上一些点 {(xi , yi  ⊂ ℜ2 ，支持以下操作：

1\. 1 l r a b：将编号在 \[l, r\] 中的点平移 ⃗v = (a, b)。

• 即沿 ⃗v 方向平移 |⃗v| 的距离。

2\. 2 l r a b θ：将编号在 \[l, r\] 中的点以 (a, b) 为中心逆时针旋转 θ

• 保证 θ ∈ (−π, π)，以弧度制给出。

3\. 3 l r a b λ：将编号在 \[l, r\] 中的点以 (a, b) 为中心放缩 |λ| 倍

• 即在指向 (a, b) 的方向所在直线上移动，距离缩小 (|λ| &lt; 1) 或变大 (|λ| &gt; 1)。

• 例如 λ = 0 即变为 (a, b) ，λ < 0 则其相对于 (a, b) 的方向会相反。

4\. 4 l r θ y0 ：将编号在 \[l, r\] 中的点以 y = (arctan θ)x + y0 为对称轴做对称变换

• 保证  以弧度制给出。

• 例如， θ = 0, y0 = 0 即沿 x 轴对称。

5\. 5 l r θ y0 ：将编号在 \[l, r\] 中的点投影到 y = (arctan θ)x + y0

• 保证 θ ∈ ( −  , ) ，以弧度制给出。

• 例如， θ = 0, y0 = 0 即投影到 x 轴上。

6\. 6 l r ：求编号在 \[l, r\] 中的点的重心。

• 点集 {(ai , bi  的重心定义为 

7\. 7 l r a b：求编号在 \[l, r\] 中的点到 (a, b) 的距离的平方的和（注意， 不是距离的 和的平方）。

• 点集 {(ai , bi  到 (a, b) 的距离的平方的和即 

【输入格式】

从标准输入读入数据。

第一行一个整数 n, q 表示点数和操作数。

接下来 n 行，每行两个实数表示 (xi , yi )。

接下来 q 行，每行若干实数表示一次操作，保证格式同题面。

【输出格式】

输出到标准输出。

若干行，每行依次对 6 和 7 操作输出两个或一个实数，表示所求的重心坐标或距离 平方和。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

10 20

26.389153 -31.339463

\-98.664509 -58.061567

16.023894 14.489272

\-67.840842 -74.793309

19.790708 -87.062719

31.541964 88.441505

\-75.918013 24.526470

57.288832 -39.033977

38.274184 -67.446883

\-90.906424 -73.528612

3 4 4 32.938694 -6.774595 1.000221

1 2 6 69.965610 -39.563795

4 3 10 -1.399075 38.282976

4 6 7 -1.016301 61.080461

7 9 10 76.549276 22.856189

7 3 7 -96.501727 5.585970

6 8 9

4 2 8 1.215917 -90.918350

7 4 8 55.948842 38.373278

1 5 9 -83.845362 -6.619437

5 6 9 -1.202044 -90.146760

7 1 4 -81.574047 -56.555229

3 1 5 75.690820 60.620104 0.980271

25

26

27

28

29

30

31

4 5 9 1.512746 89.531420

5 2 5 0.071305 79.784122

6 2 4

1 3 6 90.288492 72.829660

6 4 4

7 1 10 -51.991614 -6.732535

5 5 6 0.087950 71.164056

【样例 1 输出】

1

2

3

4

5

6

7

8

21029.678359

120220.146461

\-14.172376 -63.985055

95006.134951

52111.910474

2.849235 79.987632

35.040886 148.667661

302347.683678

【样例 2】

见题目目录下的 **_2.in_** 与 **_2.ans_**。

【样例 2 解释】

该样例中仅有 1, 3, 6 操作，且 n, q ≤ 2000。

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

【样例 3 解释】

该样例中仅有 1, 3, 6, 7 操作，且 n, q ≤ 2000。

【样例 4】

见题目目录下的 **_4.in_** 与 **_4.ans_**。

【样例 4 解释】

该样例中仅有 1, 2, 3, 6, 7 操作，且 n, q ≤ 2000。

【样例 5】

见题目目录下的 **_5.in_** 与 **_5.ans_**。

【样例 5 解释】

该样例中 n, q ≤ 2000。

【样例 6】

见题目目录下的 **_6.in_** 与 **_6.ans_**。

【样例 6 解释】

该样例与最终评测时子任务 7 的数据强度相同。

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 子任务编号 | n ≤ | q ≤ | 可能出现的操作编号 | 子任务分值 |
| 1   | 2,000 | 2,000 | 1,3,6,7 | 10  |
| 2   | 1,2,3,6,7 |
| 3   | 1,2,3,4,5,6,7 |
| 4   | 5 ×105 | 2 ×104 | 1,3,6 | 20  |
| 5   | 1,3,6,7 |
| 6   | 1,2,3,6,7 |
| 7   | 1,2,3,4,5,6,7 | 10  |

【提示】

为了避免精度误差，评测时选手的输出与标准程序的输出相对或绝对误差不超过 10-3 即算通过。

其中，实数 a, b 的绝对误差即 |a − b|，相对误差即  。

保证任意时刻任意一点的横纵坐标的绝对值均不超过 106。

第25次 CCF计算机软件能力认证

CSP202203

题目

时间：2022 年 3 月 20 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 未初始化警 告 | 出行计划 | 计算资源调 度器 | 通信系统管 理 | 博弈论与石 子合并 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.5 秒 | 1.0 秒 | 2.0 秒 | 1.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 测 试 点/包 数 目 | 10  | 10  | 20  | 7   | 6   |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 否   |

未初始化警告（warning）

【题目背景】

一个未经初始化的变量， 里面存储的值可能是任意的。因此直接使用未初始化的变 量，比如将其赋值给另一个变量，并不符合一般的编程逻辑。代码中出现这种情况， 往 往是因为遗漏了初始化语句、或是打错了变量名。对代码中使用了未初始化变量的语句 进行检查，可以方便地排查出代码中的一些隐秘 Bug。

【题目描述】

考虑一段包含 _k_ 条赋值语句的简单代码。该段代码最多使用到 _n_ 个变量，分别记 作 _a_1 , _a_2 , · · · , _an_ ；该段代码使用的常量均记作 _a_0。

第 _i_ 条（1 ≤ _i_ ≤ _k_）赋值语句为 _axi_ \= _ayi_ ，满足 1 ≤ _xi_ ≤ _n_ 、0 ≤ _yi_ ≤ _n_，表示将 _ayi_ 的值赋给变量 _axi_。其中 _axi_ 被称为该赋值语句的左值，一定是个变量；_ayi_ 被称为右值， 可以是一个常量或变量。

对于任意一条赋值语句 _axi_ \= _ayi_ ，如果右值 _ayi_ 是一个变量，则其应该在此之前被 初始化过。具体来说，如果变量 _ayi_ 在前 _i_ − 1 条赋值语句中做为左值出现过， 即存在 _j_ < _i_ 满足 _xj_ \= _yi_（这里无需考虑第 _j_ 条赋值语句本身是否也有右值未初始化的问题）， 我们就认为在第 _i_ 条赋值语句中 _ayi_ 已被初始化；否则，我们认为该条语句存在右值未 初始化的问题。

按照上述规则，试统计给定的代码中，有多少条赋值语句右值未被初始化。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 _n_ 、_k_，分别表示变量的数量和赋值语句 的条数。

接下来输入 _k_ 行，其中第 _i_ 行（1 ≤ _i_ ≤ _k_）包含空格分隔的两个正整数 _xi_ 、_yi_ ，表 示第 _i_ 条赋值语句。

【输出格式】

输出到标准输出。

输出一个整数，表示有右值未被初始化问题的赋值语句条数。

【样例 1 输入】

10 7

1 2

3 3 3 0 3 3 6 2

2 1 8 2

【样例 1 输出】

3

【样例 1 解释】

其中第一、二、五条赋值语句右值未被初始化。

【子任务】

50% 的测试数据满足 0 < _n_, _k_ ≤ 1000；

全部的测试数据满足 0 < _n_, _k_ ≤ 105。

出行计划（plan）

【题目描述】

最近西西艾弗岛上出入各个场所都要持有一定时限内的核酸检测阴性证明。

具体来时，如果在 _t_ 时刻做了核酸检测， 则经过一段时间后可以得到核酸检测阴性 证明。这里我们假定等待核酸检测结果需要 _k_ 个单位时间， 即在 _t_ \+ _k_ 时刻可以获得结 果。如果一个场所要求持 24 个单位时间内核酸检测结果入内，那么凭上述的核酸检测 结果，可以在第 _t_ \+ _k_ 时刻到第 _t_ \+ _k_ \+ 23 时刻进入该场所。

小 C 按时间顺序列出接下来的 _n_ 项出行计划， 其中第 _i_ 项（1 ≤ _i_ ≤ _n_）可以概 括为：_ti_ 时刻进入某场所，该场所需持有 _ci_ 个单位时间内的核酸检测结果入内，其中 0 < _ci_ ≤ 2 × 105。

为了合理安排核酸检测时间，试根据小 C 的出行计划，回答如下查询：

• 如果在 _q_ 时刻做了核酸检测，有多少项出行计划的核酸检测要求可以得到满足？ 这样的查询共有 _m_ 个，分别为 _q_1, _q_2 , · · · , _qm_ ；查询之间互不影响。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的三个正整数 _n_ 、_m_ 和 _k_，分别表示出行计划数目、查 询个数以及等待核酸检测结果所需时间。

接下来输入 _n_ 行，其中每行包含用空格分隔的两个正整数 _ti_ 、_ci_ ，表示一项出行计 划；出行计划按时间顺序给出，满足 0 < _t_1 ≤ _t_2 ≤ · · · ≤ _tn_ ≤ 2 × 105。

最后输入 _m_ 行，每行仅包含一个正整数 _qi_ ，表示一个查询。_m_ 个查询亦按照时间 顺序给出，满足 0 < _q_1 < _q_2 < · · · < _qm_ ≤ 2 × 105。

【输出格式】

输出到标准输出。

输出共 _m_ 行，每行一个整数，表示对应查询的答案。

【样例 1 输入】

6 2 10

5 24

10 24

11 24

34 24

35 24

35 48

1

2

【样例 1 输出】

3

3

【样例 1 解释】

时刻 1 做检测，可以满足第三、四、六项出行计划； 时刻 2 做检测，可以满足第四、五、六项出行计划。

【子任务】

40% 的测试数据满足 0 < _n_, _k_ ≤ 1000 、_m_ \= 1； 70% 的测试数据满足 0 < _n_, _m_, _k_ ≤ 1000；

全部的测试数据满足 0 < _n_, _m_, _k_ ≤ 105。

计算资源调度器（scheduler）

【题目背景】

西西艾弗岛上兴建了一批数据中心，建设了云计算资源平台。小 C 是主管西西艾 弗云开发的工程师。西西艾弗云中有大量的计算节点， 每个计算节点都有唯一编号。西 西艾弗云分为多个可用区， 每个计算节点位于一个特定的可用区。 一个可用区中可以有 多个计算节点。

西西艾弗云中运行的计算任务分为不同的应用，每个计算任务都有一个应用与之 对应，一个应用中可能包括多个计算任务。每个计算任务由一个特定的计算节点执行， 下文中计算任务“运行在某可用区上”意即“运行在某可用区的计算节点上”。不同的 计算任务对运行的计算节点的要求不尽相同。有的计算任务需要在指定可用区上运行， 有的计算任务要和其它应用的计算任务在同一个可用区上运行，还有的希望不要和某 个应用的计算任务在同一个计算节点上运行。对于一个计算任务，执行它的计算节点一 旦选定便不再更改； 在选定计算节点后， 该任务对计算节点的要求就不再被考虑， 即使 新安排的计算任务使得此前已有的计算任务的要求被违反，也是合法的。

下图示意性地说明了可用区、计算节点、计算任务之间的关系， 同时也说明了应用 和计算任务的对应关系。

节点 3

任务 3

应⽤ 1

任务 7

应⽤ 2

任务 11

应⽤ 4

可⽤区 2

节点 4

任务 4

应⽤ 1

任务 8

应⽤ 2

任务 12

应⽤ 4

可⽤区 1

节点 2

任务 2

应⽤ 1

任务 6

应⽤ 2

任务 10

应⽤ 3

节点 1

任务 1

应⽤ 1

任务 5

应⽤ 2

任务 9

应⽤ 3

一开始，小 C 使用了电子表格程序来统计计算任务的分配情况。随着云上的计算 节点和计算任务的不断增多，小 C 被这些奇怪的要求搞得焦头烂额，有的时候还弄错 了安排，让客户很不满意。小 C 找到你，希望你能为他提供一个程序，能够输入要运 行的计算任务和对节点的要求， 结合西西艾弗云的现有计算节点信息， 计算出计算任务 应该被安排在哪个计算节点上。

【题目描述】

计算任务对计算节点的要求十分复杂而且又不好描述，你对小 C 表示写程序这件 事很为难。于是， 小 C 进行了调研，将这些需求进行了归纳整理， 形成了下面这三种标

准需求。在提出需求时，必须从这三种标准需求中选取若干种，每种需求只能有一条。 选取多种需求意味着要同时满足这些需求。

• 计算节点亲和性

计算任务必须在指定可用区上运行。

• 计算任务亲和性

计算任务必须和指定应用的计算任务在同一可用区上运行。

该要求对计算任务可以运行的可用区添加了限制。不考虑该任务本身， 一个可用 区若运行有指定应用的任务，则满足要求。

• 计算任务反亲和性

计算任务不能和指定应用的计算任务在同一个计算节点上运行。

该要求对计算任务可以运行的计算节点添加了限制。不考虑该任务本身， 一个计 算节点若运行有指定应用的任务，则不满足要求。

当要执行的计算任务多起来， 计算任务反亲和性的要求可能很难满足。因此在添 加计算任务反亲和性要求时，还要指定这个要求是“必须满足”还是“尽量满 足”。

小 C 要求你按照如下方法来分配计算节点：按照计算任务的启动顺序，根据要求， 依次为每个计算任务选择计算节点。一旦选择了一个计算节点，就固定下来不再变动， 并且在此后的选择中， 不再考虑这个计算任务的要求。对每个计算任务， 选择计算节点 的方法是：

1\. 过滤阶段

在这个阶段，先根据计算任务的要求， 过滤出所有满足要求的计算节点。如果不 存在这样的计算节点， 并且指定了计算任务反亲和性要求， 并且计算任务反亲和 性要求是尽量满足的， 那么去掉计算任务反亲和性要求， 再过滤一次。如果还不 存在，就认为该计算任务的要求无法满足，该计算任务无法分配。

2\. 排序阶段

在这个阶段，将过滤后的计算节点按照这个方法排序：

1\. 选择此时运行计算任务数量最少的计算节点；

2\. 选择编号最小的计算节点。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个由空格分隔的正整数 _n_ 和 _m_，分别表示计算节点的数目和 可用区的数目。计算节点从 1 到 _n_ 编号，可用区从 1 到 _m_ 编号；

输入的第二行包含 _n_ 个由空格分隔的正整数 _l_1, _l_2, . . . _li_, . . . , _ln_，表示编号为 _i_ 的计算 节点位于编号为 _li_ 的可用区。其中， 0 < _li_ ≤ _m_；

输入的第三行包含一个正整数 _g_，表示计算任务的组数；

接下来的 _g_ 行，每行包含六个由空格分隔的整数 _fi_ 、_ai_ 、_nai_、_pai_、_paai_、_paari_ ，表 示依次启动的一组计算任务的信息，其中：

• _fi_：表示要接连启动 _fi_ 个所属应用和要求相同的计算任务，其中 _fi_ \> 0；

• _ai_：表示这 _fi_ 个计算任务所属应用的编号， 其中 0 < _ai_ ≤ _Amax_（_Amax_ 代表最大应 用编号）；

• _nai_：表示计算节点亲和性要求， 其中 0 ≤ _nai_ ≤ _m_。当 _nai_ \= 0 时，表示没有计算 节点亲和性要求；否则表示要运行在编号为 _nai_ 的可用区内的计算节点上；

• _pai_：表示计算任务亲和性要求，其中 0 ≤ _pai_ ≤ _Amax_。当 _pai_ \= 0 时，表示没有 计算任务亲和性要求； 否则表示必须和编号为 _pai_ 的应用的计算任务在同一个可 用区运行；

• _paai_：表示计算任务反亲和性要求，其中 0 ≤ _paai_ ≤ _Amax_。当 _paai_ \= 0 时，表示 没有计算任务反亲和性要求；否则表示不能和编号为 _paai_ 的应用的计算任务在 同一个计算节点上运行；

• _paari_：表示计算任务亲和性要求是必须满足还是尽量满足， 当 _paai_ \= 0 时，_paari_ 也一定为 0；否则 _paari_ \= 1 表示“必须满足”，_paari_ \= 0 表示“尽量满足”。

计算任务按组输入实际上是一种简化的记法， 启动一组 (_fi_, _ai_, _nai_, _pai_, _paai_, _paari_ ) 和连续启动 _fi_ 组 (1, _ai_, _nai_, _pai_, _paai_, _paari_ ) 并无不同。

【输出格式】

输出到标准输出。

输出 _g_ 行，每行有 _fi_ 个整数， 由空格分隔，分别表示每个计算任务被分配的计算 节点的情况。若该计算任务没有被分配， 则输出 0；否则输出被分配的计算节点的编号。

【样例 1 输入】

10 4

1 1 1 1 1 2 2 2 2 2

6

2 1 4 1 2 1

6 1 1 0 1 1

1 2 2 0 0 0

6 1 2 0 2 1

5 2 2 0 1 0

11 3 0 1 3 0

【样例 1 输出】

0 0

1 2 3 4 5 0

6

7 8 9 10 7 8

6 6 6 6 6

1 2 3 4 5 9 10 7 8 6 1

【样例 1 解释】

本输入中声明了十个计算节点，前五个位于可用区 1，后五个位于可用区 2。可用 区 3 和 4 不包含任何计算节点。

对于第一组计算任务， 由于它们声明了计算节点亲和性要求， 但要求的可用区编号 是 4 ，该可用区不包含计算节点，因此都不能满足。

对于第二组计算任务，要在可用区 1 中启动 6 份应用 1 的任务，并且要求了计算 任务反亲和性。因此， 前五份任务分别被安排在前五个节点上。对于第六份任务， 由于 它必须运行于可用区 1，所以能够安排的范围仅限于前五个节点。但是它还指定了强制 的计算任务反亲和性，前五个节点上已经启动了属于应用 1 的计算任务， 因此没有能 够运行它的节点。

对于第三组计算任务，要在可用区 2 中启动 1 份应用 2 的任务，直接将其分配给 节点 6。

对于第四组计算任务，要在可用区 2 中启动 6 份应用 1 的任务，并且要求了计算 任务反亲和性，不能和应用 2 的计算任务分配在同一个节点上。因此，节点 6 不能用 于分配，这六份任务只能分配在节点 7～10 上。按照题意，选取运行任务数最少的和 编号最小的，因此依次分配 7 、8 、9 、10 、7 、8。

对于第五组计算任务，要在可用区 2 中启动 5 份应用 2 的任务，并且要求了尽量 满足的计算任务反亲和性，不能和应用 1 的计算任务分配在同一个节点上。此时，可 用区 2 中的节点 6 上没有应用 1 的计算任务， 因此这 5 份计算任务都会被分配到这个 节点上。

对于第六组计算任务，要启动 11 份应用 3 的任务，并且要求了尽量满足的计算任 务反亲和性，不能和应用 3 的其它计算任务分配在同一个节点上， 同时要求和应用 1 的计算任务位于同一个可用区。应用 1 位于两个可用区， 因此全部 10 个节点都可以用 于分配。对于前 10 份任务，按照题意，依次选取运行的任务数最少且编号最小的节点 进行分配。对于第 11 份任务， 由于所有的节点上都运行有应用 3 的任务，因此没有节 点符合它的反亲和性要求。又因为反亲和性要求是尽量满足的， 因此可以忽略这一要 求，将它安排在节点 1 上。

【子任务】

本题包含 20 个测试用例，每个 5 分。

全部测试数据保证 

部分测试点的特殊性质详见下表， 比如测试点 1 、2 中最大应用编号仅为 10 且不 包含任何需求。

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 测试点 | 最大应用编号 | 计算节点亲和性 | 计算任务亲和性 | 计算任务反亲和性 |
| 1, 2 | _Amax_ \= 10 | 无要求（_nai_ \= 0） | 无要求（_pai_ \= 0） | 无要求（_paai_ \= 0） |
| 3, 4 | _Amax_ \= 109 | 无要求（_nai_ \= 0） | 无要求（_pai_ \= 0） | 无要求（_paai_ \= 0） |
| 5, 6, 7 | _Amax_ \= 10 | _nai_ ≥ 0 | 无要求（_pai_ \= 0） | 无要求（_paai_ \= 0） |
| 8, 9, 10 | _Amax_ \= 109 | _nai_ ≥ 0 | 无要求（_pai_ \= 0） | 无要求（_paai_ \= 0） |
| 11, 12, 13 | _Amax_ \= 10 | _nai_ ≥ 0 | 无要求（_pai_ \= 0） | _paai_ ≥ 0 |
| 14, 15, 16 | _Amax_ \= 109 | _nai_ ≥ 0 | 无要求（_pai_ \= 0） | _paai_ ≥ 0 |
| 17, 18 | _Amax_ \= 10 | _nai_ ≥ 0 | _pai_ ≥ 0 | _paai_ ≥ 0 |
| 19, 20 | _Amax_ \= 109 | _nai_ ≥ 0 | _pai_ ≥ 0 | _paai_ ≥ 0 |

通信系统管理（communication）

【题目描述】

你负责管理一个计算机通信系统。

有 _n_ 台计算机接入了该系统，编号为 1 ~_n_ ，它们之间可以互相发送数据。

由于设备条件限制，机器之间不能任意多地发送数据。每两台机器之间均有一个 “每日可用额度”的限制，单位为 MB/day，表示这两台机器每日可以互相发送的数据 量（双方各自向对方发送的数据量之和）的最大值。

最初，任意两台机器的每日可用额度均为 0 。为了能发送数据，机器管理者需要 向你申请额度。每个申请形如 _uv x y_ 的格式，表示机器 _u_ 和 _v_ 的每日可用额度增大 _x_ MB/day，持续 _y_ 天（即从申请当天开始至申请后第 _y_ \- 1 天内有效，从第 _y_ 天开始失 效）。不同申请的效果是可以叠加的。

定义每台机器的“通信主要对象”为当前时刻与该机器的每日可用额度最大的机 器（如果有并列，则取其中编号最小的机器）；如果一台机器与任何机器的每日可用额 度均为 0 ，则称其为“通信孤岛”，并认为其没有“通信主要对象”；如果两台机器 _x_ 和 _y_ 互为“通信主要对象”，则称它们是一个“通信对”。

每天开始时，你都会先接受若干个额度申请， 你需要依次处理这些申请； 而后，你 将接收到若干个查询某台机器的“通信主要对象”的请求；最后，你可能还希望求出此 时的“通信孤岛”和“通信对”各有多少。

请你编写一段程序来实现上述任务。

【输入格式】

从标准输入读入数据。

第一行：2 个正整数 _n_, _m_ ，表示机器数和天数。

接下来 3_m_ 行，每两行描述一天中的事件，格式如下：

• 第 1 行：首先是一个非负整数 _ki_ ，表示当天额度申请的数量。接下来有 4_ki_ 个 非负整数，依次描述每一个额度申请，格式如题面中所述。

• 第 2 行：首先是一个非负整数 _li_ ，表示当天查询“通信主要对象”的数量。接 下来有 _li_ 个正整数，依次表示查询的机器编号，保证编号在 \[1, _n_\] 范围内。

• 第 3 行：2 个整数 _pi_, _qi_ ，取值均为 0 或 1 ，分别表示当天是否要查询“通信孤 岛”和“通信对”的数量。其中 _pi_ \= 1 表示需要查询“通信孤岛”的数量，_pi_ \= 0 表示不需要查询； _qi_ 的含义同理。

【输出格式】

输出到标准输出。

对于每个查询分别输出一行，一个非负整数表示该查询的答案。

查询按照天数顺序输出， 对于同一天内的查询，先按照输入顺序输出所有查询“通 信主要对象”的答案，再依次输出查询“通信孤岛”和“通信对”的答案（如果当天需 要查询的话）。

如果某台被查询“通信主要对象”的机器是“通信孤岛”，认为查询结果为 0 。

【样例 1 输入】

3 3

2 1 2 2 3 1 3 3 2

1 1

0 0

1 2 3 3 1

2 1 2

0 1

0

2 1 3

1 1

【样例 1 输出】

3

3

3

1

2

0

1

1

【子任务】

设 

子任务 1（20 分）：满足 _n_, _m_ ≤ 1000, _A_, _B_ ≤ 2000 ；

子任务 2（10 分）：满足 _pi_ \= _qi_ \= 0 ；

子任务 3（10 分）：满足 _li_ \= _qi_ \= 0 ；

子任务 4（15 分）：满足 _li_ \= 0 ;

子任务 5（10 分）：满足 _k_1 = _A_ ，对于所有额度申请均满足 _y_ \= _m_ ;

子任务 6（15 分）：满足对于所有额度申请均满足 _y_ \= _m_ ;

子任务 7（20 分）：无特殊性质。

对于 100% 的数据，1 ≤ _n_, _m_ ≤ 105 , 1 ≤ _A_, _B_ ≤ 2× 105 , 1 ≤ _u_, _v_ ≤ _n_, 1 ≤ _x_ ≤ 109 , 1 ≤ _y_ ≤ _m_ 。

所有额度申请均满足 _u_ ≠ _v_ 。

博弈论与石子合并（game）

【题目背景】

小 c 和小 z 学习了博弈论的落后知识，他们打算玩 Nim 游戏以提高博弈论的先 进性。

【题目描述】

众所周知，Nim 游戏本质上就是幼儿园小朋友的玩石子的小游戏，于是他们找到 了许多石子，并将其分为 _n_ 堆并排成一排，从左到右第 _i_ 堆有 _ai_ 个石子。

而说到石子，当然就不能不提到大名鼎鼎的动态规划入门经典题目《石子合并》。

所以在最初的规则中由两人轮流进行操作，每次操作者可以选择合并两堆相邻的 石子，如此操作直到剩下一堆石子。小 c 希望这堆石子尽量少，小 z 则希望这堆石子 尽量多。

小 c 和小 z 希望知道在二人绝顶聪明的情况下最终这堆石子的大小是多少——才

怪，显然按照上述规则最终一堆石子的大小一定是 ，与二人的操作无关。

于是他们决定增添一些新的规则， 新规则如下：仍由两人轮流操作， 每次操作者可 以选择合并两堆相邻的石子， 或者扔掉目前最靠左的一堆石子，或者扔掉目前最靠右的 一堆石子（不能不操作），直到剩下一堆石子。小 c 希望这堆石子尽量少，小 z 则希望 这堆石子尽量多。

仍然假设二人聪明绝顶（虽然这在实际上并不可能（至少对小 c 不可能）），问最后 这堆石子的大小是多少？

注意，为了公平起见，每次游戏开始时他们会决定谁先手， 而不是固定的由小 c 先 手或者小 z 先手。

【输入格式】

从标准输入读入数据。

第一行两个整数 _n_, _k_；

其中 _k_ ∈ {0, 1} 。_k_ \= 0 表示小 c 先手，_k_ \= 1 表示小 z 先手；

第二行 _n_ 个整数 _a_1 , _a_2 , . . . , _an_。

【输出格式】

输出到标准输出。

输出一行一个整数表示答案。

【样例 1 输入】

2 0

1 2

【样例 1 输出】

1

【样例 1 解释】

本局小 c 先手，显然他会选择扔掉最靠右的一堆。

【子任务】

|     |     |     |     |
| --- | --- | --- | --- |
| 子任务编号 | _n_ ≤ | 特殊性质 | 测试点分值 |
| 1   | 20  | 无   | 20  |
| 2   | 105 | 每堆石子大小相等 |
| 3   | _n_ 是偶数，且小 z 先手 |
| 4   | _n_ 是偶数，且小 c 先手 |
| 5   | 2, 000 | 无   | 5   |
| 6   | 105 | 15  |

对于 100% 数据，1 ≤ _n_ ≤ 105 , 0 ≤ _k_ ≤ 1, _ai_ \> 0, ∑1 _an_ ≤ 109。

第 24 次 CCF 计算机软件能力认证 2021.12

CSP202112

题目

时间：2021 年 12月 05 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 有序数组查 询 | 查询问题新 解 | 登机牌条码 | 磁盘  | 极差路径 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 2.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 0   | 0   | 10  | 0   | 25  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 否   |

序列查询（query）

【题目背景】

西西艾弗岛的购物中心里店铺林立， 商品琳琅满目。为了帮助游客根据自己的预算 快速选择心仪的商品，IT 部门决定研发一套商品检索系统，支持对任意给定的预算 _x_， 查询在该预算范围内(≤ _x_）价格最高的商品。如果没有商品符合该预算要求，便向游 客推荐可以免费领取的西西艾弗岛定制纪念品。

假设购物中心里有 _n_ 件商品，价格从低到高依次为 _A_1, _A_2 · · · _An_ ，则根据预算 _x_ 检 索商品的过程可以抽象为如下序列查询问题。

【题目描述】

_A_ \= \[_A_0, _A_1, _A_2 , · · · , _An_ \] 是一个由 _n_ \+ 1 个 \[0, _N_) 范围内整数组成的序列， 满足 0 = _A_0 < _A_1 < _A_2 < · · · < _An_ < _N_。（这个定义中蕴含了 _n_ 一定小于 _N_。）

基于序列 _A_，对于 \[0, _N_) 范围内任意的整数 _x_，查询 _f_ (_x_) 定义为：序列 _A_ 中小于 等于 _x_ 的整数里最大的数的下标。具体来说有以下两种情况：

1\. 存在下标 0 ≤ _i_ < _n_ 满足 _Ai_ ≤ _x_ < _Ai_+1

此时序列 _A_ 中从 _A_0 到 _Ai_ 均小于等于 _x_，其中最大的数为 _Ai_ ，其下标为 _i_，故 _f_ (_x_) = _i_。

2\. _An_ ≤ _x_

此时序列 _A_ 中所有的数都小于等于 _x_，其中最大的数为 _An_，故 _f_ (_x_) = _n_。

令 _sum_(_A_) 表示 _f_ (0) 到 _f_ (_N_ − 1) 的总和，即：

对于给定的序列 _A_，试计算 _sum_(_A_)。

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 _n_ 和 _N_。

输入的第二行包含 _n_ 个用空格分隔的整数 _A_1, _A_2 , · · · , _An_。

注意 _A_0 固定为 0，因此输入数据中不包括 _A_0。

【输出格式】

输出到标准输出。

仅输出一个整数，表示 _sum_(_A_) 的值。

【样例 1 输入】

3 10

2 5 8

【样例 1 输出】

15

【样例 1 解释】

_A_ \= \[0, 2, 5, 8\]

|     |     |     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| _i_ | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| _f_ (_i_) | 0   | 0   | 1   | 1   | 1   | 2   | 2   | 2   | 3   | 3   |

如上表所示， _sum_(_A_) = _f_(0) + _f_(1) + · · · + _f_(9) = 15。

考虑到 _f_ (0) = _f_ (1) 、_f_ (2) = _f_ (3) = _f_ (4) 、_f_ (5) = _f_ (6) = _f_ (7) 以及 _f_ (8) = _f_(9)，亦可 通过如下算式计算 _sum_(_A_)：

_sum_(_A_) = _f_(0) × 2 + _f_ (2) × 3 + _f_ (5) × 3 + _f_ (8) × 2

【样例 2 输入】

9 10

1 2 3 4 5 6 7 8 9

【样例 2 输出】

45

【子任务】

50% 的测试数据满足 1 ≤ _n_ ≤ 200 且 _n_ < _N_ ≤ 1000；

全部的测试数据满足 1 ≤ _n_ ≤ 200 且 _n_ < _N_ ≤ 107。

【提示】

若存在区间 \[_i_, _j_) 满足 _f_ (_i_) = _f_ (_i_ \+ 1) = · · · = _f_(_j_ − 1)，使用乘法运算 _f_(_i_) × (_j_ − _i_) 代 替将 _f_ (_i_) 到 _f_(_j_ − 1) 逐个相加，或可大幅提高算法效率。

序列查询新解（query2）

【题目背景】

上一题“序列查询”中说道：_A_ \= \[_A_0, _A_1, _A_2 , · · · , _An_ \] 是一个由 _n_ \+ 1 个 \[0, _N_) 范围 内整数组成的序列， 满足 0 = _A_0 < _A_1 < _A_2 < · · · < _An_ < _N_。基于序列 _A_，对于 \[0, _N_) 范 围内任意的整数 _x_，查询 _f_ (_x_) 定义为：序列 _A_ 中小于等于 _x_ 的整数里最大的数的下标。

对于给定的序列 _A_ 和整数 _x_，查询 _f_ (_x_) 是一个很经典的问题，可以使用二分搜索 在 _O_(log_n_) 的时间复杂度内轻松解决。但在 IT 部门讨论如何实现这一功能时，小 P 同 学提出了些新的想法。

【题目描述】

小 P 同学认为，如果事先知道了序列 _A_ 中整数的分布情况，就能直接估计出其中 小于等于 _x_ 的最大整数的大致位置。接着从这一估计位置开始线性查找， 锁定 _f_(_x_)。如 果估计得足够准确，线性查找的时间开销可能比二分查找算法更小。

比如说，如果 _A_1, _A_2 , · · · , _An_ 均匀分布在 (0, _N_) 的区间，那么就可以估算出：

为了方便计算， 小 P 首先定义了比例系数 ⌋ , 其中 ⌊ 」表示下取整， 即 _r_ 等 于 _N_ 除以 _n_ \+ 1 的商。进一步地， 小 P 用  = ⌊ ⌋ 表示自己估算出的 _f_ (_x_) 的大小， 这里同样使用了下取整来保证 _g_(_x_) 是一个整数。

显然，对于任意的询问 _x_ ∈ \[0, _N_) ，_g_(_x_) 和 _f_ (_x_) 越接近则说明小 P 的估计越准确， 后续进行线性查找的时间开销也越小。因此，小 P 用两者差的绝对值 g(x) - f(x) 来 表示处理询问 _x_ 时的误差。

为了整体评估小 P 同学提出的方法在序列 _A_ 上的表现，试计算：

【输入格式】

从标准输入读入数据。

输入的第一行包含空格分隔的两个正整数 _n_ 和 _N_。

输入的第二行包含 _n_ 个用空格分隔的整数 _A_1, _A_2 , · · · , _An_。

注意 _A_0 固定为 0，因此输入数据中不包括 _A_0。

【输出格式】

输出到标准输出。

仅输出一个整数，表示 _error_(_A_) 的值。

【样例 1 输入】

3 10 2 5 8

【样例 1 输出】

5

【样例 1 解释】

_A_ \= \[0, 2, 5, 8\]

|     |     |     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| _i_ | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| _f_ (_i_) | 0   | 0   | 1   | 1   | 1   | 2   | 2   | 2   | 3   | 3   |
| _g_(_i_) | 0   | 0   | 1   | 1   | 2   | 2   | 3   | 3   | 4   | 4   |
| Ⅱ_g_(_i_) - _f_ (_i_)Ⅱ | 0   | 0   | 0   | 0   | 1   | 0   | 1   | 1   | 1   | 1   |

【样例 2 输入】

9 10

1 2 3 4 5 6 7 8 9

【样例 2 输出】

0

【样例 3 输入】

2 10

1 3

【样例 3 输出】

6

【样例 3 解释】

_A_ \= \[0, 1, 3\]

|     |     |     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| _i_ | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| _f_ (_i_) | 0   | 1   | 1   | 2   | 2   | 2   | 2   | 2   | 2   | 2   |
| _g_(_i_) | 0   | 0   | 0   | 1   | 1   | 1   | 2   | 2   | 2   | 3   |
| Ⅱ_g_(_i_) − _f_ (_i_)Ⅱ | 0   | 1   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 1   |

【子任务】

70% 的测试数据满足 1 ≤ _n_ ≤ 200 且 _n_ < _N_ ≤ 1000；

全部的测试数据满足 1 ≤ _n_ ≤ 105 且 _n_ < _N_ ≤ 109。

【提示】

需要注意， 输入数据 \[_A_1 · · · _An_ \] 并不一定均匀分布在 (0, _N_) 区间， 因此总误差 _error_(_A_) 可能很大。

登机牌条码（barcode）

【题目背景】

西西艾弗岛景色优美， 游人如织。但是， 由于和外界的交通只能靠渡船， 交通的不 便严重制约了岛上旅游业的发展。西西艾弗岛管委会经过努力， 争取到了一笔投资，建 设了一个通用航空机场。在三年紧锣密鼓的主体建设后， 西西艾弗岛通用航空机场终于 开始进行航站楼内部软硬件系统的安装和调试工程了。小 C 是机场运营公司信息部的 研发工程师，最近，信息部门的一项重要任务是， 研发登机牌自助打印系统。如图所示 的是设计部门根据国际民航组织的行业标准设计的登机牌样张。

图 1: 登机牌

登机牌上最重要的部分就是最下方的机读条形码了。小 C 承担了生成机读条形码 算法的开发工作。从被编码的数据到条形码， 中间有好多步骤要走。小 C 请你来帮忙， 让你帮忙处理一下数据编码的问题。

【题目描述】

登机牌上的条形码，是 PDF417 码。PDF417 码的结构如下图所示。

PDF417 码组成的基本元素是码元（Module），所有的码元都是等大的矩形，填充 有黑色或白色。码元先组成行， 若干行堆叠组成整个 PDF417 码。每一行中，每 17 个 码元表示一个码字（Code word）。码字是 PDF417 编码中的最小数据单位。每个码字 图案中，有交替排列的四个黑色矩形和四个白色矩形，这便是“417”的由来。每行开 始和结尾有固定的起始和中止图案。与他们相邻的是行左侧和右侧标志， 表示行号、行 内码字个数等信息。中间的是有效数据区。编码的步骤是： 先按照编码规则， 将被编码 的数据转换为码字；接着根据选定 PDF417 码的宽度（即每行码字的数目） 以及冗余

|     |     |
| --- | --- |
| **1** | **2** |
|     |     |

|     |     |
| --- | --- |
| **6** | **7** |
|     |     |

|     |     |
| --- | --- |
| **3** | **4** |

**3**

**4**

**5**

**9**

**10**

**11**

**12**

**13**

**14**

**15**

**16**

**17**

**1**

**2**

**5**

**8**

**9**

**10**

**11**

**12**

**13**

**14**

**15**

**16**

**17**

|     |     |     |
| --- | --- | --- |
| **6** | **7** | **8** |
|     |     |     |

起始图案 ⾏左侧标志 数据区 ⾏右侧标志 终⽌图案

图 2: PDF417 码

程度计算校验码字； 最后将码字按规则转换为对应的图案， 并按照从左至右， 从上至下 的的顺序填入有效数据区， 并与起始终止图案和行左右标志拼合， 形成完整的 PDF417 码。

每个码字是一个 0 至 928 之间的数字，每个码字可以编码两个输入字符。对于输 入的被编码的数据， 按照下表进行编码。编码器共有三种模式： 大写字母模式、小写字 母模式和数字模式。在编码开始时，编码器处于大写字母模式。编码器处于某种模式 时，仅能编码对应类型的字符， 如果需要编码其它类型的字符， 需要通过特殊值切换到 对应模式下。要进行模式切换， 可以有多种切换方法。例如， 要从大写模式切入小写模 式，可以直接用 27 切入，也可以先用 28 切入数字模式后立刻再用 27 切入小写模式。 你需要选择最短的方式进行切换， 因此只有前一种方法是正确的。需要注意的是， 从小 写模式不能直接切入大写模式，必须要经过数字模式过渡。

|     |     |     |     |
| --- | --- | --- | --- |
| 值   | 大写模式 | 小写模式 | 数字模式 |
| 0   | A   | a   | 0   |
| 1   | B   | b   | 1   |
| 2   | C   | c   | 2   |
| 3   | D   | d   | 3   |
| 4   | E   | e   | 4   |
| 5   | F   | f   | 5   |
| 6   | G   | g   | 6   |
| 7   | H   | h   | 7   |
| 8   | I   | i   | 8   |
| 9   | J   | j   | 9   |
| 10  | K   | k   |     |
| 11  | L   | l   |
| 12  | M   | m   |
| 13  | N   | n   |
| 14  | O   | o   |
| 15  | P   | p   |
| 16  | Q   | q   |
| 17  | R   | r   |
| 18  | S   | s   |
| 19  | T   | t   |
| 20  | U   | u   |
| 21  | V   | v   |
| 22  | W   | w   |
| 23  | X   | x   |
| 24  | Y   | y   |
| 25  | Z   | z   |
| 27  | 小写  |     | 小写  |
| 28  | 数字  | 数字  | 大写  |
| 29  | 填充  | 填充  | 填充  |

按照这个方法可以得到一系列的不超过 30 的数字。如果有奇数个这样的数字，则 在最后补充一个 29，使之成为偶数个。将它们两两成组， 假设 _H_ 和 _L_ 是一组中连续出 现的两个数字，那么可以得到一个码字是：

30 × _H_ \+ _L_

例如，要编码“HE1lo ”，首先先根据字母表，产生数字序列：

H E 1 l o

7 4 28 1 27 11 14

由于只有奇数个数字，需要在末尾补充 29，然后将它们两两成组：

(7, 4), (28, 1), (27, 11), (14, 29)

最后计算码字，例如： 30 × 7 + 4 = 214，以此类推，可以得到码字为：

214, 841, 821, 449

接下来要计算校验码。校验码字的数目， 由校验级别确定。假设校验级别为 _s_(0 ≤ _s_ ≤ 8)，则校验码字的数目为 _k_ \= 2_s_+1。特别地，如果指定了 _s_ \= −1，则表示不需 要计算校验码字。要计算校验码字， 首先要确定数据码字。数据码字由以下数据按顺序 拼接而成（如图所示）：

⾏左侧标志 ⾏右侧标志

dn-1 ⻓度 ：n

dn-2

有效数据

数据码字

起始 图案

终⽌

图案

d2

d 1

填充

900

d0

ck-1

校验

ck-2

校验

填充

有效数据

900

校验码字

c 1 校验

c0 校验

图 3: 码字填充过程

• 一个长度码字，表示全部数据码字的个数 _n_ ，包括该长度码字、有效数据码字、 填充码字；

• 若干有效数据码字，是此前计算的码字序列；

• 零个或多个由重复的 900 组成的填充码字，使得包括校验码字在内的码字总数 恰能被有效数据区的行宽度整除。

设全部数据码字依次为 _dn_−1, _dn_−2, . . . , _d_0 ；校验码字依次为 _ck_−1, _ck_−2, . . . , _c_0。那么校 验码字按照如下方式计算：

取 _k_ 次多项式 _g_(_x_) = (_x_ − 3)(_x_ − 32 ) . . . (_x_ − 3_k_ ), (_n_ − 1) 次多项式 _d_(_x_) = _dn_−1_xn_−1 +

. . . _dn_−2_xn_−2 + . . . _d_1 _x_ \+ _d_0 ，找到多项式 _q_(_x_) 和不超过 (_k_ − 1) 次的多项式 _r_(_x_)，使得 _xkd_(_x_) 三 _q_(_x_)_g_(_x_) − _r_(_x_)

。那么多项式 _r_(_x_) 中 _x_ 的 _i_ 次项系数对 929 取模后（取正值） 的数字即为校验码字 _ci_。

例如，如果要将 HE1lo 编码为 PDF417 条码，且有效数据区的行宽是 4 码字（即 68 码元），校验级别为 0。此时校验码字有两个。根据此前的编码结果，有效数据码字 有 4 个。再加上一个长度码字，共有 7 个码字。因此需要补充一个填充码字，使包括 校验码字在内的总码字数能够被 4 整除。这样，用于计算校验码字的数据码字有 6 个， 分别是：

6, 214, 841, 821, 449, 900

因此有 _g_(_x_) = _x_2 - 12_x_+27，_d_(_x_) = 6_x_5 +214_x_4 +841_x_3 +821_x_2 +449_x_+900，不难得到 _r_(_x_) = -32902164_x_ \+ 98246277，因此相应可以计算出 _c_1 = 229 ≡ -32902164 mod 929， _c_0 = 811 ≡ 98246277 mod 929 。这样，全部码字序列即为：

6, 214, 841, 821, 449, 900, 229, 811

在本题中，你需要帮助小 C 完成的任务是，给定被编码的数据，计算出需要填入 有效数据区的码字序列。被处理的数据中只含有大写字母、小写字母和数字。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个用空格分隔的整数 _w_ 、_s_，分别表示有效数据区每行能容纳 的码字数和校验级别。保证 0 < _w_ < 929 ，-1 ≤ _s_ ≤ 8。特别地， 当 _s_ \= -1 时，表示不需 要计算校验码字。

输入的第二行是一个非空字符串， 仅包含大小写字母和数字， 长度保证编码后全部 数据码字的个数少于 929。

【输出格式】

输出到标准输出。

输出若干行，每行一个数字，表示编码后的全部码字序列。

【样例 1 输入】

5 -1

HELLO

【样例 1 输出】

5

214

341

449

900

【样例 1 解释】

要求编码数据是 HELLO ，首先查表将其对应成数字。注意， 由于编码器在开始时 就处于大写字母模式， 因此不需要额外的模式切换。因此对应成的数字为： 7, 4, 11, 11, 14。由于只有奇数个数字， 因此补充 29，形成序列 7, 4, 11, 11, 14, 29。然后两两成组 计算码字：7 × 30 + 4 = 214，以此类推，得到 214, 341, 449。本输入不要求产生校验码， 且有效数据区的宽度是 5 码字。目前有效数据的码字是 3 个，加上开头要添加的长度 码字，共有 4 个码字。因此， 需要补充一个填充码字，使得总码字数达到 5 个，充满一 行。注意， 长度码字中的长度数据包括所有数据码字， 因此长度码字是 5 而不是 4。最 终可以得到码字序列 5, 214, 341, 449, 900。

【样例 2 输入】

4 0

HE1lo

【样例 2 输出】

6

214

841

821

449

900

229

811

【样例 2 解释】

本组数据即为此前用于说明编码过程的示例。

【子任务】

对于 20% 的数据，有 _s_ \= -1，且输入字符串中仅含有大写字母或小写字母；

对于 40% 的数据，有 _s_ \= -1；

对于 80% 的数据，有 _s_ ≤ 2;

对于 100% 的数据，满足全部对于输入的要求。

磁盘文件操作（disk）

【题目背景】

小 C 对计算机运行的原理很感兴趣，经常进行一些研究和实验。

有一天，他在尝试删除一个好几 GB 大小的文件时，惊奇地发现删除操作几乎在 一瞬间就完成了！这让他很是纳闷：如果计算机在每次删除文件时都直接在磁盘上把 对应的数据抹掉，不是应该要花挺长时间吗？

于是他找来了小 S 和小 P 一起讨论。小 S 说，或许计算机是一个很“懒”的体系， 在删除时不会真的去抹除数据吧？而小 P 则更见多识广一些，他当即找来了一个号称 能“恢复磁盘数据”的软件，当场把小 C 刚刚删除的文件恢复了！

这让小 C 有了更强的好奇心，于是他们决定设计一个模型来模拟一个磁盘文件的 写入、删除及恢复过程。但是在他们生活的西西艾弗岛上没有合适的条件来运行他们的 模型，于是他们联系了带着一台算力超强的电脑来西西艾弗岛旅游的你来帮助他们。

【题目描述】

在小 C、小 S 和小 P 设计的模型中，计算机中有 _n_ 段程序（编号为 1 ~_n_ ）， 它 们共享一块大小为 _m_ 的磁盘空间（编号为 1 ~_m_ ）， 磁盘上的每个位置可以写入一个 整数。

最初，磁盘上每个位置上的数都是 0 ，并不被任何程序占用。

现在，这 _n_ 段程序同时执行，在某一时刻，某段程序可能对磁盘数据进行读写等 操作。

操作共 _k_ 个，按时间先后顺序给出，具体操作如下：

0 _id l r x_ ：编号为 _id_ 的程序尝试向磁盘空间中 \[_l_, _r_\] 位置上每个位置都写入一个整 数 _x_。

• 操作执行过程中，程序 _id_ 会尝试从最左端 _l_ 开始向右顺次写入数据。

• 对于每个位置，若目前不被任何程序占用， 则成功写入整数 _x_ ，并将其视为被程 序 _id_ 占用；

• 若该位置目前正被程序 _id_ 自己占用，则这次写入的 _x_ 可以覆盖之前写入的结果， 此后该位置仍被程序 _id_ 占用；

• 直到成功向 _r_ 位置写入数据，或遇到第一个正在被其他程序占用的位置为止， 此 时该操作立刻中断。

1 _id l r_ ：程序 _id_ 尝试删除磁盘中 \[_l_, _r_\] 位置上的所有数据。

• 这一操作当且仅当 \[_l_, _r_\] 区间内所有位置都正在被程序 _id_ 占用时才能成功执行。

• 执行效果为将其中所有位置都解除占用， 即恢复到可以被任意程序写入的状态。 但为了便于恢复数据，不会立即将全部位置重新覆盖成 0 。

• 否则，认为此操作执行失败，不进行任何修改。

2 _id l r_ ：程序 _id_ 尝试恢复磁盘中 \[_l_, _r_\] 位置上的所有数据。

• 这一操作当且仅当 \[_l_, _r_\] 区间内所有位置都未被占用，且上一次被占用是被程序 _id_ 占用时才能成功执行

• 执行效果为将其中所有位置恢复为被程序 _id_ 占用的状态， 同时由于之前删除操 作并未改变其存储的值，因此本次操作也不需要改变每个位置上的值。

• 否则，认为此操作执行失败，不进行任何修改。

3 _p_ ：尝试读取磁盘中 _p_ 位置的数据，返回结果为两个整数。

• 如果该位置当前正被程序 _id_ 占用且存储的值为 _p_ ，返回结果为 _id p_ 。

• 如果该位置当前没有被任何程序占用，返回 0 0 。

你需要实现一个程序，帮助小 C、小 S 和小 P 来模拟实现上述过程，并对于每个 操作输出操作结果。

【输入格式】

从标准输入读入数据。

第一行：3 个正整数 _n_, _m_, _k_ 。

接下来 _k_ 行，每行若干个整数描述一个操作，格式如上所述。

【输出格式】

输出到标准输出。

输出共 _k_ 行，对于每个操作输出一行。

对于每个写入操作， 输出一个整数表示此次操作写入成功的最右位置； 特别地如果 该操作一个位置也没有写入成功，输出 -1 。

对于每个删除、恢复操作， 若该操作成功，输出一个字符串 OK ，否则输出一个字 符串 FAIL 。

对于每个读取操作，输出两个整数表示此次查询的结果。

【样例 1 输入】

3 15 12

0 1 1 5 -1

0 2 10 13 2

0 1 4 14 6

1 1 2 8

3 1

3 3

3 14

2 1 3 5

0 3 7 8 -4

2 1 6 8

1 3 6 7

0 2 5 7 3

【样例 1 输出】

5

13

9

OK

1 -1

0 0

0 0

OK

8

FAIL

FAIL

\-1

【样例 2】

见题目目录下的 **_2.in_** 与 **_2.ans_**。

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

【子任务】

对于 25% 的数据，_n_, _k_ ≤ 2000, _m_ ≤ 10000 ；

对于另外 15% 的数据，没有删除、恢复操作；

对于另外 20% 的数据，没有恢复操作；

对于另外 15% 的数据，_n_ \= 1 。

对于 100% 的数据， 1 ≤ _n_, _k_ ≤ 2 × 105 , 1 ≤ _m_ ≤ 109 , 1 ≤ _id_ ≤ _n_, 1 ≤ _l_ ≤ _r_ ≤ _m_, 1 ≤ _p_ ≤ _m_, x ≤ 109 。

极差路径（min_max_path）

【题目背景】

众所周知，西西艾弗岛是一个旅游胜地， 但是由于兴建机场， 西西艾弗岛最近的财 务状况有点紧张。

【题目描述】

为了从游客手中获取更多的经济利润， 岛上仅有的三个小学生小 C、小 S 和小 P 建立了 _n_ 个景点，编号依次从 1 到 _n_。编号为 _i_ 的景点是第 _i_ 个被修建的。由于越到后 期经费越是不足，所以编号更大的景点通常更令人不满意——方便起见，假定编号为 _i_ 的景点的令人不满意程度是 _i_。

有些景点之间修有双向可通行的道路， 但是出于减少经费的考虑， 他们只修了能使 得所有景点连通的最少数量的道路，从而这些景点和其间的道路形成一棵树的结构。

对于每个游客而言， 由于只修了 _n_ \- 1 条道路，所以他只能沿着树上的边参观，并 且由于他不可能重复参观一个景点，所以他的游览路径一定是树上的一条简单路径。

现在西西艾弗岛希望制定一些推荐游览路径，但并非所有树上的路径都是合意的， 因为这条路径上的景点令人不满意程度的极差可能过大，使游客产生这些景点质量不 稳定的错觉。由于最开始的景点和最后的景点令人印象比较深刻， 所以游客通常会把游 览路径上的景点和这两个景点作比较。因此， 最令人不满意的景点不能比这两个景点差 太多，最优秀的景点也不能比这两个景点优秀太多。

具体来说，一条从 _x_ 到 _y_ 的游览路径（记作 (_x_, _y_)）是推荐的， 当且仅当下式成立：

min{_x_, _y_} - _k_1 ≤ min _P_(_x_, _y_) ≤ max _P_(_x_, _y_) ≤ max{_x_, _y_} + _k_2

其中 _P_(_x_, _y_) 表示一条从 _x_ 出发到达 _y_ 的简单路径上的点的令人不满意程度的数值的集 合（包括 _x_ 和 _y_，也就是 _x_ 到 _y_ 的简单路径上的点的编号的集合），min_S_ 和 max _S_ 分 别表示集合 _S_ 中的最小和最大值，_k_1, _k_2 是西西艾弗岛经过数次尝试后选取的两个给定 的参数，保证 _k_1, _k_2 ≥ 0。

特别的，容易验证 _x_ \= _y_ 时 (_x_, _y_) 总是推荐的。

现在西西艾弗岛想知道， 一共有多少树上的简单路径作为游览路径是被推荐的？ 这 里我们认为 (_x_, _y_) 和 (_y_, _x_) 是同一条路径。

【输入格式】

从标准输入读入数据。

第一行输入三个非负整数 _n_, _k_1, _k_2。

接下来 _n_ \- 1 行，每行两个正整数 _x_, _y_ 表示树上的一条边。

【输出格式】

输出到标准输出。

输出一行一个非负整数表示答案。

【样例 1 输入】

5 0 1

5 4

4 2

4 1

2 3

【样例 1 输出】

12

【样例 1 解释】

容易验证 (1, 1), (1, 4), (1, 5), (1, 3), (2, 2), (2, 4), (2, 5), (2, 3), (3, 3), (4, 4), (4, 5), (5, 5) 都 是推荐的游览路径，因此答案是 12。

【样例 2】

见题目目录下的 **_2.in_** 与 **_2.ans_**。

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

【样例 4】

见题目目录下的 **_4.in_** 与 **_4.ans_**。

【样例 5】

见题目目录下的 **_5.in_** 与 **_5.ans_**。

【样例 6】

见题目目录下的 **_6.in_** 与 **_6.ans_**。

【样例 7】

见题目目录下的 **_7.in_** 与 **_7.ans_**。

【样例 8】

见题目目录下的 **_8.in_** 与 **_8.ans_**。

【子任务】

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 测试点 | _n_ ≤ | _k_1 | _k_2 | 树的形态 | 堆性质 |
| 1   | 5, 000 | ≤ _n_ | ≤ _n_ | _A_3 | 无   |
| 2   |
| 3   |
| 4   | 5 × 105 | \= 0 | \= 0 | _A_1 | 有   |
| 5   | 无   |
| 6   | ≤ _n_ | 有   |
| 7   | 无   |
| 8   | ≤ _n_ | 有   |
| 9   | 无   |
| 10  | \= 0 | \= 0 | _A_2 |
| 11  | ≤ _n_ |
| 12  | ≤ _n_ |
| 13  | \= 0 | \= 0 | _A_3 | 有   |
| 14  | 无   |
| 15  |
| 16  |
| 17  | ≤ _n_ | 有   |
| 18  | 无   |
| 19  |
| 20  |
| 21  | ≤ _n_ | 有   |
| 22  |
| 23  | 无   |
| 24  |
| 25  |

对于 100% 的数据，1 ≤ _n_ ≤ 5 × 105 , 0 ≤ _k_1, _k_2,≤ _n_，保证输入的 _n_ − 1 条边一定构成 一棵树。

树的形态：

_A_1 ：树是一条链；

_A_2 ：存在一个度数为 _n_ − 1 的点；

_A_3 ：树的形态无特殊性质。

堆性质：若取编号为 1 的点为根，则除 1 号点外，每个点的编号都比其父节点的 编号大。

【提示】

请注意答案可能的取值范围。

第 **23** 次 **CCF** 计算机软件能力认证

2021.09

CSP202109

题目

时间：2021 年 9 月 19 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 数组推导 | 非零段划分 | 脉冲神经网 络 | 收集卡牌 | 箱根山岳险 天下 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 5.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 128 MiB |
| 测 试 点/包 数 目 | 10  | 10  | 3   | 10  | 10  |
| 测试点是否等 分 | 是   | 是   | 否   | 是   | 是   |

数组推导（array）

【题目描述】

_A_1, _A_2 , · · · , _An_ 是一个由 _n_ 个自然数（即非负整数）组成的数组。在此基础上， 我们 用数组 _B_1 · · · _Bn_ 表示 _A_ 的前缀最大值。

_Bi_ \= max {_A_1, _A_2 , · · · , _Ai_ }

如上所示，_Bi_ 定义为数组 _A_ 中前 _i_ 个数的最大值。根据该定义易知 _A_1 = _B_1 ，且随 着 _i_ 的增大，_Bi_ 单调不降。此外， 我们用 _sum_ \= _A_1 + _A_2 + · · · + _An_ 表示数组 _A_ 中 _n_ 个数 的总和。

现已知数组 _B_，我们想要根据 _B_ 的值来反推数组 _A_。显然， 对于给定的 _B_，_A_ 的取 值可能并不唯一。试计算，在数组 _A_ 所有可能的取值情况中，_sum_ 的最大值和最小值 分别是多少？

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 _n_。

输入的第二行包含 _n_ 个用空格分隔的自然数 _B_1, _B_2 , · · · , _Bn_。

【输出格式】

输出到标准输出。

输出共两行。

第一行输出一个整数，表示 _sum_ 的最大值。

第二行输出一个整数，表示 _sum_ 的最小值。

【样例 1 输入】

6

0 0 5 5 10 10

【样例 1 输出】

30

15

【样例 1 解释】

数组 _A_ 的可能取值包括但不限于以下三种情况。

情况一：_A_ \= \[0, 0, 5, 5, 10, 10\]

情况二：_A_ \= \[0, 0, 5, 3, 10, 4\]

情况三：_A_ \= \[0, 0, 5, 0, 10, 0\]

其中第一种情况 _sum_ \= 30 为最大值，第三种情况 _sum_ \= 15 为最小值。

【样例 2 输入】

7

10 20 30 40 50 60 75

【样例 2 输出】

285

285

【样例 2 解释】

_A_ \= \[10, 20, 30, 40, 50, 60, 75\] 是唯一可能的取值， 所以 _sum_ 的最大、最小值均为 285。

【子任务】

50% 的测试数据满足数组 _B_ 单调递增，即 0 < _B_1 < _B_2 < · · · < _Bn_ < 105；

全部的测试数据满足 _n_ ≤ 100 且数组 _B_ 单调不降，即 0 ≤ _B_1 ≤ _B_2 ≤ · · · ≤ _Bn_ ≤ 105。

非零段划分（split）

【题目描述】

_A_1, _A_2 , · · · , _An_ 是一个由 _n_ 个自然数（非负整数）组成的数组。我们称其中 _Ai_ , · · · , _Aj_ 是一个非零段，当且仅当以下条件同时满足：

• 1 ≤ _i_ ≤ _j_ ≤ _n_；

• 对于任意的整数 _k_，若 _i_ ≤ _k_ ≤ _j_，则 _Ak_ \> 0；

• _i_ \= 1 或 _Ai_−1 = 0；

• _j_ \= _n_ 或 _Aj_+1 = 0。

下面展示了几个简单的例子：

• _A_ \= \[3, 1, 2, 0, 0, 2, 0, 4, 5, 0, 2\] 中的 4 个非零段依次为 \[3, 1, 2\] 、\[2\] 、\[4, 5\] 和 \[2\]；

• _A_ \= \[2, 3, 1, 4, 5\] 仅有 1 个非零段；

• _A_ \= \[0, 0, 0\] 则不含非零段（即非零段个数为 0）。

现在我们可以对数组 _A_ 进行如下操作：任选一个正整数 _p_，然后将 _A_ 中所有小于 _p_ 的数都变为 0。试选取一个合适的 _p_，使得数组 _A_ 中的非零段个数达到最大。若输入 的 _A_ 所含非零段数已达最大值，可取 _p_ \= 1，即不对 _A_ 做任何修改。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 _n_。

输入的第二行包含 _n_ 个用空格分隔的自然数 _A_1, _A_2 , · · · , _An_。

【输出格式】

输出到标准输出。

仅输出一个整数，表示对数组 _A_ 进行操作后，其非零段个数能达到的最大值。

【样例 1 输入】

11

3 1 2 0 0 2 0 4 5 0 2

【样例 1 输出】

5

【样例 1 解释】

_p_ \= 2 时，_A_ \= \[3, 0, 2, 0, 0, 2, 0, 4, 5, 0, 2\] ，5 个非零段依次为 \[3\] 、\[2\] 、\[2\] 、\[4, 5\] 和 \[2\] ；此时非零段个数达到最大。

【样例 2 输入】

14

5 1 20 10 10 10 10 15 10 20 1 5 10 15

【样例 2 输出】

4

【样例 2 解释】

_p_ \= 12 时，_A_ \= \[0, 0, 20, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 15\] ，4 个非零段依次为 \[20\] 、\[15\]、

\[20\] 和 \[15\] ；此时非零段个数达到最大。

【样例 3 输入】

3

1 0 0

【样例 3 输出】

1

【样例 3 解释】

_p_ \= 1 时，_A_ \= \[1, 0, 0\]，此时仅有 1 个非零段 \[1\] ，非零段个数达到最大。

【样例 4 输入】

3

0 0 0

【样例 4 输出】

0

【样例 4 解释】

无论 _p_ 取何值，_A_ 都不含有非零段，故非零段个数至多为 0。

【子任务】

70% 的测试数据满足 _n_ ≤ 1000；

全部的测试数据满足 _n_ ≤ 5 × 105 ，且数组 _A_ 中的每一个数均不超过 104。

脉冲神经网络（snn）

【题目背景】

在本题中，你需要实现一个 SNN（spiking neural network，脉冲神经网络） 的模拟 器。一个 SNN 由以下几部分组成：

1\. 神经元：按照一定的公式更新内部状态，接受脉冲并可以发放脉冲

2\. 脉冲源：在特定的时间发放脉冲

3\. 突触：连接神经元-神经元或者脉冲源-神经元，负责传递脉冲

【题目描述】

神经元会按照一定的规则更新自己的内部状态。本题中， 我们对时间进行离散化处 理，即设置一个时间间隔 Δ_t_，仅考虑时间间隔整数倍的时刻 _t_ \= _k_Δ_t_(_k_ ∈ _Z_\+ )，按照下面 的公式，从 _k_ \- 1 时刻的取值计算 _k_ 时刻的变量的取值：

_vk_ \= _vk_\-1 + Δ_t_(0.04_v_ \-1 + 5_vk_\-1 + 140 - _uk_\-1 ) + _Ik_

_uk_ \= _uk_\-1 + Δ_ta_(_bvk_\-1 - _uk_\-1 )

其中 _v_ 和 _u_ 是神经元内部的变量， 会随着时间而变化， _a_ 和 _b_ 是常量，不会随着时 间变化；其中 _Ik_ 表示该神经元在 _k_ 时刻接受到的所有脉冲输入的强度之和，如果没有 接受到脉冲，那么 _Ik_ \= 0。当进行上面的计算后， 如果满足 _vk_ ≥ 30，神经元会发放一个 脉冲，脉冲经过突触传播到其他神经元； 同时，_vk_ 设为 _c_ 并且 _uk_ 设为 _uk_ \+ _d_，其中 _c_ 和 _d_ 也是常量。图 1 展示了一个神经元 _v_ 变量随时间变化的曲线。

20

Membrane potential (mV)

0

\- 20

\- 40

\- 60

\- 80

Neuron 0

Time (ms)

图 1: 神经元 _v_ 变量随时间变化的曲线

突触表示的是神经元-神经元、脉冲源-神经元的连接关系，包含一个入结点和一个 出结点（可能出现自环和重边）。当突触的入结点（神经元或者脉冲源）在 _k_ 时刻发放 一个脉冲，那么在传播延迟 _D_(_D_ \> 0) 个时刻以后，也就是在 _k_ \+ _D_ 时刻突触的出结点 （神经元）会接受到一个强度为 _w_ 的脉冲。

脉冲源在每个时刻以一定的概率发放一个脉冲，为了模拟这个过程， 每个脉冲源有 一个参数 0 < _r_ ≤ 32767，并统一采用以下的伪随机函数：

C++ 版本：

static unsigned long next = 1;

/\* RAND_\_MAX assumed to be 32767 \*/

int myrand(void) {

next = next \* 1103515245 + 12345;

return((unsigned)(next/65536) % 32768); }

Python 版本：

next = 1

def myrand():

global next

next = (next \* 1103515245 + 12345) % (2 \*\* 64) return (next // 65536) % 32768

Java 版本：

long next = 1; int myrand() {

next = next \* 1103515245 + 12345;

return (int)((Long.divideUnsigned(next, 65536)) % 32768); }

在每个时间刻，按照编号顺序从小到大，每个脉冲源调用一次上述的伪随机函数， 当 _r_ \> myrand() 时，在当前时间刻发放一次脉冲，并通过突触传播到神经元。

进行仿真的时候， 已知 0 时间刻各个神经元的状态，从 1 时间刻开始按照上述规 则进行计算，直到完成 _T_ 时刻的计算，再输出 _T_ 时刻神经元的 _v_ 值和发放的脉冲次数 分别的最小值和最大值。

规定输入数据中结点按如下方式顺序编号： \[0, _N_ \-1\] 为神经元的编号，\[_N_, _N_ \+ _P_\-1\] 为脉冲源的编号。

代码中请使用双精度浮点类型。

【输入格式】

从标准输入读入数据。

输入的第一行包括四个以空格分隔的正整数 _N S P T_，表示一共有 _N_ 个神经元，_S_ 个突触和 _P_ 个脉冲源，输出时间刻 _T_ 时神经元的 _v_ 值。

输入的第二行是一个正实数 Δ_t_，表示时间间隔。

输入接下来的若干行， 每行有以空格分隔的一个正整数 _RN_ 和六个实数 _vu abc d_， 按顺序每一行对应 _RN_ 个具有相同初始状态和常量的神经元：其中 _v u_ 表示神经元在时 刻 0 时的变量取值；_a b c d_ 为该神经元微分方程里的四个常量。保证所有的 _RN_ 加起 来等于 _N_。它们从前向后按编号顺序描述神经元，每行对应一段连续编号的神经元的 信息。

输入接下来的 _P_ 行，每行是一个正整数 _r_，按顺序每一行对应一个脉冲源的_r_ 参数。

输入接下来的 _S_ 行，每行有以空格分隔的两个整数 _s_(0 ≤ _s_ < _N_ \+ _P_) 、_t_(0 ≤ _t_ < _N_) 、 一个实数 _w_(_w_ ≥ 0) 和一个正整数 _D_，其中 _s_ 和 _t_ 分别是入结点和出结点的编号；_w_ 和 _D_ 分别表示脉冲强度和传播延迟。

【输出格式】

输出到标准输出。

输出共有两行，第一行由两个近似保留 3 位小数的实数组成，分别是所有神经元 在时刻 _T_ 时变量 _v_ 的取值的最小值和最大值。第二行由两个整数组成，分别是所有神 经元在整个模拟过程中发放脉冲次数的最小值和最大值。

只要按照题目要求正确实现就能通过，不会因为计算精度的问题而得到错误答案。

【样例 1 输入】

1 1 1 10

0.1

1 -70.0 -[14.0 0.02 0.2](14.00.020.2) -65.0 2.0

30000

1 0 30.0 2

【样例 1 输出】

\-35.608 -35.608

2 2

【样例 1 解释】

该样例有 1 个神经元、 1 个突触和 1 个脉冲源， 时间间隔 Δ_t_ \= 0. 1。唯一的脉冲源 通过脉冲强度为 30.0、传播延迟为 2 的突触传播到唯一的神经元。

该样例一共进行 10 个时间步的模拟，随机数生成器生成 10 次随机数如下：

16838

5758

10113

17515

31051

5627

23010

7419

16212

4086

因此唯一的脉冲源在时刻 1-4 和 6-10 发放脉冲。在时间刻从 1 到 10 时，唯一的 神经元的 _v_ 取值分别为：

\-70.000

\-70.000

\-40.000

\-8.200

\-65.000

\-35.404

\-32.895

0.181

\-65.000

\-35.608

该神经元在时刻 5 和时刻 9 发放，最终得到的 _v_ \= -35.608 。

【样例 2 输入】

2 4 2 10 0.1

1 -70.0 -[14.0 0.02 0.2](14.00.020.2) -65.0 2.0 1 -69.0 -[13.0 0.04 0.1](13.00.040.1) -60.0 1.0 30000

20000

2 0 15.0 1 3 1 20.0 1 1 0 10.0 2

0 1 40.0 3

【样例 2 输出】

\-60.000 -22.092

1 2

【子任务】

|     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- |
| 子任务 | _T_ | _N_ | _S_ | _P_ | _D_ | 分值  |
| 1   | ≤ 102 | ≤ 102 | ≤ 102 | ≤ 102 | ≤ 102 | 30  |
| 2   | ≤ 103 | ≤ 103 | ≤ 103 | ≤ 103 | ≤ 103 | 40  |
| 3   | ≤ 105 | ≤ 10 | 30  |

收集卡牌（collect）

【题目描述】

小林在玩一个抽卡游戏，其中有 _n_ 种不同的卡牌， 编号为 1 到 _n_。每一次抽卡，她 获得第 _i_ 种卡牌的概率为 _pi_。如果这张卡牌之前已经获得过了，就会转化为一枚硬币。 可以用 _k_ 枚硬币交换一张没有获得过的卡。

小林会一直抽卡，直至集齐了所有种类的卡牌为止， 求她的期望抽卡次数。如果你 给出的答案与标准答案的绝对误差不超过 10-4，则视为正确。

提示：聪明的小林会把硬币攒在手里，等到通过兑换就可以获得剩余所有卡牌时， 一次性兑换并停止抽卡。

【输入格式】

从标准输入读入数据。

输入共两行。第一行包含两个用空格分隔的正整数 _n_, _k_，第二行给出 _p_1, _p_2 , . . . , _pn_， 用空格分隔。

【输出格式】

输出到标准输出。

输出共一行，一个实数，即期望抽卡次数。

【样例 1 输入】

2 2

0.4 0.6

【样例 1 输出】

2.52

【样例 1 解释】

共有 2 种卡牌，不妨记为 A 和 B，获得概率分别为 0.4 和 0.6 ，2 枚硬币可以换一 张卡牌。下面给出各种可能出现的情况：

• 第一次抽卡获得 A，第二次抽卡获得 B，抽卡结束，概率为 0.4 × 0.6 = 0.24，抽 卡次数为 2。

• 第一次抽卡获得 A，第二次抽卡获得 A，第三次抽卡获得 B，抽卡结束，概率为 0.4 × 0.4 × 0.6 = 0.096，抽卡次数为 3。

• 第一次抽卡获得 A，第二次抽卡获得 A，第三次抽卡获得 A，用硬币兑换 B，抽 卡结束，概率为 0.4 × 0.4 × 0.4 = 0.064，抽卡次数为 3。

• 第一次抽卡获得 B，第二次抽卡获得 A，抽卡结束，概率为 0.6 × 0.4 = 0.24，抽 卡次数为 2。

• 第一次抽卡获得 B，第二次抽卡获得 B，第三次抽卡获得 A，抽卡结束，概率为 0.6 × 0.6 × 0.4 = 0. 144，抽卡次数为 3。

• 第一次抽卡获得 B，第二次抽卡获得 B，第三次抽卡获得 B，用硬币兑换 A，抽 卡结束，概率为 0.6 × 0.6 × 0.6 = 0.216，抽卡次数为 3。

因此答案是 0.24 × 2 + 0.096 × 3 + 0.064 × 3 + 0.24 × 2 + 0.144 × 3 + 0.216 × 3 = 2.52。

【样例 2 输入】

4 3

0.006 0.1 0.2 0.694

【样例 2 输出】

7.3229920752

【子任务】

对于 20% 的数据，保证 1 ≤ _n_, _k_ ≤ 5。

对于另外 20% 的数据，保证所有 _pi_ 是相等的。

对于 100% 的数据， 保证 1 ≤ _n_ ≤ 16, 1 ≤ _k_ ≤ 5，所有的 _pi_ 满足  且 

箱根山岳险天下（hakone）

【题目背景】

“你知道对长跑选手来说，最棒的赞美是什么吗？”

“是‘快’吗？”

“不， 是‘强’，”清濑说，“光跑得快，是没办法在长跑中脱颖而出的。天 候、场地、比赛的发展、体能， 还有自己的精神状态——长跑选手必须冷静 分析这许多要素， 即使面对再大的困难， 也要坚忍不拔地突破难关。长跑选 手需要的，是真正的‘强’。所以我们必须把‘强’当作最高的荣誉，每天 不断跑下去。”

不论阿走或其他房客，全都全神贯注地聆听清濑的话。

“看了你这三个月来的表现， 我越来越相信自己没看错人，”清濑接着说，“你 很有天分，也很有潜力。所以呢， 阿走，你一定要更相信自己， 不要急着想 一飞冲天。变强需要时间， 也可以说它永远没有终点。长跑是值得一生投入 的竞赛，有些人即使老了，仍然没有放弃慢跑或马拉松运动。”

——三浦紫苑《强风吹拂》

箱根驿传（正式名称为东京箱根间往复大学驿传竞走）是日本一项在每年 1 月 2-3 日举行的驿站接力赛， 由关东学生田径联盟主办， 关东的每所高校都有机会参加。在日 本，箱根驿传是新年假期必看的比赛，许多家庭会一边吃年糕汤一边欣赏激烈的比赛。

今年，京都大学也想派出长跑队参加箱根驿传， 田径部的长跑教练组织起一批预备 役运动员，并开展了严苛的训练。

【题目描述】

京都大学的训练一共会持续 _m_ 天，在训练过程中正式队员的名单可能发生变化。 简单起见，我们约定在且仅在第 _t_(1 ≤ _t_ ≤ _m_) 天结束时，会有以下三种事件之一发生：

1\. 有一个学生跑 10km 的速度达到了正式队员要求， 教练将其作为最后一名纳入正 式队员的名单中，这个学生的强度为 _x_；或者速度排名在最后一位的正式队员， 由于速度过慢，而被从正式队员的名单中淘汰。

• 在训练过程中， 我们假定队员的速度的相对排名不会发生变化， 与强度无 关。

• 严苛的教练制订了残酷的规则：被淘汰的学生虽然依然会跟大家一起训 练，但将不能再次加入本年度参加箱根驿传的正式队员的名单中。

2\. 由于近日的训练，第 _s_ 天结束时速度排名为 _l_ 至 _r_ 的选手的强度有了变化， 变为 此前的 _y_ 倍。

3\. 教练在深夜想知道近日训练的效果， 于是他统计了第 _s_ 天结束时速度排名为 _l_ 至 _r_ 的选手目前（即第 _t_ 天结束时）强度的和。由于这个结果可能很大，方便起见 我们只考虑其模 _p_ 的值。

出于学生们的隐私考虑，事件日志有可能会被加密。

【输入格式】

从标准输入读入数据。

第一行为三个用空格隔开的整数 _m_ ，_p_ 和 _T_。

如果 _T_ \= 0，事件 1 中 _x_ \= _x_′ ，事件 2 中 _y_ \= _y_′ ；如果 _T_ \= 1，表示事件日志被加密 了，事件 1 中 _x_ \= _x_′ ⊕ _A_，事件 2 中 _y_ \= _y_′ ⊕ _A_，其中 ⊕ 为按位异或运算，_A_ 为此前最后 一次事件 3 所统计出的结果。如果此前没有事件 3 发生，则 _A_ \= 0。

接下来 _m_ 行，第 _t_ 行表示在第 _t_ 天结束时发生的事件：

• 1 _x_′ ：表示事件 1 发生。若 _x_ \> 0，表示有一个强度为 _x_ 的学生作为最后一名纳 入正式队员的名单；若 _x_ \= 0，表示排名在最后的正式队员被从名单中淘汰。保 证有 0 ≤ _x_′ < 230。

• 2 _s l r y_′ ：表示事件 2 发生。保证有 1 ≤ _s_ ≤ _t_ ，1 ≤ _l_ ≤ _r_ ≤ _n_ ，0 ≤ _y_′ < 230 ，其中 _n_ 为在第 _s_ 天结束时正式队员的人数。

• 3 _s l r_：表示事件 3 发生。保证有 1 ≤ _s_ ≤ _t_ ，1 ≤ _l_ ≤ _r_ ≤ _n_，其中 _n_ 为在第 _s_ 天结 束时正式队员的人数。

【输出格式】

输出到标准输出。

对于每一个事件 3，输出一行一个数字，为其所统计出的结果。

【样例 1 输入】

8 10 0

1 7

1 3

1 0

1 4

2 4 1 2 2

3 2 1 2

2 1 1 1 3

3 6 1 2

【样例 1 输出】

7

0

【样例 1 解释】

第 1 天结束时，有一个强度为 7 的学生被列为正式队员， 我们不妨称他为小津。此 时正式队员名单依次为：小津。

第 2 天结束时，有一个强度为 3 的学生被列为正式队员， 我们不妨称他为城崎。此 时正式队员名单依次为：小津、城崎。

第 3 天结束时，城崎被淘汰了。此时正式队员名单为：小津。

第 4 天结束时，有一个强度为 4 的学生被列为正式队员，我们不妨称他为樋口清 太郎。此时正式队员名单依次为：小津、樋口清太郎。

第 5 天结束时， 由于近日的训练，第 4 天正式队员名单中第 1 至 2 个人——即小 津和樋口清太郎——的强度乘了 2，所以，小津的强度达到了 14，樋口清太郎的强度 达到了 8。

第 6 天结束时，教练统计了第 2 天正式队员名单中第 1 至 2 个人——即小津和城 崎——当前的强度，小津的强度为 14，城崎的强度为 3，故统计结果为 17，模 _p_ 的值 为 7。

第 7 天结束时， 由于近日的训练，第 1 天正式队员名单中的第 1 个人——即小津 ——的强度乘了 3，所以，小津的强度达到了 42。

第 8 天结束时，教练统计了第 6 天正式队员名单中第 1 至 2 个人——即小津和樋 口清太郎——当前的强度，小津的强度为 42，樋口清太郎的强度为 8，故统计结果为 50，模 _p_ 的值为 0。

【样例 2 输入】

200 307854322 1

1 304192542

1 261749745

1 227234660

1 258761107

1 71490397

1 72584186

1 172113773

1 170623186

1 109308637

1 108383253

1 221430535

1 184520171

1 12820964

1 64943840

1 271383631

1 103269159

1 12002213

1 141551258

1 200255671

1 303679342

1 177153246

1 242934504

1 192722694

1 81041418

1 129449540

1 208869479

1 193883084

1 47265951

1 14844237

1 204331401

1 120715260

1 183356222

1 151061115

1 97645108

1 95770509

1 10891614

1 136365751

1 277592250

1 244161106

1 74405936

1 140365146

1 22587603

1 172441554

1 300179553

1 235367849

1 75467014

1 291045594

1 220071302

1 26967280

1 279868778

1 109902396

1 286509675

1 275417760

1 74253569

1 57318310

1 147462465

1 89999340

1 17784677

1 245244350

1 138709004

1 214478013

1 134244031

1 298548097

1 17276277

1 183802269

1 22366514

1 275904549

1 142230969

1 116156399

1 63581175

1 136336228

1 214860504

1 72329372

1 204231581

1 78276583

1 277642488

1 81760292

1 7831561

1 134535873

1 42237141

1 165620849

1 286362129

1 87388726

1 288617590

1 97675237

1 113222505

1 292912

1 98092392

1 257549905

1 180583994

1 244157382

1 117371320

1 304810612

1 148813285

1 150599985

1 229632823

1 246806551

1 297736161

1 66536628

1 70165839

1 31086027

1 0

1 46984478

1 0

3 13 2 11

1 134407869

1 134407869

2 73 7 31 130418473

1 134407869

1 62804642

1 134407869

1 134407869

3 28 12 21

1 173819539

3 93 34 83

3 68 5 38

1 95422722

2 85 54 85 89788932

2 28 2 25 251954506

1 185543612

1 34466375

1 185543612

2 28 2 13 51844756

3 43 22 33

3 97 5 87

1 53569742

1 83590412

1 53569742

2 1 1 1 131620724

2 128 5 72 41971821

1 53569742

1 197197823

1 333156690

3 59 48 50

1 224641252

1 24037560

3 54 26 40

2 91 7 37 58105019

2 59 4 50 254285874

3 112 17 63

3 103 53 54

3 3 1 3

3 4 4 4

2 121 68 76 258392700

2 88 55 59 10180251

2 110 45 76 125533148

1 160394017

1 170735200

3 51 18 34

3 136 43 64

1 49346652

1 114223193

3 62 17 26

3 57 8 40

1 278848254

1 278848254

1 411603847

1 278848254

1 278848254

1 278848254

2 112 70 79 437553006

2 120 4 89 428224488

3 53 50 51

2 109 36 81 205513848

3 81 31 46

3 78 45 64

2 107 19 28 8661353

3 36 21 33

2 28 4 28 227981470

2 42 18 29 7067955

1 1536382

1 214941299

1 176373062

2 172 26 74 241772251

1 21368911

2 61 50 61 37266210

3 84 30 48

3 31 8 24

1 297156062

1 328205831

2 175 57 77 408989526

1 528105214

2 30 4 24 416690156

3 9 4 8

1 31664726

3 144 40 67

1 276474902

2 115 56 72 15951722

2 187 6 50 38653155

1 17582098

1 276474902

1 415944350

3 34 1 24

1 204461450

2 136 1 59 92444637

3 79 7 79

3 22 2 17

1 284506459

2 166 78 86 22058413

1 30931926

【样例 2 输出】

134407869

184056088

13293385

185543612

34566045

53569742

224641252

2971977

10689074

196073568

220349662

170735200

273278086

25664733

155812556

278848254

238098134

256392602

172981220

1536382

57033232

297156062

31664726

276474902

204461450

168966052

30931926

【子任务】

1 ≤ _m_ ≤ 3 × 105 , 2 ≤ _p_ < 230 , _mode_ ∈ {0, 1}

|     |     |     |
| --- | --- | --- |
| 测试点 | 特殊性质 | _mode_ |
| 1   | _m_ ≤ 5000 | 1   |
| 2   | 事件 1 中 _x_ \> 0 |
| 3   | 没有事件 2 |
| 4   | 事件 1 中 _x_ 在 {0, 1} 中随机选取 | 0   |
| 5   | _r_ \- _l_ ≤ 10 |
| 6   | 1   |
| 7, 8 | 无   | 0   |
| 9, 10 | 1   |

每个测试点占 10 分。

第 **22** 次 **CCF CSP** 软件能力认证

CCF CSP

时间：2021 年 4 月 11 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 灰度直方图 | 邻域均值 | DHCP 服 务器 | 校门外的树 | 疫苗运输 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 5   | 10  | 10  | 10  | 20  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

灰度直方图（histogram）

【题目描述】

一幅长宽分别为 _n_ 个像素和 _m_ 个像素的灰度图像可以表示为一个 _n_ × _m_ 大小的 矩阵 _A_。其中每个元素 _Aij_（0 ≤ _i_ < _n_ 、0 ≤ _j_ < _m_）是一个 \[0, _L_) 范围内的整数，表示 对应位置像素的灰度值。具体来说，一个 8 比特的灰度图像中每个像素的灰度范围是 \[0, 128)。

一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为 _L_ 的数组 _h_，其中 _h_\[_x_\]（0 ≤ _x_ < _L_）表示该图像中灰度值为 _x_ 的像素个数。显然， _h_\[0\] 到 _h_\[_L_ − 1\] 的总和应等于图像中的像素总数 _n_ · _m_。

已知一副图像的灰度矩阵 _A_，试计算其灰度直方图 _h_\[0\], _h_\[1\], · · · , _h_\[_L_ − 1\]。

【输入格式】

从标准输入读入数据。

输入共 _n_ \+ 1 行。

输入的第一行包含三个用空格分隔的正整数 _n_ 、_m_ 和 _L_，含义如前文所述。

第二到第 _n_ \+ 1 行输入矩阵 _A_。第 _i_ \+ 2（0 ≤ _i_ < _n_）行包含用空格分隔的 _m_ 个整数， 依次为 _Ai_0, _Ai_1 , · · · , _Ai_(_m_−1)。

【输出格式】

输出到标准输出。

输出仅一行，包含用空格分隔的 _L_ 个整数 _h_\[0\], _h_\[1\], · · · , _h_\[_L_ − 1\]，表示输入图像的 灰度直方图。

【样例 1 输入】

4 4 16

0 1 2 3

4 5 6 7

8 9 10 11

12 13 14 15

【样例 1 输出】

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

【样例 2 输入】

7 11 8

0 7 0 0 0 7 0 0 7 7 0

7 0 7 0 7 0 7 0 7 0 7

7 0 0 0 7 0 0 0 7 0 7

7 0 0 0 0 7 0 0 7 7 0

7 0 0 0 0 0 7 0 7 0 0

7 0 7 0 7 0 7 0 7 0 0

0 7 0 0 0 7 0 0 7 0 0

【样例 2 输出】

48 0 0 0 0 0 0 29

【子任务】

全部的测试数据满足 0 < _n_, _m_ ≤ 500 且 4 ≤ _L_ ≤ 256。

邻域均值（localavg）

【题目背景】

顿顿在学习了数字图像处理后， 想要对手上的一副灰度图像进行降噪处理。不过该 图像仅在较暗区域有很多噪点， 如果贸然对全图进行降噪， 会在抹去噪点的同时也模糊 了原有图像。因此顿顿打算先使用邻域均值来判断一个像素是否处于较暗区域，然后仅 对处于较暗区域的像素进行降噪处理。

【题目描述】

待处理的灰度图像长宽皆为 _n_ 个像素，可以表示为一个 _n_ × _n_ 大小的矩阵 _A_，其中 每个元素是一个 \[0, _L_) 范围内的整数， 表示对应位置像素的灰度值。对于矩阵中任意一 个元素 _Aij_（0 ≤ _i_, _j_ < _n_），其邻域定义为附近若干元素的集和：

_Neighbor_(_i_, _j_, _r_) = {_Axy_ | 0 ≤ _x_, _y_ < _n_ and |_x_ \- _i_| ≤ _r_ and |_y_ \- _j_| ≤ _r_}

这里使用了一个额外的参数 _r_ 来指明 _Aij_ 附近元素的具体范围。根据定义， 易知 _Neighbor_(_i_, _j_, _r_) 最多有 (2_r_ \+ 1)2 个元素。

如果元素 _Aij_ 邻域中所有元素的平均值小于或等于一个给定的阈值 _t_ ，我们就认为 该元素对应位置的像素处于较暗区域。下图给出了两个例子， 左侧图像的较暗区域在右 侧图像中展示为黑色，其余区域展示为白色。

n = 217, L = 256

r = 3, t = 85

n = 512, L = 256

r = 3, t = 125

现给定邻域参数 _r_ 和阈值 _t_，试统计输入灰度图像中有多少像素处于较暗区域。

【输入格式】

从标准输入读入数据。

输入共 _n_ \+ 1 行。

输入的第一行包含四个用空格分隔的正整数 _n_ 、_L_ 、_r_ 和 _t_，含义如前文所述。

第二到第 _n_ \+ 1 行输入矩阵 _A_。第 _i_ \+ 2（0 ≤ _i_ < _n_）行包含用空格分隔的 _n_ 个整数， 依次为 _Ai_0, _Ai_1 , · · · , _Ai_(_n_−1)。

【输出格式】

输出到标准输出。

输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。

【样例 1 输入】

4 16 1 6

0 1 2 3

4 5 6 7

8 9 10 11

12 13 14 15

【样例 1 输出】

7

【样例 2 输入】

11 8 2 2

0 0 0 0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0 0 0 0

0 7 0 0 0 7 0 0 7 7 0

7 0 7 0 7 0 7 0 7 0 7

7 0 0 0 7 0 0 0 7 0 7

7 0 0 0 0 7 0 0 7 7 0

7 0 0 0 0 0 7 0 7 0 0

7 0 7 0 7 0 7 0 7 0 0

0 7 0 0 0 7 0 0 7 0 0

0 0 0 0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0 0 0 0

【样例 2 输出】

83

【子任务】

70% 的测试数据满足 _n_ ≤ 100 、_r_ ≤ 10。

全部的测试数据满足 0 < _n_ ≤ 600 、0 < _r_ ≤ 100 且 2 ≤ _t_ < _L_ ≤ 256。

DHCP 服务器（DHCP）

【题目背景】

动态主机配置协议（Dynamic Host Conﬁguration Protocol, DHCP）是一种自动为 网络客户端分配 IP 地址的网络协议。当支持该协议的计算机刚刚接入网络时，它可以 启动一个 DHCP 客户端程序。后者可以通过一定的网络报文交互， 从 DHCP 服务器上 获得 IP 地址等网络配置参数，从而能够在用户不干预的情况下， 自动完成对计算机的 网络设置，方便用户连接网络。 DHCP 协议的工作过程如下：

1\. 当 DHCP 协议启动的时候， DHCP 客户端向网络中广播发送 Discover 报文，请 求 IP 地址配置；

2\. 当 DHCP 服务器收到 Discover 报文时，DHCP 服务器根据报文中的参数选择一 个尚未分配的 IP 地址，分配给该客户端。DHCP 服务器用 Oﬀer 报文将这个信 息传达给客户端；

3\. 客户端收集收到的 Oﬀer 报文。由于网络中可能存在多于一个 DHCP 服务器，因 此客户端可能收集到多个 Oﬀer 报文。客户端从这些报文中选择一个，并向网络 中广播 Request 报文，表示选择这个 DHCP 服务器发送的配置；

4\. DHCP 服务器收到 Request 报文后，首先判断该客户端是否选择本服务器分配 的地址：如果不是，则在本服务器上解除对那个 IP 地址的占用；否则则再次确 认分配的地址有效，并向客户端发送 Ack 报文，表示确认配置有效，Ack 报文 中包括配置的有效时间。如果 DHCP 发现分配的地址无效，则返回 Nak 报文；

5\. 客户端收到 Ack 报文后，确认服务器分配的地址有效， 即确认服务器分配的地 址未被其它客户端占用， 则完成网络配置， 同时记录配置的有效时间， 出于简化 的目的，我们不考虑被占用的情况。若客户端收到 Nak 报文，则从步骤 1 重新 开始；

6\. 客户端在到达配置的有效时间前，再次向 DHCP 服务器发送 Request 报文，表 示希望延长 IP 地址的有效期。 DHCP 服务器按照步骤 4 确定是否延长， 客户端 按照步骤 5 处理后续的配置；

在本题目中，你需要理解 DHCP 协议的工作过程，并按照题目的要求实现一个简 单的 DHCP 服务器。

【题目描述】

报文格式

为了便于实现，我们简化地规定 DHCP 数据报文的格式如下：

&lt; 发送主机&gt; &lt; 接收主机&gt; &lt; 报文类型&gt; &lt;IP 地址&gt; &lt; 过期时刻&gt;

DHCP 数据报文的各个部分由空格分隔，其各个部分的定义如下：

• 发送主机：是发送报文的主机名， 主机名是由小写字母、数字组成的字符串， 唯 一地表示了一个主机；

• 接收主机： 当有特定的接收主机时， 是接收报文的主机名； 当没有特定的接收主 机时，为一个星号（ \*）；

• 报文类型：是三个大写字母，取值如下：

**\-** DIS：表示 Discover 报文；

**\-** OFR：表示 Oﬀer 报文；

**\-** REQ：表示 Request 报文；

**\-** ACK：表示 Ack 报文；

**\-** NAK：表示 Nak 报文；

• IP 地址，是一个非负整数：

**\-** 对于 Discover 报文，该部分在发送的时候为 0，在接收的时候忽略；

**\-** 对于其它报文，为正整数，表示一个 IP 地址；

• 过期时刻，是一个非负整数：

**\-** 对于 Oﬀer 、Ack 报文，是一个正整数，表示服务器授予客户端的 IP 地址 的过期时刻；

**\-** 对于 Discover 、Request 报文，若为正整数， 表示客户端期望服务器授予的 过期时刻；

**\-** 对于其它报文，该部分在发送的时候为 0 ，在接收的时候忽略。 例如下列都是合法的 DHCP 数据报文：

a \* DIS 0 0

d a ACK 50 1000

服务器配置

为了 DHCP 服务器能够正确分配 IP 地址，DHCP 需要接受如下配置：

• 地址池大小 _N_：表示能够分配给客户端的 IP 地址的数目，且能分配的 IP 地址 是 1, 2, . . . , _N_；

• 默认过期时间 _Tdef_：表示分配给客户端的 IP 地址的默认的过期时间长度；

• 过期时间的上限和下限 _Tmax_ 、_Tmin_：表示分配给客户端的 IP 地址的最长过期时 间长度和最短过期时间长度，客户端不能请求比这个更长或更短的过期时间；

• 本机名称 _H_：表示运行 DHCP 服务器的主机名。

分配策略

当客户端请求 IP 地址时，首先检查此前是否给该客户端分配过 IP 地址，且该 IP 地址在此后没有被分配给其它客户端。如果是这样的情况， 则直接将 IP 地址分配给它， 否则，总是分配给它最小的尚未占用过的那个 IP 地址。如果这样的地址不存在，则分 配给它最小的此时未被占用的那个 IP 地址。如果这样的地址也不存在，说明地址池已 经分配完毕，因此拒绝分配地址。

实现细节

在 DHCP 启动时，首先初始化 IP 地址池，将所有地址设置状态为未分配， 占用 者为空，并清零过期时刻。其中地址的状态有未分配、待分配、占用、过期四种。处于 未分配状态的 IP 地址没有占用者，而其余三种状态的 IP 地址均有一名占用者。处于 待分配和占用状态的 IP 地址拥有一个大于零的过期时刻。在到达该过期时刻时，若该 地址的状态是待分配， 则该地址的状态会自动变为未分配， 且占用者清空，过期时刻清 零；否则该地址的状态会由占用自动变为过期， 且过期时刻清零。处于未分配和过期状 态的 IP 地址过期时刻为零，即没有过期时刻。

对于收到的报文，设其收到的时刻为 _t_。处理细节如下：

1\. 判断接收主机是否为本机，或者为 \* ，若不是，则判断类型是否为 Request，若 不是，则不处理；

2\. 若类型不是 Discover 、Request 之一，则不处理；

3\. 若接收主机为 \* ，但类型不是 Discover，或接收主机是本机， 但类型是 Discover， 则不处理。

对于 Discover 报文，按照下述方法处理：

1\. 检查是否有占用者为发送主机的 IP 地址：

• 若有，则选取该 IP 地址；

• 若没有，则选取最小的状态为未分配的 IP 地址；

• 若没有，则选取最小的状态为过期的 IP 地址；

• 若没有，则不处理该报文，处理结束；

2\. 将该 IP 地址状态设置为待分配，占用者设置为发送主机；

3\. 若报文中过期时刻为 0 ，则设置过期时刻为 _t_ \+ _Tdef_ ；否则根据报文中的过期时 刻和收到报文的时刻计算过期时间， 判断是否超过上下限： 若没有超过，则设置 过期时刻为报文中的过期时刻；否则则根据超限情况设置为允许的最早或最晚 的过期时刻；

4\. 向发送主机发送 Oﬀer 报文，其中，IP 地址为选定的 IP 地址，过期时刻为所设 定的过期时刻。

对于 Request 报文，按照下述方法处理：

1\. 检查接收主机是否为本机：

• 若不是，则找到占用者为发送主机的所有 IP 地址，对于其中状态为待分配的， 将其状态设置为未分配，并清空其占用者，清零其过期时刻，处理结束；

2\. 检查报文中的 IP 地址是否在地址池内，且其占用者为发送主机，若不是，则向 发送主机发送 Nak 报文，处理结束；

3\. 无论该 IP 地址的状态为何，将该 IP 地址的状态设置为占用；

4\. 与 Discover 报文相同的方法，设置 IP 地址的过期时刻；

5\. 向发送主机发送 Ack 报文。

上述处理过程中，地址池中地址的状态的变化可以概括为如下图所示的状态转移 图。为了简洁，该图中没有涵盖需要回复 Nak 报文的情况。

DIS，设置定时器，发 OFR

DIS，设置定时器， 发 OFR

未分配

待分配

DIS，设置定时器， 发 OFR

DIS，设置定时器， 发 OFR

占用 过期

REQ，设定定时器， 发 ACK

定时器到期

待分配

未分配

REQ（非本机）， 清定时器

REQ，设定定时器， 发 ACK

过期

占用

REQ，设定定时器， 发 ACK

定时器到期

图 1: 地址状态转移图

【输入格式】

从标准输入读入数据。

输入的第一行包含用空格分隔的四个正整数和一个字符串，分别是：_N_、_Tdef_ 、_Tmax_、 _Tmin_ 和 _H_，保证 _Tmin_ ≤ _Tdef_ ≤ _Tmax_。

输入的第二行是一个正整数 _n_，表示收到了 _n_ 个报文。

输入接下来有 _n_ 行，第 (_i_ \+ 2) 行有空格分隔的正整数 _ti_ 和约定格式的报文 _Pi_。表 示收到的第 _i_ 个报文是在 _ti_ 时刻收到的，报文内容是 _Pi_。保证 _ti_ < _ti_+1。

【输出格式】

输出到标准输出。

输出有若干行， 每行是一个约定格式的报文。依次输出 DHCP 服务器发送的报文。

【样例 1 输入】

4 5 10 5 dhcp

16

1 a \* DIS 0 0

2 a dhcp REQ 1 0

3 b a DIS 0 0

4 b \* DIS 3 0

5 b \* REQ 2 12

6 b dhcp REQ 2 12

7 c \* DIS 0 11

8 c dhcp REQ 3 11

9 d \* DIS 0 0

10 d dhcp REQ 4 20

11 a dhcp REQ 1 20

12 c dhcp REQ 3 20

13 e \* DIS 0 0

14 e dhcp REQ 2 0

15 b dhcp REQ 2 25

16 b \* DIS 0 0

【样例 1 输出】

dhcp a OFR 1 6

dhcp a ACK 1 7

dhcp b OFR 2 9

dhcp b ACK 2 12

dhcp c OFR 3 12

dhcp c ACK 3 13

dhcp d OFR 4 14

dhcp d ACK 4 20

dhcp a ACK 1 20

dhcp c ACK 3 20

dhcp e OFR 2 18

dhcp e ACK 2 19

dhcp b NAK 2 0

【样例 1 解释】

输入第一行，分别设置了 DHCP 的相关参数，并收到了 16 个报文。

第 1 个报文和第 2 个报文是客户端 a 正常请求地址，服务器为其分配了地址 1，相 应地设置了过期时刻是 7 （即当前时刻 2 加上默认过期时间 5）。

第 3 个报文不符合 Discover 报文的要求，不做任何处理。

第 4 个报文 b 发送的 Discover 报文虽然有 IP 地址 3，但是按照处理规则， 这个字 段被忽略，因此服务器返回 Oﬀer 报文，过期时刻是 9。

第 5 个报文中，Request 报文不符合接收主机是 DHCP 服务器本机的要求， 因此 不做任何处理。

第 6 个报文是 b 发送的 Request 报文，其中设置了过期时刻是 12，没有超过最长 过期时间，因此返回的 Ack 报文中过期时刻也是 12。

第 7 个报文中，过期时刻 11 小于最短过期时间， 因此返回的过期时刻是 12。虽然 此时为 a 分配的地址 1 过期，但是由于还有状态为未分配的地址 3，因此为 c 分配地 址 3。第 8 个报文同理，为 c 分配的地址过期时刻是 13。

第 9 、10 两个报文中，为 d 分配了地址 4，过期时刻是 20。

第 11 个报文中，a 请求重新获取此前为其分配的地址 1，虽然为其分配的地址过 期，但是由于尚未分配给其它客户端， 因此 DHCP 服务器可以直接为其重新分配该地 址，并重新设置过期时刻为 20。

第 12 个报文中，c 请求延长其地址的过期时刻为 20 。DHCP 正常向其回复 Ack 报文。

第 13 、14 个报文中，e 试图请求地址。此时地址池中已经没有处于“未分配”状 态的地址了， 但是有此前分配给 b 的地址 2 的状态是“过期”，因此把该地址重新分配 给 e。

第 15 个报文中，b 试图重新获取此前为其分配的地址 2，但是此时该地址已经被 分配给 e，因此返回 Nak 报文。

第 16 个报文中，b 试图重新请求分配一个 IP 地址，但是此时地址池中已经没有 可用的地址了，因此忽略该请求。

【样例 2 输入】

4 70 100 50 dhcp

6

5 a \* OFR 2 100

10 b \* DIS 0 70

15 b dhcp2 REQ 4 60

20 c \* DIS 0 70

70 d \* DIS 0 120

75 d dhcp REQ 1 125

【样例 2 输出】

dhcp b OFR 1 70

dhcp c OFR 1 70

dhcp d OFR 1 120

dhcp d ACK 1 125

【样例 2 解释】

在本样例中， DHCP 服务器一共收到了 6 个报文，处理情况如下：

第 1 个报文不是 DHCP 服务器需要处理的报文，因此不回复任何报文。

第 2 个报文中，b 请求分配 IP 地址， 因此 DHCP 服务器将地址 1 分配给 b ，此 时，地址 1 进入待分配状态， DHCP 服务器向 b 发送 Oﬀer 报文。

第 3 个报文中，b 发送的 REQ 报文是发给非本服务器的， 因此需要将地址池中所 有拥有者是 b 的待分配状态的地址修改为未分配。

第 4 个报文中，c 请求分配 IP 地址。由于地址 1 此时是未分配状态， 因此将该地 址分配给它，向它发送 Oﬀer 报文，地址 1 进入待分配状态。

第 5 、6 个报文中，d 请求分配 IP 地址。注意到在收到第 5 个报文时， 已经是时 刻 70，地址 1 的过期时刻已到，它的状态已经被修改为了未分配， 因此 DHCP 服务器

仍然将地址 1 分配给 d。

【子任务】

对于 20% 的数据，有 _N_ ≤ 200，且 _n_ ≤ _N_，且输入仅含 Discover 报文，且 _t_ < _Tmin_；

对于 50% 的数据，有 _N_ ≤ 200，且 _n_ ≤ _N_，且 _t_ < _Tmin_ ，且报文的接收主机或为本 机，或为 \*；

对于 70% 的数据，有 _N_ ≤ 1000，且 _n_ ≤ _N_，且报文的接收主机或为本机，或为 \*；

对于 100% 的数据， 有 _N_ ≤ 10000，且 _n_ ≤ 10000，主机名的长度不超过 20，且 _t_, _Tmin_, _Tdefault_ , _Tmax_ ≤ 109 ，输入的报文格式符合题目要求，且数字不超过 109。

校门外的树（tree）

【题目描述】

X 校最近打算美化一下校园环境。前段时间因为修地铁，X 校大门外种的行道树 全部都被移走了。现在 X 校打算重新再种一些树，为校园增添一抹绿意。

X 校大门外的道路是东西走向的， 我们可以将其看成一条数轴。在这条数轴上有 _n_ 个障碍物，例如电线杆之类的。虽然障碍物会影响树的生长， 但是障碍物不一定能被随 便移走，所以 X 校规定在障碍物的位置上不能种树。_n_ 个障碍物的坐标都是整数；如 果规定向东为正方向，则 _n_ 个障碍物的坐标按照从西到东的顺序分别为 _a_1 , _a_2 , · · · , _an_。 X 校打算在 \[_a_1, _an_ \] 之间种一些树，使得这些树看起来比较美观。

X 校希望， 在一定范围内， 树应该是等间隔的。更具体地说， 如果把 \[_a_1, _an_ ) 划 分成一些区间\[_ap_1, _ap_2), · · · , \[_apm_−1, _apm_)（1 = _p_1 < _p_2 < · · · < _pm_ \= _n_）， 那么每个区间 \[_api_ , _api_+1) 内需要至少种一棵树，且该区间内种的树的坐标连同区间端点 _api_ , _api_+1 应该 构成一个等差数列。不同区间的公差，也就是树的间隔可以不相同。

例如，如果障碍物位于 0, 2, 6 这三处，那么我们可以选择在 \[0, 2) 和 \[2, 6) 分别种 树，也可以选择在 \[0, 6) 等间隔种树。如果是分别在 \[0, 2) 和 \[2, 6) 种树， 由于每个区 间内至少要种一棵树，坐标 1 上必须种树；而 \[2, 6) 上的树可以按照 1 的间隔种下，也 可以按照 2 的间隔种下。下图表示了这两种美观的种树方案，其中橙色的圆表示障碍 物，绿色的圆表示需要在这个位置种树， 箭头上的数字表示种下这棵树时对应的间隔为 多少。

图 2: 对区间 \[0, 2) 和 \[2, 6) 分别以 1 和 2 的间隔种树是美观的

图 3: 对区间 \[0, 2) 和 \[2, 6) 分别以 1 的间隔种树也是美观的

而如果选择在 \[0, 6) 区间等间隔种树， 我们只能以 3 的间隔种树， 因为无论是选择 间隔 1 或者间隔 2，都需要在坐标 2 上种树，而这个位置已经有障碍物了。下图分别表 示了间隔为 3, 2, 1 时的种树情况，红色箭头表示不能在这里种树。

图 4: 对区间 \[0, 6) 以 3 的间隔种树是美观的

图 5: 对区间 \[0, 6) 以 2 的间隔种树是不美观的

一般地，给定一个区间 \[_al_, _ar_ )，对于树的坐标的集合 _T_ ⊂ (_al_, _ar_ )（_T_ ⊂ Z），归纳定 义 _T_ 在 \[_al_, _ar_ ) 上是美观的：

1\. 如果 _T_ ≠ ∅ , _T_ ∩ {_al_ , _al_+1 , · · · , _ar_ } = ∅, 并且存在一个公差 _d_ ≥ 1，使得 _T_ ∪ {_al_, _ar_ } 中的元素按照从小到大的顺序排序后，可以构成一个公差为 _d_ 的等差数列（显 然，这个等差数列的首项为 _al_，末项为 _ar_），则 _T_ 在 \[_al_, _ar_ ) 上是美观的；

2\. 如果 _T_ ∩ {_al_ , _al_+1 , · · · , _ar_ } = ∅, 并且存在一个下标 _m_（_l_ < _m_ < _r_），使得 _T_ ∩ (_al_, _am_ ) 在 \[_al_, _am_ ) 上是美观的，且 _T_ ∩ (_am_, _ar_ ) 在 \[_am_, _ar_ ) 上是美观的， 则 _T_ 在 \[_al_, _ar_ ) 上 是美观的。

根据这一定义， 空集在任意区间上都不是美观的； 另外， 如果存在下标 _i_ 使得 _ai_ ∈ _T_，那么 _T_ 一定不是美观的。

我们称两种种树的方案是本质不同的，当且仅当两种方案中，种树的坐标集合不 同。请帮助 X 校对 \[_a_1, _an_ ) 求出所有本质不同的美观的种树方案。当然， 由于方案可能 很多，你只需要输出总方案数对 109 + 7 取模的结果。

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 _n_，表示障碍物的数量。

输入的第二行包括 _n_ 个非负整数 _a_1 , · · · , _an_，表示每个障碍物的坐标。

保证对 _i_ \= 1, 2, · · · , _n_ − 1 ，_ai_ < _ai_+1。

【输出格式】

输出到标准输出。

输出一个非负整数，表示本质不同的美观的种树方案的数量对 109 + 7 取模的结果。

图 6: 对区间 \[0, 6) 以 1 的间隔种树也是不美观的

【样例 1 输入】

3

0 2 6

【样例 1 输出】

3

【样例 1 解释】

这组样例即为题面描述中提到的那组。

【样例 2 输入】

11

0 10 20 30 40 50 60 70 80 90 100

【样例 2 输出】

256507

【样例 3】

见题目目录下的 **_3.in_** 与 **_3.ans_**。

【子任务】

对于 10% 的数据，保证 _n_ \= 2；

对于 30% 的数据，保证 _n_ ≤ 10；

对于 60% 的数据，保证 _n_ ≤ 100, _ai_ ≤ 1000；

对于 100% 的数据，保证 2 ≤ _n_ ≤ 1000, 0 ≤ _ai_ ≤ 100, 000，且至少存在一种美观的 种树方案。

疫苗运输（vaccine）

【题目描述】

X 市最近生产了一批疫苗，需要运往各地使用。疫苗的运输是一个困难的问题： 既 要实现尽快时间送达，又要保证全程冷链，否则疫苗会损坏。

X 市的物流系统并不发达， 只有 _n_ 个物流站点（以下简称“站点”）和 _m_ 条物流线 路（以下简称“线路”），且该物流系统具有以下几个特点：

1\. 每条线路都是环线。即， 从某个站点出发， 经过一系列不重复的站点， 最终回到 出发站点。

2\. 每条线路上有且仅有一辆运输车，以固定的时刻表（相邻站间的时间间隔） 在环 线上不断运行。在 0 时刻时，运输车在出发站点。

3\. 运输车上配备了容量足够大的制冷系统， 疫苗可以在车上长时间存放。但是换乘 （从一条线路切换到另一条线路）必须在同一个站点同一个时刻发生——因为各

个站点没有独立的制冷系统，疫苗不能在站点内下车等待。

现在 X 市想要从 1 号站点开始，经过若干条线路的运输和换乘，将疫苗运输到各 个其他站点。与其他站点不同， 1 号站点配有冷库。也就是说， 从 0 时刻开始，可以在 1 号站点等待某条线路运输车的到来， 再开始疫苗运输。问对于 2 号 ~ _n_ 号站点，分别 最早可以在什么时刻将疫苗送到该站点。

注意：每个问题是独立的，即只需要求出 1 号站点到各个站点的最早送达时刻。

【输入格式】

从标准输入读入数据。

第一行两个整数 _n_, _m_。

接下来 _m_ 行，每行表示一条物流线路。对于第 _i_ (1 ≤ _i_ ≤ _m_) 条线路，首先有一个 整数 _li_ (2 ≤ _li_ ≤ _n_) 表示该线路经过的站点个数。接下来 2_li_ 个整数，第 2_j_ \- 1 和第 2_j_ 个整数分别表示该线路的第 _j_ (1 ≤ _j_ ≤ _li_ ) 个站点的编号 _ai_,_j_ (1 ≤ _ai_,_j_ ≤ _n_)， 以及该线路 的第 _j_ 个站点到下一个站点所需的时间 _ti_,_j_ (1 ≤ _ti_,_j_ ≤ _T_)（对于第 _li_ 个站点即为它到第 1 个站点的时间）。其中，每条线路的第 1 个站点为其出发站点。 输入中同一行相邻的 整数，均用一个空格隔开。

【输出格式】

输出 _n_ \- 1 行，第 _i_ 行表示将疫苗送达第 _i_ \+ 1 个站点的最早时间： 如果能在有限时 间内送达，输出最早的送达时刻；否则输出 inf。

【样例 1 输入】

5 2

3 1 100 2 100 3 100

3 3 100 4 100 5 100

【样例 1 输出】

100

200

inf

inf

【样例 2 输入】

5 3

3 1 100 2 100 3 100

3 3 100 4 100 5 100

2 3 125 5 125

【样例 2 输出】

100

200

1600

625

【样例 2 解释】

在此样例中，有 5 个站点、3 条线路。第一条线路经过站点 1 、2 、3，第二条线路 经过站点 3 、4 、5，第三条线路经过站点 3 和 5。

以下为从 1 号站点到各个其他站点的最早送达路线：

• 2 号站点：通过第一条线路运输，在 100 时刻到达 2 号站点

• 3 号站点：通过第一条线路运输，在 200 时刻到达 3 号站点

• 4 号站点：通过第一条线路运输， 在 500 时刻到达 3 号站点，然后换乘第三条线 路，在 1500 时刻再次到达 3 号站点，最后换乘第二条线路， 在 1600 时刻到达 4 号站点

• 5 号站点：通过第一条线路运输， 在 500 时刻到达 3 号站点，然后换乘第三条线 路，在 625 时刻到达 5 号站点

【样例 3 输入】

10 5

6 8 18 1 8 3 52 4 3 7 18 2 47

6 8 96 2 45 10 44 6 95 4 97 3 96

4 10 63 8 97 7 75 1 12

7 3 7 5 75 1 19 2 37 4 25 10 43 9 32

2 6 35 5 74

【样例 3 输出】

99

26

78

245

7753

81

146

206

163

【子任务】

对于 10% 的数据，_n_ ≤ 5, _m_ \= 1, _T_ ≤ 10。

对于 30% 的数据，_n_ ≤ 5, _m_ ≤ 2, _T_ ≤ 10。

对于 50% 的数据，_n_ ≤ 5, _m_ ≤ 5, _T_ ≤ 10。

对于 70% 的数据，_n_ ≤ 10, _m_ ≤ 10, _T_ ≤ 100。

对于 80% 的数据，_n_ ≤ 30, _m_ ≤ 30, _T_ ≤ 1000 。 对于 95% 的数据，_n_ ≤ 100, _m_ ≤ 100, _T_ ≤ 105 。 对于 100% 的数据，_n_ ≤ 500, _m_ ≤ 500, _T_ ≤ 106。

第二十一次 **CCF** 计算机软件能力认证

CCF CSP

时间：2020 年 12 月 13 日 14:00 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 期末预测之<br><br>安全指数 | 期末预测之 最佳阈值 | 带配额的文 件系统 | 食材运输 | 星际旅行 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 目录  | index | threshold | quota | transport | travel |
| 可执行文件名 | index | threshold | quota | transport | travel |
| 输入文件名 | index.in | threshold. | i uota.in | transport. | iravel.in |
| 输出文件名 | index.out | threshold. | o ota.out | transport. | oavel.out |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 5.0 秒 | 1.0 秒 | 3.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 1024 MiB |
| 子任务数目 | 5   | 10  | 10  | 3   | 5   |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 否   |

提交源程序文件名

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 对于 C++ 语 言 | index.cpp | threshold. | c ota.cpp | transport. | cavel.cpp |
| 对于 C 语言 | index.c | threshold. | cquota.c | transport. | ctravel.c |
| 对于 Pascal 语 言 | index.pas | threshold. | p ota.pas | transport. | pavel.pas |

编译选项

|     |     |
| --- | --- |
| 对于 C++ 语 言 | \-O2 -std=c++14 |
| 对于 C 语言 | \-O2 -std=c11 |
| 对于 Pascal 语 言 | \-O2 |

期末预测之安全指数（index）

【题目背景】

期末要到了，小菜同学找到了自己的好朋友顿顿， 希望可以预测一下自己这学期是 否会挂科。

【题目描述】

首先，顿顿选取了如“课堂表现”、“自习时长”、“作业得分”、“社团活动参与度” 等 _n_ 项指标作为预测的依据。然后，顿顿根据自己平日里对小菜的暗中观察， 以百分 制给每一项指标打分， 即小菜同学第 _i_（1 ≤ _i_ ≤ _n_）项指标的得分 _scorei_ 是一个 \[0; 100\] 范围内的整数。鉴于每一项指标的重要性不尽相同，顿顿用一个 \[一10; 10\] 范围内的整 数 _wi_ 来表示第 _i_（1 ≤ _i_ ≤ _n_）项指标的重要程度。

最后，小菜同学期末的安全指数 _y_ 定义如下：

其中 ReLU (_x_) = max (0; _x_) 是一种常见的激活函数。因为使用了 ReLU 函数，安全指 数一定是个非负值。如果安全指数过低（甚至为零）， 则说明小菜同学这学期很可能要 挂科了......

已知每一项指标的重要程度 _wi_ 和相应的得分 _scorei_ ，快来算算小菜同学期末的安 全指数吧。

【输入格式】

从文件 **_index.in_** 中读入数据。

输入的第一行包含一个正整数 _n_，保证 2 ≤ _n_ ≤ 105。

接下来输入 _n_ 行，其中第 _i_（1 ≤ _i_ ≤ _n_）行包含用空格分隔的两个整数 _wi_ 和 _scorei_， 分别表示第 _i_ 项指标的重要程度和小菜同学该项的得分。

【输出格式】

输出到文件 **_index. out_** 中。

输出一个非负整数 _y_，表示小菜同学期末的安全指数。

【样例 1 输入】

6

2 60

10 100 0 70

0 0

\-10 50 10 60

【样例 1 输出】

1220

【样例 1 解释】

_y_ \= ReLU (1220) = 1220

【样例 2 输入】

2

\-10 100

\-1 15

【样例 2 输出】

0

【样例 2 解释】

_y_ \= ReLU (-1015) = 0

期末预测之最佳阈值（threshold）

【题目背景】

考虑到安全指数是一个较大范围内的整数、小菜很可能搞不清楚自己是否真的安 全，顿顿决定设置一个阈值 θ, 以便将安全指数 _y_ 转化为一个具体的预测结果——“会 挂科”或“不会挂科”。

因为安全指数越高表明小菜同学挂科的可能性越低，所以当 _y_ ≥ θ 时，顿顿会预测 小菜这学期很安全、不会挂科；反之若 _y_ < θ , 顿顿就会劝诫小菜：“你期末要挂科了， 勿谓言之不预也。”

那么这个阈值该如何设定呢？顿顿准备从过往中寻找答案。

【题目描述】

具体来说，顿顿评估了 _m_ 位同学上学期的安全指数， 其中第 _i_（1 ≤ _i_ ≤ _m_）位同学 的安全指数为 _yi_ ，是一个 \[0; 108 \] 范围内的整数； 同时，该同学上学期的挂科情况记作 _resulti_ ∈ {0; 1}，其中 0 表示挂科、 1 表示未挂科。

相应地，顿顿用 predictθ (_y_) 表示根据阈值 θ 将安全指数 _y_ 转化为的具体预测结果。 如果 predictθ (_yj_ ) 与 _resultj_ 相同，则说明阈值为 θ 时顿顿对第 _j_ 位同学是否挂科预测 正确；不同则说明预测错误。

最后，顿顿设计了如下公式来计算最佳阈值 θ\*：

该公式亦可等价地表述为如下规则：

1\. 最佳阈值仅在 {_yi_ } 中选取，即与某位同学的安全指数相同；

2\. 按照该阈值对这 _m_ 位同学上学期的挂科情况进行预测， 预测正确的次数最多 （即准确率最高）；

3\. 多个阈值均可以达到最高准确率时，选取其中最大的。

【输入格式】

从文件 **_threshold.in_** 中读入数据。

输入的第一行包含一个正整数 _m_。

接下来输入 _m_ 行，其中第 _i_（1 ≤ _i_ ≤ _m_）行包括用空格分隔的两个整数 _yi_ 和 _resulti_， 含义如上文所述。

【输出格式】

输出到文件 **_threshold. out_** 中。

输出一个整数，表示最佳阈值 θ\*。

【样例 1 输入】

6

0

1

1

3

5

7

0

0

1

1

1

1

【样例 1 输出】

3

【样例 1 解释】

按照规则一，最佳阈值的选取范围为 {0; 1; 3; 5; 7}。

θ = 0 时，预测正确次数为 4；

θ = 1 时，预测正确次数为 5；

θ = 3 时，预测正确次数为 5；

θ = 5 时，预测正确次数为 4；

θ = 7 时，预测正确次数为 3。

阈值选取为 1 或 3 时，预测准确率最高；所以按照规则二，最佳阈值的选取范围 缩小为 {1; 3}。

依规则三， θ\* = max {1; 3} = 3。

【样例 2 输入】

8

5

5

5

2

3

1

0

0

1

0

4 0

100000000 1

1 0

【样例 2 输出】

100000000

【子任务】

70% 的测试数据保证 _m_ ≤ 200；

全部的测试数据保证 2 ≤ _m_ ≤ 105。

带配额的文件系统（quota）

【题目背景】

小 H 同学发现，他维护的存储系统经常出现有人用机器学习的训练数据把空间占 满的问题，十分苦恼。查找了一阵资料后，他想要在文件系统中开启配额限制， 以便能 够精确地限制大家在每个目录中最多能使用的空间。

文件系统概述

文件系统，是一种树形的文件组织和管理方式。在文件系统中，文件是指用名字

. .

标识的文件系统能够管理的基本对象，分为普通文件和目录文件两种， 目录文件可以

. . . . . . . .

被简称为 目录。目录中有一种特殊的目录被叫做根目录 。除了根目录外，其余的文

. . . . .

件都有名字， 称为文件名。合法的文件名是一个由若干数字（ \[0-9\]）、大小写字母 （\[A-Za-z\]）组成的非空字符串。普通文件中含有一定量的数据， 占用存储空间； 目录 不占用存储空间。文件和目录之间存在含于关系。上述概念满足下列性质：

. .

1\. 有且仅有一个根目录；

. . .

2\. 对于除根目录以外的文件，都含于且恰好含于一个目录；

3\. 含于同一目录的文件，它们的文件名互不相同；

4\. 对于任意不是根目录的文件 _f_ ，若 _f_ 不含于根目录， 那么存在有限个目录 _d_1;_d_2; . . . ;_dn_，使得 _f_ 含于 _d_1 ，_d_1 含于 _d_2 ，. . . ，_dn_ 含于根目录。

结合性质 4 和性质 2 可知，性质 4 中描述的有限多个目录， 即诸 _di_ ，是唯一的。 再结合性质 3，我们即可通过从根目录开始的一系列目录的序列， 来唯一地指代一个文 件。我们记任意不是根目录且不含于根目录的文件 _f_ 的文件名是 _Nf_ ，那么 _f_ 的路径 是：‘/, + _Ndn_ \+ ‘/, + · · · + _Nd_1 + ‘/, + _Nf_，其中符号 + 表示字符串的连接；对于含于根 目录的文件 _f_ ，它的路径是：‘/, + _Nf_ ；根目录的路径是： ‘/,。不符合上述规定的路径都 是非法的。例如： /A/B 是合法路径，但 /A//B、/A/、A/、A/B 都不是合法路径。

若文件 _f_ 含于目录 _d_，我们也称 _f_ 是 _d_ 的孩子文件。_d_ 是 _f_ 的双亲目录。我们称 文件 _f_ 是目录 _d_ 的后代文件，如果满足：(1) _f_ 是 _d_ 的孩子文件，或 (2) _f_ 含于 _d_ 的后 代文件。

如图所示，该图中绘制的文件系统共有 8 个文件。其中， 方形表示目录文件， 圆形 表示普通文件，它们之间的箭头表示含于关系。在表示文件的形状上的文字是其文件 名；各个形状的左上方标记了序号， 以便叙述。在该文件系统中，文件 5 含于文件 2， 文件 5 是文件 2 的孩子文件，文件 5 也是文件 2 的后代文件。文件 8 是文件 2 的后代 文件，但不是文件 2 的孩子文件。文件 8 的路径是 /D1/D1/F2。

1

根⽬录

2 3 

4

D1 D2 F1

5

6 7

F1

D1 F1

F2

8

图 1: 文件系统样例

配额概述

配额是指对文件系统中所含普通文件的总大小的限制。对于每个目录 _d_，都可以设 定两个配额值： 目录配额和 后代配额。我们称目录配额 _LDd_ 是满足的，当且仅当 _d_ 的 孩子文件中，全部普通文件占用的存储空间之和不大于该配额值。我们称后代配额 _LRd_ 是满足的，当且仅当 _d_ 的后代文件中，全部普通文件占用的存储空间之和不大于该配额 值。我们称文件系统的配额是满足的，当且仅当该文件系统中所有的配额都是满足的。

很显然，若文件系统中仅存在目录， 不存在普通文件， 那么该文件系统的配额一定 是满足的。随着配额和文件的创建，某个操作会使文件系统的配额由满足变为不满足， 这样的操作会被拒绝。例如： 试图设定少于目前已有文件占用空间的配额值， 或者试图 创建超过配额值的文件。

【题目描述】

在本题中，假定初始状态下， 文件系统仅包含根目录。你将会收到若干对文件系统 的操作指令。对于每条指令，你需要判断该指令能否执行成功，对于能执行成功的指 令，在成功执行该指令后， 文件系统将会被相应地修改。对于不能执行成功的指令， 文 件系统将不会发生任何变化。你需要处理的指令如下：

. . . . . . . .

创建普通文件

创建普通文件指令的格式如下：

C &lt;file path&gt; &lt;file size&gt;

创建普通文件的指令有两个参数， 是空格分隔的字符串和一个正整数，分别表示需 要创建的普通文件的路径和文件的大小。

对于该指令，若路径所指的文件已经存在，且也是普通文件的，则替换这个文件； 若路径所指文件已经存在，但是目录文件的，则该指令不能执行成功。

当路径中的任何目录不存在时， 应当尝试创建这些目录； 若要创建的目录文件与已 有的同一双亲目录下的孩子文件中的普通文件名称重复，则该指令不能执行成功。

另外，还需要确定在该指令的执行是否会使该文件系统的配额变为不满足， 如果会 发生这样的情况，则认为该指令不能执行成功，反之则认为该指令能执行成功。

移除文件

移除文件指令的格式如下：

R &lt;file path&gt;

移除文件的指令有一个参数，是字符串，表示要移除的文件的路径。

若该路径所指的文件不存在，则不进行任何操作。

若该路径所指的文件是目录，则移除该目录及其所有后代文件。

在上述过程中被移除的目录（如果有）上设置的配额值也被移除。

该指令始终认为能执行成功。

设置配额值

Q &lt;file path&gt; &lt;LD&gt; &lt;LR&gt;

设置配额值的指令有三个参数， 是空格分隔的字符串和两个非负整数， 分别表示需 要设置配额值的目录的路径、目录配额和后代配额。

该指令表示对所指的目录文件， 分别设置目录配额和后代配额。若路径所指的文件 不存在，或者不是目录文件，则该指令执行不成功。

若在该目录上已经设置了配额，则将原配额值替换为指定的配额值。

特别地，若配额值为 0 ，则表示不对该项配额进行限制。若在应用新的配额值后， 该文件系统配额变为不满足，那么该指令执行不成功。

【输入格式】

从文件 **_quota.in_** 中读入数据。

输入的第一行包含一个正整数 _n_，表示需要处理的指令条数。

输入接下来会有 _n_ 行，每一行一个指令。指令的格式符合前述要求。输入数据保 证：对于所有指令， 输入的路径是合法路径； 对于创建普通文件和移除文件指令， 输入 的路径不指向根目录。

【输出格式】

输出到文件 **_quota. out_** 中。

输出共有 _n_ 行，表示相应的操作指令是否执行成功。若成功执行，则输出字母 Y； 否则输出 N。

【样例 1 输入】

10

C /A/B/1 1024

C /A/B/2 1024

C /A/B/1/3 1024

C /A 1024

R /A/B/1/3

Q / 0 1500

C /A/B/1 100

Q / 0 1500

R /A/B

Q / 0 1

【样例 1 输出】

Y

Y

N

N

Y

N

Y

Y

Y

Y

【样例 1 解释】

输入总共有 10 条指令。其中前两条指令可以正常创建两个普通文件。第三条指令 试图创建 /A/B/1/3，但是 /A/B/1 已经存在，且不是目录，而是普通文件，不能再进 一步创建孩子文件， 因此执行不成功。第四条指令试图创建 /A，但是 /A 已经存在，且 是目录， 因此执行不成功。第五条指令试图删除 /A/B/1/3，由于该文件不存在，因此

不对文件系统进行修改， 但是仍然认为执行成功。第六条指令试图在根目录增加后代配 额限制，但此时，文件系统中的文件总大小是 2048，因此该限制无法生效，执行不成 功。第七条指令试图创建文件 /A/B/1， 由于 /A/B/1 已经存在，且是普通文件， 因此 该指令实际效果是将原有的该文件替换。此时文件总大小是 1124，因此第八条指令就 可以执行成功了。第九条指令递归删除了 /A/B 目录和它的所有后代文件。此时文件系 统中已经没有普通文件，因此第十条命令可以执行成功。

【样例 2 输入】

9

Q /A/B 1030 2060

C /A/B/1 1024

C /A/C/1 1024

Q /A/B 1024 0

Q /A/C 0 1024

C /A/B/3 1024

C /A/B/D/3 1024

C /A/C/4 1024

C /A/C/D/4 1024

【样例 2 输出】

N

Y

Y

Y

Y

N

Y

N

N

【样例 2 解释】

输入共有 9 条指令。第一条指令试图为 /A/B 创建配额规则，然而该目录并不存 在，因此执行不成功。接下来的两条指令创建了两个普通文件。再接下来的两条指令分 别在目录 /A/B 和 /A/C 创建了两个配额规则。其中前者是目录配额， 后者是后代配额。 接下来的两条指令，创建了两个文件。其中，/A/B/3 超出了在 /A/B 的目录配额， 因

此执行不成功；但 /A/B/D/3 不受目录配额限制， 因此执行成功。最后两条指令， 创建 了两个文件。虽然在 /A/C 没有目录配额限制，但是无论是 /A/C 下的孩子文件还是后 代文件，都受到后代配额的限制，因此两条指令执行都不成功。

【子任务】

本题目各个测试点的数据规模如下：

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 测试点 | 操作数 | 单个文件大小 | 路径长度 | 目录层次 | 没有操作 Q |
| 1; 2 | ≤ 100 | ≤ 109 | ≤ 100 | ≤ 20 | 是   |
| 3; 4 | 否   |
| 5; 6; 7 | ≤ 105 | 是   |
| 8; 9; 10 | 否   |

表格中，目录层次是指各指令中出现的路径中， / 字符的数目。 所有输入的数字均不超过 1018。

食材运输（transport）

【题目背景】

在 T 市有很多个酒店，这些酒店对于不同种类的食材有不同的需求情况，莱莱公 司负责每天给这些酒店运输食材。

由于酒店众多，如何规划运输路线成为了一个非常重要的问题。你作为莱莱公司的 顾问，请帮他们解决这个棘手的问题。

【题目描述】

T 市有 _N_ 个酒店， 这些酒店由 _N_ \- 1 条双向道路连接， 所有酒店和道路构成一 颗树。不同的道路可能有不同的长度，运输车通过该道路所需要的时间受道路的长度 影响。

在 T 市，一共有 _K_ 种主流食材。莱莱公司有 _K_ 辆车，每辆车负责一种食材的配 送，不存在多辆车配送相同的食材。

由于不同酒店的特点不同， 因此不同酒店对食材的需求情况也不同， 比如可能 1 号 酒店只需要第 1; 5 种食材，2 号酒店需要全部的 _K_ 种食材。

莱莱公司每天给这些公司运输食材。对于运输第 _i_ 种食材的车辆， 这辆车可以从任 意酒店出发，然后将食材运输到所有需要第 _i_ 种食材的酒店。假设运输过程中食材的装 卸不花时间，运输车足够大使得其能够在出发时就装满全部所需食材， 并且食材的重量 不影响运输车的速度。

为了提高配送效率，这 _K_ 辆车可以从不同的酒店出发。但是由于 T 市对于食品安 全特别重视，因此每辆车在配送之前需要进行食品安全检查。鉴于进行食品安全检查的 人手不足，最多可以设置 _M_ 个检查点。

现在莱莱公司需要你制定一个运输方案：选定不超过 _M_ 个酒店设立食品安全检查

. . .

点，确定每辆运输车从哪个检查点出发，规划每辆运输车的路线。

假设所有的食材运输车在进行了食品安全检查之后同时出发，请制定一个运输方 案，使得所有酒店的等待时间的最大值最小。酒店的等待时间从运输车辆出发时开始计 算，到该酒店所有需要的食材都运输完毕截至。如果一个酒店不需要任何食材， 那么它 的等待时间为 0 。

【输入格式】

从文件 **_transport.in_** 中读入数据。

输入的第一行包含 3 个正整数 _N_; _M_; _K_ (1 ≤ _N_ ≤ 102 ; 1 ≤ _M_ ≤ _K_ ≤ 10)，含义见题目 描述。

接下来 _N_ 行，每行包含 _K_ 个整数。每行输入描述对应酒店对每种食材的需求情况， 1 表示需要对应的食材， 0 表示不需要。

接下来 _N_ \- 1 行，每行包含 3 个整数 _u_; _v_; _w_ ，表示存在一条通行时间为 _w_ 的双向 道路连接 _u_ 号酒店和 _v_ 号酒店。保证输入数据是一颗树，酒店从 1 编号到 _N_ ，保证 1 ≤ _u_; _v_ ≤ _N_ 并且 1 ≤ _w_ ≤ 106。

【输出格式】

输出到文件 **_transport. out_** 中。

输出一个整数，表示在你的方案中，所有酒店的等待时间的最大值。

【样例 1 输入】

6 1 2

1 0

0 0

1 0

0 1

0 1

0 1

1 2 7

2 3 2

2 4 4

4 5 5

4 6 3

【样例 1 输出】

15

【样例 1 解释】

需要对应的⻝材

不需要对应的⻝材

样例 1 的输入数据如上图。由于限制了最多只能设置 1 个检查点， 因此可以设置 两辆运输车的路径如下：

在 2 号酒店设置检查点，最晚拿到所有食材的酒店为 3 号酒店，等待时间为 9 。

1号运输车 2  3  2  1

2号运输车 2  4  6  4  5

【样例 2 输入】

6 2 2

1 0

0 0

1 0

0 1

0 1

0 1

1 2 7

2 3 2

2 4 4

4 5 5

4 6 3

【样例 2 输出】

9

【样例 2 解释】

样例 2 的输入数据和样例 1 几乎完全相同，唯一的区别在于样例 2 中允许最多设 置 2 个检查点。我们可以设置两辆运输车的路径如下：

1号运输车 

2号运输车 

在 1 号酒店和 6 号酒店设置检查点，最晚拿到所有食材的酒店为 5 号酒店，等待 时间为 15 。

【子任务】

本题目数据规模如下：

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 分数占比 | N   | M   | K   | 特殊性 |
| 30% | ≤ 102 | \= _K_ | ≤ 10 | 保证输入数据是一条链，且 _u_ \+ 1 = _v_ |
| 40% | 无   |
| 30% | ≤ _K_ |

星际旅行（travel）

【题目描述】

乔帝要规划一次星际旅行， 星际空间可以视为一个 3 维坐标系， 乔帝有 _n_(_n_ ≤ 1; 000; 000; 000) 个动力装置排成一行 (下标从 1 到 _n_ )。

第 _i_ 个动力装置可以让他的飞船 3 个维度的坐标分别增加 _xi_; _yi_; _zi_ 。一开始这些动 力装置的所有参数都是 0 。

在规划过程中，乔帝可能会对动力装置进行调整， 也可能会对一些动力装置的动力 进行评估。

具体来说，乔帝会进行 _m_(_m_ ≤ 40000) 次操作，每次操作可能是以下四种操作之一：

• 动力增加：指定一个区间 \[_L_; _R_\] 和三个参数 _a_; _b_; _c_ ，令区间内所有动力装置的 3 维坐标分别增加 _a_; _b_; _c_

• 动力强化：指定一个区间 \[_L_; _R_\] 和一个参数 _k_ ，令区间内所有动力装置的 3 维坐 标分别乘 _k_

• 动力转向：指定一个区间 \[_L_; _R_\] ，令区间内所有动力装置的 _x_; _y_; _z_ 坐标分别变为 原来的 _y_ 坐标，_z_ 坐标，_x_ 坐标

• 动力查询：指定一个区间 \[_L_; _R_\] ，询问如果使用区间内所有动力装置各一次能将 乔帝送到离起点多远的地方 (输出距离的平方除以 1,000,000,007 的余数)

【输入格式】

从文件 **_travel.in_** 中读入数据。

第一行包含两个正整数 _n_; _m_。

接下来 _m_ 行，每行用若干个空格分隔的整数表示一个操作。

每行的第一个整数表示这次进行的是哪一种操作，1; 2; 3; 4 分别表示动力增加、动 力强化、动力转向、动力查询。

每行的接下来两个整数表示 _L_; _R_，含义如上面所述。

每行接下来若干个整数，根据操作类型确定，为 _a_; _b_; _c_ 或 _k_ 或空。

【输出格式】

输出到文件 **_travel. out_** 中。

对于每个动力查询操作，输出一行，包含一个整数，表示查询的答案。

【样例 1 输入】

5 5

1 2 4 5 6 7

3 5 5

2 1 2 4

4 1 3

4 2 5

【样例 1 输出】

2750

3960

【样例 1 解释】

一共有 5 个动力装置。

对于第 1 个操作，令第 2; 3; 4 个动力装置的动力变为 (5; 6; 7)。

对于第 2 个操作，令第 5 个动力装置转向，为 (0; 0; 0)。

对于第 3 个操作，令第 1; 2 个动力装置变为原来的 4 倍，第一个变为 (0; 0; 0)，第 二个变为 (20; 24; 28)。

对于第 4 个操作，是查询，送到离起点 (0 + 20 + 5; 0 + 24 + 6; 0 + 28 + 7)，距离的 平方为 2750。

对于第 5 个操作，也是查询，送到离起点 (20 + 5 + 5 + 0; 24 + 6 + 6 + 0; 28 + 7 + 7 + 0)， 距离的平方为 3960。

【子任务】

对于 20% 的数据，_n_; _m_ ≤ 1000；

对于另外 20% 的数据，_n_ ≤ 100000，且只包含第 1; 4 种操作；

对于另外 20% 的数据，_n_ ≤ 100000，且只包含第 1; 2; 4 种操作；

对于另外 20% 的数据，_n_ ≤ 100000；

对于另外 20% 的数据，没有特殊性质。

所有输入的数字都在 \[1; 1000000000\] 范围内。

所有的数据中 1 ≤ _m_ ≤ 40000。

所有的操作满足 1 ≤ _L_ ≤ _R_ ≤ _n_。

第二十次

CCF 计算机软件能力认证

CCF CSP

时间：2020 年 9 月 13 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 检测点查询 | 风险人群筛 查 | 点亮数字人 生 | 星际旅行 | 密信与计数 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MiB |
| 子任务数目 | 10  | 5   | 3   | 20  | 25  |
| 测试点是否等 分 | 是   | 是   | 否   | 是   | 是   |

检测点查询（knn）

【题目背景】

2020 年 6 月 8 日，国务院联防联控机制发布《关于加快推进新冠病毒核酸检测的 实施意见》，提出对“密切接触者”等八类重点人群“应检尽检”，其他人群“愿检尽检”。

【题目描述】

某市设有 n 个核酸检测点，编号从 1 到 n，其中 i 号检测点的位置可以表示为一个 平面整数坐标 (xi , yi )。为方便预约核酸检测， 请根据市民所在位置 (X, Y)，查询距其最 近的三个检测点。多个检测点距离相同时，编号较小的视为更近。

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

第一行包含用空格分隔的三个整数 n 、X 和 Y，表示检测点总数和市民所在位置。

第二行到第 n + 1 行依次输入 n 个检测点的坐标。第 i + 1 行（1 ≤ i ≤ n）包含用 空格分隔的两个整数 xi 和 yi，表示 i 号检测点所在位置。

【输出格式】

输出到标准输出。

输出共三行，按距离从近到远，依次输出距离该市民最近的三个检测点编号。

【样例 1 输入】

1

2

3

4

3 2 2

2 2

2 3

2 4

【样例 1 输出】

1

2

3

1

2

3

【样例 2 输入】

1

2

3

4

5

6

5 0 1

\-1 0

0 0

1 0

0 2

\-1 2

【样例 2 输出】

1

2

3

2

4

1

【样例 2 解释】

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 检测点编号 | 1   | 2   | 3   | 4   | 5   |
| 距离  | √2  | 1   | √2  | 1   | √2  |

【子任务】

全部的测试点满足， 3 ≤ n ≤ 200，所有坐标均为整数且绝对值不超过 1000。

【提示】

市民到第 i 号检测点的距离 Di 可由如下公式算出：

D = (X - xi )2 + (Y - yi )2

风险人群筛查（filter）

【题目背景】

某地疫情爆发后， 出于“应检尽检”的原则，我们想要通知所有近期经过该高危区 域的居民参与核酸检测。

【题目描述】

想要找出经过高危区域的居民，分析位置记录是一种简单有效的方法。

具体来说，一位居民的位置记录包含 t 个平面坐标 {(x1 , y1 ), (x2 , y2 ), · · · , (xt , yt )}， 其中 (xi , yi ) 表示该居民 i 时刻所在位置。高危区域则可以抽象为一个矩形区域（含边 界），左下角和右上角的坐标分别为 (xl , yd ) 和 (xr , yu )，满足 xl < xr 且 yd < yu。

考虑某位居民的位置记录，如果其中某个坐标位于矩形内（含边界）， 则说明该居 民经过高危区域；进一步地，如果其中连续 k 个或更多坐标均位于矩形内（含边界），则 认为该居民曾在高危区域逗留。需要注意的是， 判定经过和逗留时我们只关心位置记录

. . . . . .

中的 t 个坐标，而无需考虑该居民在 i 到 i + 1 时刻之间位于何处。

给定高危区域的范围和 n 位居民过去 t 个时刻的位置记录，试统计其中经过高危区 域的人数和曾在高危区域逗留的人数。

【输入格式】

从标准输入读入数据。

输入共 n + 1 行。

第一行包含用空格分隔的七个整数 n 、k 、t 、xl 、yd 、xr 和 yu，含义如上文所述。

接下来 n 行，每行包含用空格分隔的 2t 个整数，按顺序表示一位居民过去 t 个时 刻的位置记录 {(x1 , y1 ), (x2 , y2 ), · · · , (xt , yt )}。

【输出格式】

输出到标准输出。

输出共两行， 每行一个整数，分别表示经过高危区域的人数和曾在高危区域逗留的 人数。

【样例 1 输入】

1

2

3

4

10 60 14 62 18 66 22 74 26 86 30 100

5 2 6 20 40 100 80

100 80 100 80 100 80 100 80 100 80 100 80

60 50 60 46 60 42 60 38 60 34 60 30

第 4 页 共 23 页

90 31 94 35 98 39 102 43 106 47 110 51

0 20 4 20 8 20 12 20 16 20 20 20

【样例 1 输出】

1

2

3

2

【样例 1 解释】

如下图红色标记所示， 前三条位置记录经过了高危区域； 但第三条位置记录（图中 左上曲线）只有一个时刻位于高危区域内，不满足逗留条件。

120

100

80

60

y

40

20

0

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
|     |     |     |     |     |     |     |     |     |
| Δ   | Record 1<br><br>Record 3<br><br>Record 2 |
|     |     |     |     |     |     |     | Record 4<br><br>Record 5 |     |
|     |     |     |
|     | Δ Δ | Δ   |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |
|     |     |     |     |     |     |     |     |     |

0 20 40 60 80 100 120

x

5

6

【样例 2 输入】

1

2

1 3 8 0 0 10 10

\-1 -1 0 0 0 0 -1 -1 0 0 -1 -1 0 0 0 0

【样例 2 输出】

1

2

1

0

【样例 2 解释】

该位置记录经过了高危区域， 但最多只有连续两个时刻位于其中， 不满足逗留条件。

【子任务】

全部的测试点满足 1 ≤ n ≤ 20 ，1 ≤ k ≤ t ≤ 103 ，所有坐标均为整数且绝对值不超 过 106。

点亮数字人生（digital）

【题目背景】

土豪大学的计算机系开了一门数字逻辑电路课，第一个实验叫做“点亮数字人生”， 要用最基础的逻辑元件组装出实际可用的电路。时间已经是深夜了， 尽管实验箱上密密 麻麻的连线已经拆装了好几遍， 小君同学却依旧没能让她的电路正常工作。你能帮助她 模拟出电路的功能，成功点亮她的数字人生吗？

【题目描述】

本题中，你需要实现一个简单的数字逻辑电路模拟器。如果你已经有了此方面的基 础，可以直接跳过本节。在阅读时， 也可以参照前两个样例的图示和解释， 这有助于你 更好地理解数字逻辑电路的工作原理。

数字逻辑电路是用来传输数字信号（也就是二进制信号）的电路。一般来说，数字逻 辑电路可以分为两大类， 即组合逻辑（combinational logic）电路和时序逻辑（sequential logic）电路。在本题中， 我们仅关注组合逻辑电路。这种电路仅由逻辑门（logical gate） 构成。 一个逻辑门可以理解为一个多输入单输出的函数， 输入端连接至少一个信号，而 后经过一定的逻辑运算输出一个信号。常见的逻辑门包括与（AND）、或（OR）、非 （NOT）、异或（XOR）等，均与编程语言中的按位运算是对应的。

将一系列的逻辑门连接起来， 就能构成具有特定功能的电路。它的功能可能很简单 （如一位二进制加法只需要一个异或门），也可能极其复杂（如除法）。无论复杂程度， 这 类电路的特点是： 它不维持任何的状态， 任何时刻输出只与输入有关，随输入变化。真

. . . . . . . . . . . .

实世界中的逻辑器件由于物理规律的限制， 存在信号传播延时。为了简单起见， 本题中 我们模拟的组合逻辑电路不考虑延时： 一旦输入变化，输出立刻跟着变化。

考虑到组合逻辑电路的这一特性，设计时不能允许组合环路（combinational loop） 的存在，即某逻辑门的输入经过了一系列器件之后又被连接到了自己的输入端。真实世 界中，这种做法将导致电路变得不稳定， 甚至损坏元器件。因此， 你也需要探测可能的 环路。需要注意， 环路的存在性与逻辑门的具体功能没有任何关系； 只要连接关系上存

. . . . . . . .

在环路，电路就无法正常工作。

. . . . . . . . . . . .

【输入格式】

从标准输入读入数据。

输入数据包括若干个独立的问题，第一行一个整数 Q，满足 1 ≤ Q ≤ Qmax。接下 来依次是这 Q 个问题的输入，你需要对每个问题进行处理，并且按照顺序输出对应的 答案。

每一个问题的输入在逻辑上可分为两部分。第一部分定义了整个电路的结构， 第二 部分定义了输入和输出的要求。 实际上两部分之间没有分隔，顺序读入即可。

. . . . . . . . . . . . . . . . . .

第一部分

第一行是两个空格分隔的整数 M, N，分别表示了整个电路的输入和器件的数量， 满 足 1 ≤ N ≤ Nmax 并且 0 ≤ M ≤ kmax N。其中 kmax 和 Nmax 都是与测试点编号有关的 参数。

接下来 N 行，每行描述一个器件，编号从 1 开始递增，格式如下：

1

FUNC k L_1 L_2 ... L_k

其中 FUNC 代表具体的逻辑功能，k 表示输入的数量，后面跟着该器件的 k 个输入 端描述 L，格式是以下二者之一：

• Im：表示第 m 个输入信号连接到此输入端，保证 1 ≤ m ≤ M；

• On：表示第 n 个器件的输出连接到此输入端，保证 1 ≤ n ≤ N。

所有可能的 FUNC 和允许的输入端数量如下表所述：

|     |     |     |     |
| --- | --- | --- | --- |
| FUNC | 最少输入数量 | 最多输入数量 | 功能描述 |
| NOT | 1   | 1   | 非   |
| AND | 2   | kmax | 与   |
| OR  | 2   | kmax | 或   |
| XOR | 2   | kmax | 异或  |
| NAND | 2   | kmax | 与非（先全部与后取非） |
| NOR | 2   | kmax | 或非（先全部或后取非） |

所有的器件均只有一个输出，但这个输出信号可以被用作多个器件的输入。

第二部分

第一行是一个整数 S，表示此电路需要运行 S 次。每次运行，都会给定一组输入， 并检查部分器件的输出是否正确。S 满足 1 ≤ S ≤ Smax ，其中 Smax 是一个与测试点编 号有关的参数。

接下来的 S 行为输入描述，每一行的格式如下：

1

I_1 I_2 ... I_M

每行有 M 个可能为 0 或 1 的数字，表示各个输入信号（按编号排列）的状态。 接下来的 S 行为输出描述，每一行的格式如下：

1

s_i O_1 O_2 ... O_s

第一个整数 1 ≤ si ≤ N(1 ≤ i ≤ S) 表示需要输出的信号数量。后面共有 si 个在 1 到 N 之间的数字，表示在对应的输入下，组合逻辑完成计算后，需要输出结果的器件 编号。

注意 O 序列不一定是递增的，即要求输出的器件可能以任意顺序出现。

. . . . . . . . . . .

【输出格式】

输出到标准输出。

对于输入中的 Q 个问题，你需要按照输入顺序输出每一个问题的答案：

如果你检测到电路中存在组合环路，则请输出一行， 内容是 LOOP，无需输出其他 任何内容。

如果电路可以正常工作，则请输出 S 行，每一行包含 si 个用空格分隔的数字（可 能为 0 或 1），依次表示“输出描述”中要求的各个器件的运算结果。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

1

3 5

XOR 2 I1 I2

XOR 2 O1 I3

AND 2 O1 I3

AND 2 I1 I2

OR 2 O3 O4

4

0 1 1

1 0 1

1 1 1

0 0 0

2 5 2

2 5 2

2 5 2

2 5 2

【样例 1 输出】

1

2

3

4

1 0

1 0

1 1

0 0

【样例 1 解释】

本样例只有一个问题，它定义的组合逻辑电路结构如下图所示。其功能是一位全加 器，即将三个信号相加， 得到一个两位二进制数。要求的器件 2 的输出是向更高位的进 位信号，器件 5 的输出是本位的求和信号。

对于第一组输入 0 1 1，输出是 1 0；对于第二组输入 1 0 1，输出恰好依旧是 1 0（但电路内部状态不同）。

【样例 2 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

1

2 6

NOR 2 O4 I2

AND 2 O4 O6

XOR 2 O5 O1

NOT 1 O6

NAND 2 O2 O2

AND 2 I1 O3

2

0 0

1 0

3 2 3 4

6 1 2 3 4 5 6

【样例 2 输出】

1

LOOP

【样例 2 解释】

本样例也只有一个问题，它定义的组合逻辑电路结构如下图所示。

这是一个带组合环路的电路， 因此无法正常工作。特别地， 其中最短的环路有以下 三条：

• 6 - 2 - 5 - 3 - 6

• 4 - 1 - 3 - 6 - 4

• 2 - 5 - 3 - 6 - 2

【子任务】

本题共有 10 个测试点，每个测试点占 10 分。

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 测试点 | Nmax | kmax | Smax | Qmax | 可能存在环 |
| 1, 2 | 50  | 2   | 100 | 1   | 否   |
| 3, 4, 5 | 100 | 500 | 2   |
| 6, 7, 8, 9, 10 | 500 | 5   | 10000 | 5   | 是   |

星际旅行（tangent）

【题目描述】

在一个 n 维欧几里得空间的宇宙中，小 A 打算完成一次星际旅行。

利用 n 维直角坐标系，宇宙中每个点的位置都可以用 n 维坐标来表示。其中，在 宇宙中心的 O 点（未必是坐标系原点） 处，有一个半径为 r 的超球体黑洞，任何物体若 落入黑洞内部（不包括其表面）则无法逃脱。

小 A 选定了 m 个不在黑洞内部的点 P1 , P2 , · · · , Pm，作为他星际旅行的目标。不会 有两个点处于同一位置。

为了提前做好旅行规划，小 A 希望求出这 m 个点两两之间的最短曲线距离。同样 地，这些曲线不能经过黑洞的内部。为了方便， 你只需要输出每个点到其他 m - 1 个点 的距离之和。

【输入格式】

从标准输入读入数据。

第一行两个整数 n, m。

第二行一个整数 r。

第三行 n 个整数，依次表示超球体黑洞的中心 O 的每一维坐标。

接下来 m 行，每行 n 个整数。第 i 行的各个整数依次表示点 Pi 的每一维坐标。 同一行内的多个整数之间用一个空格隔开。

【输出格式】

输出到标准输出。

输出一共 m 行，每行一个实数。第 i 行表示第 i 个点（Pi ）到其他所有点的最短曲 线距离之和。

请以“整数部分、小数点、小数部分”的格式输出实数，并保留不少于 12 位小数 结果。采用其他格式（如科学记数法）输出可能无法得分。

【样例 1 输入】

1

2

3

4

5

6

|     |     |
| --- | --- |
| 2<br><br>2<br><br>3<br><br>5<br><br>1<br><br>3 | 3<br><br>1<br><br>1<br><br>3<br><br>\-2 |

【样例 1 输出】

1

2

3

8.83711594354348 10.83711594354348

9.39104657990738

【样例 1 解释】

如下图所示，圆 O 为二维平面上的黑洞， P1 , P2 , P3 为小 A 星际旅行的目标。

通过在圆周上选择合适的点 A, B, C, D，可以证明， 曲线 P1 AP2 , P2 BCP3 , P3 DP1 分别为这三对点之间满足条件的最短曲线。这些曲线的长度分别为 5.14159265358979, 5.69552328995369, 3.69552328995369。

【样例 2 输入】

1

2

3

4

5

6

7

8

9

10

3 8

1

0 0 0

0 0 1

0 1 0

1 0 0

1 1 1

\-1 -1 0

\-1 0 -1

0 -1 -1

11

1

2

3

4

5

6

7

8

\-1 -1 -1

【样例 2 输出】

14.12797001266400 14.12797001266400 14.12797001266400 17.90086240651788 13.95502966750398 13.95502966750398 13.95502966750398

14.99490548122857

【评分方式】

对于每个测试点， 你的结果正确则得该测试点的满分， 错误不得分。你的输出被认 为是正确的，当且仅当你输出的每个实数与对应答案的相对或绝对误差不超过 10-9。

为了达到这一精度要求，请不要使用单精度浮点数（对应 C 、C++ 、Java 语言的

. . . . . . . . . .

float 类型，机器精度约 10-6 级别）完成本题，而应当使用双精度浮点数（对应 C、 C++、Java 语言的 double 类型、Python 语言的 float 类型，机器精度约 10-15 级别） 或更精确的表示法（如整数类型 int，前提是不能超出该类型的表示范围）。

【子任务】

本题共 20 个测试点，每个 5 分。

对于所有的测试点， 2 ≤ n ≤ 100, 2 ≤ m ≤ 2000, 1 ≤ r ≤ 1000.

输入中的所有坐标均在 \[-1000, 1000\] 范围内。

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点编号 | n   | 所有 Pi 均在黑洞边界上 | m   |
| 1   | \= 2 | 是   | \= 10 |
| 2   | \= 20 |
| 3   | \= 50 |
| 4   | 否   | \= 100 |
| 5   | \= 200 |
| 6   | \= 500 |
| 7   | \= 2000 |
| 8   | \= 3 | 是   | \= 100 |
| 9   | \= 200 |
| 10  | 否   | \= 500 |
| 11  | \= 1000 |
| 12  | \= 2000 |
| 13  | \= 100 | 是   | \= 100 |
| 14  | \= 500 |
| 15  | \= 2000 |
| 16  | 否   | \= 100 |
| 17  | \= 200 |
| 18  | \= 500 |
| 19  | \= 1000 |
| 20  | \= 2000 |

【提示】

以下数学知识对你求解此题有可能会有帮助（其中所有的角均采用弧度制）：

. . .

• 某个点在超球体的内部（不含边界）， 当且仅当该点到球心的距离小于超球体的 半径；

• 超球体的任意一条切线（与超球体有且仅有一个公共点的直线） 垂直于过切点的 半径；

• 给定实数 A1 , A2, . . . , An , B（其中 A1 , A2, . . . , An 不全为 0），方程 A1 x1 + A2 x2 +

· · ·+An xn +B = 0 确定了 n 维空间中的一个 n-1 维超平面，向量 (A1 , A2, . . . , An ) 是该超平面的一个法向量，点 (p1 , p2, . . . , pn ) 到该超平面的距离为：

| A1p1 + A2p2 + · · · + Anpn + B|

√A + A + · · · + A

• 对于半径为 r 的圆，圆心角 α 对应的弧长为 αr；

• 对于三边长分别为 a, b, c 的三角形 ABC（边 a 是点 A 的对边，其余同）：

**\-** 正弦定理：  =  =  = D，其中 D 为三角形外接圆直径；

**\-** 余弦定理：c2 = a2 + b2 - 2abcos C；

**\-** 正弦求三角形面积 

**\-** 海伦-秦九韶公式 其中 p = 

• 同上述，如果  该三角形为直角三角形：

**\-** 勾股定理：a2 + b2 = c2；

**\-** 三角函数定义：正弦 sin  余弦  正切 

• 三角函数的和/差角公式：

**\-** 两角和/差的正弦： sin(α ± β) = sin α cos β ± cosα sin β;

**\-** 两角和/差的余弦： cos (α ± β) = cos α cos β 干 sin α sin β;

**\-** 两角和/差的正切

密信与计数（decrypt）

【题目描述】

背景

小明和小鱼研究出了一套加密通信的规则。小鱼给小明发送信息（仅由小写字母组 成的字符串）的流程如下：

• 小鱼使用手中的密码本， 将明文信息生成密文， 该密文也仅由小写字母组成且与 明文等长；

• 小鱼将密文发送给小明；

• 小明使用手中的密码本（内容与小鱼的密码本很可能不同），将密文解密为明文， 该明文与小鱼的原信息一定是相同的。

解密密码本

虽然你不知道小鱼是如何加密的，但是你拿到了小明用来解密的密码本。

小明的密码本共有 n 页（从 1 到 n 编号）。每页有 26 行，对应着字母 a 到 z。每 行写有一个小写字母 out 和一个整数 next（1 ≤ next ≤ n）。对于每一页，其上面的 26 个 out 是两两不同的。

小明在解密信息时， 先将密码本翻到第 1 页，然后对于密文的每一个字符依次进行 以下操作：在当前页找到该字符对应的行， 在纸上写下该行的 out 字符，并将密码本翻 到第 next 页。扫描完密文的每个字符后，纸上写下的字符就依次形成了明文。

下面是一个密码本的例子：

1

2

3

4

5

6

7

|     |     |     |
| --- | --- | --- |
| 'a'<br><br>'b'<br><br>'c'<br><br>'d'<br><br>'z' | Page 1<br><br>(out='x',next=1)<br><br>(out='y',next=2)<br><br>(out='z',next=2)<br><br>......<br><br>......<br><br>...... | Page 2<br><br>(out='w',next=2)<br><br>(out='z',next=1)<br><br>(out='y',next=2)<br><br>......<br><br>......<br><br>...... |

在这个例子下，如果小明收到的密文为 abac，则相应的解密过程如下：

• 初始时，将密码本翻到第 1 页；

• 遇到密文字符 a，查到 out 为 x，next 为 1，则向纸上写字符 x，密码本仍在第 1 页；

• 遇到密文字符 b，查到 out 为 y，next 为 2，则向纸上写字符 y，将密码本翻到 第 2 页；

• 遇到密文字符 a，查到 out 为 w，next 为 2，则向纸上写字符 w，密码本仍在第 2 页；

• 遇到密文字符 c，查到 out 为 y，next 为 2，则向纸上写字符 y，密码本仍在第

2 页。

所以，解密得到的明文为 xywy。

词典

你还拿到了一个词典，小鱼和小明的通信内容明文都是由这个词典中的字符串拼接 而成的。词典中不会有空串， 不会有两个完全相同的单词， 也不会存在某个单词是另一

. . . . . . . . . . .

个单词的前缀。

. . . . . .

例如，词典有 4 个单词：

1

2

3

4

dog

is

good

happy

那么 dogishappy、happydogisgooddog 都是可能出现的通信内容， 但是 dogood、 hisappy 是不合法的明文。

此外，小鱼在编写明文时，会特别注意使它对应的密文“看起来像密文”。“看起来像 密文”是指，对应的密文当中不应当包含词典中的任何词作为子串。例如明文 doggood 本身符合词典的要求，但假设它对应的密文是 xisxxyz， 由于其中包含了 is 为子串， 则小鱼也不会编写 doggood 这一明文。

本题的任务

给定小明的解密密码本和词典，我们定义 k-合法密文是指：

• 长度为 k，仅包含小写字母的字符串；

• 不包含词典中的任何一个串为子串；

• 其对应的明文可以通过词典中的字符串拼接而成。

除了密码本和词典以外， 我们还输入正整数 m。你需要对于 k = 1, 2, 3, . . . , m 输出 k-合法密文的数量。由于答案可能很大，每个数只需要对 998244353 取模后输出即可。

【输入格式】

从标准输入读入数据。

第一行输入两个正整数 n, m。

接下来输入小明的解密密码本。密码本包含 26 行，每行有 n 个元素。其中第 i 行 第 j 列的元素输入密码本第 j 页第 i 行的内容。每个元素先输入 out，后输入 next。例 如输入 y2 表示 out 为 y，next 为 2 。注意字母和数字之间没有空格。

接下来输入词典，词典的每个单词占据一行。

【输出格式】

输出到标准输出。

输出 m 行，每行一个整数，依次表示 k = 1, k = 2, . . . , k = m 时，k-合法密文的数 量，对 998244353 取模的结果。

【样例 1 输入】

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

2 4

x2 w2

y2 z1

z1 y2

a2 x1

b2 a2

c1 b1

d2 c2

e2 d1

f1 e2

g2 f1

h2 g2

i1 h1

j2 i2

k2 j1

l1 k2

m2 l1

n2 m2

o1 n1

p2 o2

q2 p1

r1 q2

s2 r2

t2 s1

u1 t2

v2 u1

w2 v2

a

de

hh

【样例 1 输出】

1

2

3

4

1

2

3

5

【样例 1 解释】

|     |     |     |
| --- | --- | --- |
| k   | k-合法密文 | 对应的明文 |
| \= 1 | d   | a   |
| \= 2 | gi  | de  |
| kl  | hh  |
| \= 3 | dlk | ahh |
| gie | dea |
| kld | hha |
| \= 4 | dlke | ahha |
| giee | deaa |
| gilk | dehh |
| klgi | hhde |
| klkl | hhhh |

【样例 2 输入】

1 30

1

2

3

4

5

6

7

8

9

10

11

12

13

n1

b1

k1

w1

l1

q1

r1

y1

h1

o1

f1

d1

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

u1

i1

g1

p1

c1

m1

v1

x1

j1

t1

z1

e1

s1

a1

yyyyy

a

sss

ffff

uuuu

n

rrrrr

zzzz

dd

l

w

x

jjj

i

tttt

kkk

ee

ggg

qq

【样例 2 输出】

1

4

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

15

62

254

1037

4238

17318

70762

289147

1181515

4827896

19727703

80611180

329392745

347717570

508636782

512101020

990699955

897183687

992683554

367164478

441771655

282208579

707622895

680435638

349679885

49272719

821317456

174000209

371253693

【样例 2 解释】

该样例的输入文件与第 18 个测试点仅有 m 不同（详见下述）。

【子任务】

本题共 25 个测试点，每个 4 分。

对于所有的测试点， 1 ≤ n ≤ 50, 1 ≤ m ≤ 1000，词典不为空且所有单词的长度之和 不超过 50。

对于编号为偶数的测试点，n = 1。

其他的特殊性质如下表所述：

|     |     |
| --- | --- |
| 测试点编号 | 特殊性质 |
| 1,2 | m = 2 |
| 3,4 | m = 3 |
| 5,6 | m = 4 |
| 7,8 | 每个单词长度至少为 7 |
| 9,10 | 每个单词长度至少为 8 |
| 11,12 | 每个单词长度至少为 9 |
| 13,14,15,16 | 每个单词长度均为 1 |
| 17,18,19,20 | 每个单词均由一种字母重复组成（如 aaaaa 、b 、ccc） |
| 21,22,23,24,25 | 无   |

第 **19** 次 **CCF CSP** 认证 CSP 202006

时间：2019 年 12 月 15 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 线性分类器 | 稀疏向量 | Markdown<br><br>渲染器 | 1246 | 乔乔和牛牛 逛超市 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 2.0 秒 | 1.0 秒 | 1.0 秒 | 1.0 秒 |
| 内存限制 | 512 MiB | 512 MiB | 512 MiB | 512 MiB | 512 MB |
| 子任务数目 | 20  | 10  | 10  | 25  | 10  |
| 测试点是否等 分 | 是   | 是   | 是   | 是   | 是   |

线性分类器（line）

**1**

**2**

**3**

【题目描述】

考虑一个简单的二分类问题——将二维平面上的点分为A 和B 两类。

训练数据包含 _n_ 个点，其中第 _i_ 个点（1 ≤ _i_ ≤ _n_）可以表示为一个三元组 (_xi_, _yi_, _typei_ )， 即该点的横坐标、纵坐标和类别。

在二维平面上， 任意一条直线可以表示为 θ0 + θ1 _x_ \+ θ2_y_ \= 0 的形式，即由 θ0 、θ1 和 θ2 三个参数确定该直线，且满足 θ1 、θ2 不同时为 0。

基于这 _n_ 个已知类别的点，我们想要在平面上找到一条直线作为一个线性分类器。 具体来说，这条线要把训练数据中的A、B 两类点完美分隔开来，即一侧只有A 类点、另

. . . .

一侧只有B 类点。这样， 对于任意一个的未知类别的点， 我们就可以根据它是位于直线 的哪一侧来预测它的类别了。

在本题中我们仅需要处理 _m_ 个如下查询：给定一条直线，判断它是否能将训练数 据中的A、B 两类点完美分开。

【输入格式】

从标准输入读入数据。

输入共 _n_ \+ _m_ \+ 1 行。

第一行包含用空格分隔的两个正整数 _n_ 和 _m_，分别表示点和查询的个数。

第二行到第 _n_ \+ 1 行依次输入 _n_ 个点的信息。第 _i_ \+ 1 行（1 ≤ _i_ ≤ _n_）包含用空格分 隔的三项 _xi_、_yi_ 和 _typei_ ，分别表示第 _i_ 个点的横、纵坐标和类别， 其中坐标为整数、类 别为一个大写英文字母A 或B。

第 _n_ \+ 2 行到第 _n_ \+ _m_ \+ 1 行依次输入 _m_ 个查询。第 _j_ \+ _n_ \+ 1 行（1 ≤ _j_ ≤ _m_）包含 用空格分隔的三个整数 θ0 、θ1 和 θ2 ，表示第 _j_ 个查询中给定直线的三个参数。

【输出格式】

输出到标准输出。

输出共 _m_ 行，每行输出一个字符串。

第 _j_ 行（1 ≤ _j_ ≤ _m_）输出的字符串对应第 _j_ 个查询的结果：如果给定直线可以完 美分隔A、B 两类点，则输出Yes；否则输出No。

【样例 1 输入】

r

9

3

1

0

1

1

A

A

、

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**12**

**13**

1 -1 A

2 2 B

2 3 B

0 1 A

3 1 B

1 3 B

2 0 A

0 2 -3

\-3 0 2

\-3 1 1

、 ,

【样例 1 输出】

**1** No

**2** No

**3** Yes

(

、

、

,

【样例 1 解释】

只有第 3 个查询给出的直线能将A、B 两类点完美分隔。

4

A

B

2x - 3y = 0

\-3 + 2y = 0

\-3 + x + y = 0

3

2

y

1

0

\-1

\-1 0 1 2 3 4

x

【子任务】

• 输入数据保证不存在恰好落在给定直线上的点；

. . .

• 0 < _n_ ≤ 103 、0 < _m_ ≤ 20，且A、B 两类点的数量均不为 0；

• 所有点的坐标和给定直线的三个参数均为整数，且绝对值 ≤ 106；

• 任意两个点的坐标不完全相同。

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点 | θ0  | θ1  | θ2  |
| 1,2,3,4,5 | 不为零 | \= 0 | 不为零 |
| 6,7,8,9,10 | 不为零 | 不为零 | \= 0 |
| 11,12,13,14,15 | \= 0 | 不为零 | 不为零 |
| 16,17,18,19,20 | 不为零 | 不为零 | 不为零 |

稀疏向量（svector）

【题目描述】

对于一个 _n_ 维整数向量 **v** ∈ Z_n_ ，其在第 _index_ 个维度上的取值记作 **v**_index_。这里我 们约定 _index_ 的取值从 1 开始， 即 **v** \= (**v**1 , **v**2 , · · · , **v**_n_ )。下面介绍一种向量的稀疏表示 方法。

如果 **v** 仅在少量维度上的取值不为 0，则称其为稀疏向量。

例如当 _n_ \= 10 时，**v** \= (0, 0, 0, 5, 0, 0, -3, 0, 0, 1) 就是一个稀疏向量。

由于稀疏向量的非零值较少， 我们可以通过仅存储非零值的方式来节省空间。具体 来说，每个非零值都可以用一个 (_index_, _value_) 对来表示，即该向量在第 _index_ 个维度上 的取值 **v**_index_ \= _value_ ≠ 0。在上面的例子中， **v** 就可以表示为 \[(4, 5), (7, -3), (10, 1)\]。

接下来给出这种稀疏表示一般化的定义。

• 对于任意一个 _n_ 维整数向量 **v** ∈ Z_n_ ，如果其在且仅在 _a_ 个维度上取值不为 0，则 可以唯一表示为：

\[(_index_1, _value_1 ), (_index_2, _value_2 ), · · · , (_indexa_, _valuea_ )\]

• 其中所有的 _index_ 均为整数且满足：

1 ≤ _index_1 < _index_2 < · · · < _indexa_ ≤ _n_

• _valuei_ 表示向量 **v** 在对应维度 _indexi_ 上的非零值。

给出两个 _n_ 维整数向量 **u**, **v** ∈ Z_n_ 的稀疏表示，试计算它们的内积。

【输入格式】

从标准输入读入数据。

输入的第一行包含用空格分隔的三个正整数 _n_ 、_a_ 和 _b_，其中 _n_ 表示向量 **u** 、**v** 的 维数，_a_ 和 _b_ 分别表示两个向量所含非零值的个数。

第二行到第 _a_ \+ 1 行输入向量 **u** 的稀疏表示。第 _i_ \+ 1 行（1 ≤ _i_ ≤ _a_）包含用空格分 隔的两个整数 _indexi_ 和 _valuei_，表示 **u**_indexi_ \= _valuei_ ≠ 0。

第 _a_ \+ 2 行到第 _a_ \+ _b_ \+ 1 行输入向量 **v** 的稀疏表示。第 _j_ \+ _a_ \+ 1 行（1 ≤ _j_ ≤ _b_）包 含用空格分隔的两个整数 _indexj_ 和 _valuej_，表示 **v**_index j_ \= _valuej_ ≠ 0。

【输出格式】

输出到标准输出。

输出一个整数，表示向量 **u** 和 **v** 的内积 **u** · **v**。

【样例输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

、

10 3 4

4 5

7 −3

10 1

1 10

4 20

5 30

7 40

、 ,

【样例输出】

**1** −20

、

、 ,

【样例解释】

**u** \= (0, 0, 0, 5, 0, 0, −3, 0, 0, 1)

**v** \= (10, 0, 0, 20, 30, 0, 40, 0, 0, 0)

**u** · **v** \= 5 × 20 + (−3) × 40 = −20

【子任务】

• 输入数据保证 0 < _a_, _b_ < _n_；

• 向量 **u** 和 **v** 在每一维度上取值的绝对值 |**u**_i_ | , |**v**_i_ | ≤ 106（1 ≤ _i_ ≤ _n_）。

|     |     |     |
| --- | --- | --- |
| 测试点 | _n_ | _a_, _b_ |
| 1,2,3 | ≤ 105 | ≤ 103 |
| 4,5,6 | ≤ 5 × 105 | ≤ 105 |
| 7,8,9,10 | ≤ 109 | ≤ 5 × 105 |

Markdown 渲染器（markdown）

【题目背景】

Markdown 是一种轻量级的标记语言， 它可以用较为简单的符号来标记文本中的成 分的意义。通过套用适当的样式， 即可生成一份美观的文档。 Markdown 由于其轻量级 的特性，深受喜爱，并在各种方面得到了广泛的运用。本题需要你解析并渲染简化的 Markdown 文档。

【题目描述】

本题中，你需要按照下述要求，在终端屏幕上渲染简单的 Markdown 文档。终端 屏幕，可以被视为宽度为 _w_ 单位，长度为无限长单位的方格，每个方格中可以被填充 至多一个字符。可选地，每个方格中的字符可以带有一定的样式。在这个终端屏幕中， 可以按照下列方法，渲染 Markdown 文档中的各个元素。

段落

在 Markdown 文档中，换行符将文档分为若干行。仅包含零个或多个空格的行被 称为“空白行”。空白行将整个文档分割成了若干段落。例如，下面的示例文档中包含 有 5 个空白行，行号分别是 2 、6 、7 、9 、10，他们将该文档分成了 3 个段落。为了能 够便于你阅读，“˽”符号表示空格。“¬”符号表示换行符。

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

、

CSP¬

¬

CSP˽ is¬

a˽ real˽ real real real real real˽¬

˽˽˽˽˽ competition . ¬

¬

¬

˽˽˽

Come˽˽˽ and˽˽˽ join˽˽˽ us˽˽˽¬

¬

¬

、 ,

在渲染一个段落前，应该去掉每行首尾的连续空格。如果一个段落包含有多行文 本，那么将各个行用一个空格连接起来， 形成一个不含换行符的连续的段落文本。渲染 段落时，应当首先与之前的段落或项目列表空出一行的间距，从新的一行开始连续将段 落中的文本从左至右渲染在屏幕上。如果段落中的字符超出了终端的宽度，那么则应 当从终端的下一行开始继续渲染其余的文本。如果余下的文本恰好是以空格字符开头，

那么应该将这些连续的空格字符删除。上述文本按照这样的规则，在一个宽度为 10 的 终端中渲染，其结果为：

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**12**

**13**

、

1

+1---5----0+

1 |CSP |

2 | |

3 |CSP is a r |

4 |eal real re|

5 |al real real|

6 |real compe |

7 |tition . |

8 | |

9 |Come and|

10 |join us |

+----------+

、 ,

项目列表

“项目”由连续的若干行文本组成，其中第一行必须以星号和空格（\*˽) 开头，其 余的行（如果有）为以两个空格( ˽˽ ) 开头的非空白行。“项目列表”由连续的一个或 多个项目组成，其中各个项目之间没有空白行或开头不是两个空格的行。如果两个项 目列表之间没有空白行或开头不是两个空格的行，那么它们应当被视为一个项目列表。 例如，下列文本中，行 1 、行 3-5、行 6-7、行 9 和行 10 组成了 5 个项目，它们分别属 于 3 个项目列表，因为它们被空行（行 3）、段落（行 8）分隔开来。

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

、

\*˽CSP¬

¬

˽˽˽˽

\*˽˽˽CSP˽ is¬

˽˽\*˽ a˽ real˽˽¬

˽˽˽˽˽ competition . ¬

\*

¬

˽

˽˽\*˽Come !˽˽˽and˽˽˽ join . ¬

\*Tel : ¬

\* 12345 ¬ ˽

\*

¬

˽

、 ,

在渲染一个项目列表时， 应当首先与之前的段落或项目列表空出一行的间距，从新 的一行开始连续渲染每个项目。在渲染一个项目前，先把这个项目的各个文本行首的 两个空格字符或星号空格字符去掉。渲染时， 从新的一行开始，输出空格、点号、空格 ( ˽ ·˽ ) 符号，然后按照渲染一个段落的规则，渲染该项目中的各个文本行。但是，在 终端上输出一个项目的随后的行时， 应当插入三个空格( ˽˽˽ ), 以使这些行与第一行对 齐。特别地， 如果一个项目的首行除行首的星号空格字符外， 没有其它的字符， 那么应 当直接从项目的余下的行开始渲染该项目（例如上述文本第 6 行）；如果仅有一行，那 么认为这个项目渲染结束（例如上述文本第 10 行）。上述文本按照该规则，在一个宽 度为 10 的终端中渲染，其结果为：

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

**10**

**11**

**12**

**13**

**14**

**15**

**16**

**17**

、

1

+1---5----0+

1 | · CSP |

2 | |

3 | · CSP is |

4 | \* a rea |

5 | l compe |

6 | tition . |

7 | · \* Come ! |

8 | and j |

9 | oin . |

10 | |

11 |\*Tel : |

12 | | 13 | · 12345 |

14 | · |

+----------+

、 ,

这里，原文本第 2 行是空白行，将前后两个项目分成了两个项目列表， 因此在输 出终端中，二者之间有空行分隔。原文本第 8 行，开头不是星号和空格， 因此是一个单 独的段落。

【输入格式】

从标准输入读入数据。

输入第一行包含一个数字 _w_，是终端宽度。随后从第二行开始，是被渲染的文本。

【输出格式】

输出到标准输出。

输出一行，是一个数字，表示渲染所需终端行数。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

、

10

CSP

CSP is

a real real real real real real

competition .

Come and join us

、 ,

【样例 1 输出】

**1** 10

、

、 ,

【样例 1 解释】

该输入是本题第一个例子，渲染共需 10 行。

**1**

**2**

**3**

**4**

**5**

**6**

**7**

**8**

**9**

【样例 2 输入】

、

10

\* CSP

\* CSP is

\* a real

competition .

\*

\* Come ! and join .

\*Tel :

**10**  \* 12345 **11**  \*

、 ,

【样例 2 输出】

**1** 14

(

、

、

,

【样例 2 解释】

该输入是本题第二个例子，渲染共需 14 行。

【子任务】

• 对于 10% 的测试点，仅包含段落，且每个段落仅包含一行文本，且每行文本长 度不超过 _w_；

• 对于 20% 的测试点，仅包含段落，且每个段落仅包含一行文本；

• 对于 40% 的测试点，仅包含段落；

• 对于 60% 的测试点，仅包含段落和至多一个项目列表，且输入数据大小在 2.5 MiB 以内；

• 对于 80% 的测试点，包含零个或多个段落和项目列表， 且 _w_ ≤ 103 ，输入数据大 小在 5 MiB 以内；

• 对于 100% 的测试点，包含零个或多个段落和项目列表， 4 ≤ _w_ ≤ 104 ，输入数据 中仅包括 ASCII 字符，输入数据大小在 20 MiB 以内。

【提示】

函数fgets 的声明是char \* fgets ( char \* str, int num, FILE \* stream );，其 功能是从stream 中读取字符并按照 C 字符串的格式存储在str 中，直到读入了 (num - 1) 个字符或到达了换行符或文件末尾，以先遇到的为准。

换行符可以使fgets 停止读取，但是该函数仍然认为换行符是合法的字符，并将其 包含在拷贝入str 的字符串中。一个终止的\\\\0 字符会自动地添加在拷贝到str 的字符 后面。

当成功时，该函数返回str。如果在试图读取字符时，遇到了文件末尾，那么 eof 标志会被设置。如果这个情况发生在成功读取任何字符之前， 该函数会返回空指针， 并 且str 的内容不会被改变。

函数feof 的声明是int feof ( FILE \* stream );，其功能是检查stream 的 eof 标 志是否被设置。如果 eof 标志被设置，则返回非零值；否则返回 0。

1246（digits）

【题目描述】

1, 2, 4, 6 这四个数字有一个神奇的性质：如果将其分别取以 2 为底的幂，得到的分 别是 2, 4, 16, 64 ，仍是由这四个数字组成的。

我们从数字串1 开始，每秒钟它的每一位都会独立地变成 2 的幂。例如， 在前几秒 钟，数字串会依次变成：

1\. 2

2\. 4

3\. 16 4. 264

5\. 46416

6\. 166416264

7\. 264641626446416

8\. 46416641626446416166416264

9\. 166416264641626446416166416264264641626446416

显然，这些数字串都仅包含 1, 2, 4, 6 这四个数字。

输入整数 _n_ 和数字串 _S_， 请你求出 _S_ 在第 _n_ 秒钟的数字串共出现了几次？ 由于答 案可能很大，只需要你输出它对 998244353 取模的结果。

【输入格式】

从标准输入读入数据。

包含两行，第一行为一个数 _n_，第二行为一个串 _S_ 。

【输出格式】

输出到标准输出。

仅有一行，含有一个整数，表示所求的答案。

【样例 1 输入】

**1** 9

**2** 26

、

、 ,

【样例 1 输出】

**1** 5

、

、 ,

【样例 1 解释】

第 9 秒的数字串为166416264641626446416166416264264641626446416，其中出现了 5 次26。

【样例 2 输入】

**1**

**2**

2020

16

、

、 ,

【样例 2 输出】

**1** 292008622

、

、 ,

【子任务】

对于所有的数据，保证要输出的答案不为 0，保证 0 ≤ _n_ ≤ 109 ，1 ≤ |_S_| ≤ 105。

|     |     |     |
| --- | --- | --- |
| 测试点 | _n_ | \|_S_\| |
| 1,2,3,4 | ≤ 20 | \= 1 |
| 5,6,7,8 | \= 2 |
| 9,10,11,12 | ≤ 1000 | \= 1 |
| 13,14,15,16 | \= 2 |
| 17,18,19,20 | ≤ 109 | \= 1 |
| 21,22,23,24 | \= 2 |
| 25  | ≤ 105 |

乔乔和牛牛逛超市（supermarket）

【题目描述】

乔乔和牛牛去逛超市了， 超市里有 _n_ 种商品，他们决定买一些商品回家。但是， 第

_i_ 种商品一旦被选择，购买的个数就必须是 _Li_ 和 _Ri_ 之间的整数（含端点）。 某些商品之间有依赖关系，依赖关系有两种：

• 1、只有第 _x_ 种商品被购买了，第 _y_ 种商品才可以被购买。

• 2、只有第 _x_ 种商品被购买了，第 _y_ 种商品的购买个数才可以恰好是 _Lx_ 或 _Rx_ 。

购买一个商品的带来的开心程度和这个商品购买的个数有关， 若第 _i_ 个商品购买了

_xi_ 个 _xi_ \> 0 ，则收益为 _aix_ \+ _bi xi_ \+ _ci_ ，否则为 0 。

现在牛牛和乔乔想知道逛超市的最大总开心程度是多少，你能帮他们选购商品并 确定购买商品数量吗？

【输入格式】

从标准输入读入数据。

第一行包含两个整数 _n_ ，_m_ ，表示商品数量和依赖关系数量。 0 ≤ _n_ ≤ 104 , 0 ≤ _m_ ≤ 105 。

接下来 _n_ 行，每行包含五个整数 _Li_, _Ri_, _ai_, _bi_ , _ci_ ，描述一个商品。 1 ≤ _Li_ ≤ _Ri_ ≤ 104 , -5 ≤ _a_ ≤ 5, -104 ≤ _bi_ , _ci_ ≤ 104 , _Li_ \+ 1 ≤ _Ri_ \- 1 。

接下来 _m_ 行，每行包含三个整数 _z_, _x_, _y_ ，表示第 _x_ 种商品对第 _y_ 种商品存在第 _z_ 种关系。 1 ≤ _x_, _y_ ≤ _n_, 1 ≤ _z_ ≤ 2。

【输出格式】

输出到标准输出。

输出一个整数，表示最大总开心程度。

【样例 1 输入】

**1**

**2**

**3**

**4**

**5**

、

2 2

1 10 -2 3 -5

1 10 2 3 5

2 1 2

1 2 1

、 ,

【样例 1 输出】

**1** 231

、

、 ,

【样例 1 解释】

第 1 种商品购买 1 个，第 2 种商品购买 10 个。

【子任务】

对于 20% 的数据，_n_ ≤ 10, _Ri_ ≤ 5 ；

对于 40% 的数据，_n_ ≤ 10 ；

对于另外 20% 的数据，只有第 1 种依赖关系。

第 **18** 次 **CCF CSP** 认证 CSP 201912

时间：2019 年 12 月 15 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 报数  | 回收站选址 | 化学方程式 | 区块链 | 魔数  |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 1.0 秒 | 1.0 秒 | 1.0 秒 | 10.0 秒 | 1.0 秒 |
| 内存限制 | 512 MB | 512 MB | 512 MB | 512 MB | 1024 MB |
| 子任务数目 | 10  | 10  | 10  | 5   | 20  |
| 测试点是否等 分 | 是   | 是   | 是   | 否   | 是   |

报数（seven）

【题目描述】

甲乙丙丁决定玩一个报数的游戏来打发时间。游戏规则为四个人从 1 开始轮流进 行报数，但如果需要报出的数是 7 的倍数或含有数字 7 则直接跳过。

此外大家约定，在总共报出了 _n_ 个数后（不计入被跳过的数）游戏结束。现在需要 你来帮忙统计，游戏过程中每个人各自跳过了几次。

【输入格式】

从标准输入读入数据。

输入仅一行，包含一个正整数 _n_，表示报出了多少个数后游戏结束。

【输出格式】

输出到标准输出。

输出共四行，每行一个整数，依次表示甲乙丙丁四人在游戏过程中跳过的次数。

【样例 1 输入】

20

【样例 1 输出】

2

1

1

0

【样例 1 解释】

报数过程为：

甲：1，乙：2，丙： 3，丁：4

甲：5，乙：6，丙：跳过，丁： 8

甲：9，乙：10，丙：11，丁：12

甲：13，乙：跳过，丙： 15，丁：16

甲：跳过，乙：18，丙：19，丁：20

甲：跳过，乙：22，丙：23，丁：24

在丁报出 24 后，四个人总计报出了 20 个数，游戏结束。

【样例 2 输入】

66

【样例 2 输出】

7

5

11

5

【子任务】

• 测试点 1 、2 、3 、4 和 5，保证 _n_ ≤ 102；

• 测试点 6 、7 、8 、9 和 10，保证 _n_ ≤ 666。

回收站选址（clean）

【题目背景】

开学了，可是校园里堆积了不少垃圾杂物。

热心的同学们纷纷自发前来清理，为学校注入正能量 ~

【题目描述】

通过无人机航拍我们已经知晓了 _n_ 处尚待清理的垃圾位置，其中第 _i_（1 ≤ _i_ ≤ _n_） 处的坐标为 (_xi_, _yi_ ) ，保证所有的坐标均为整数。

我们希望在垃圾集中的地方建立些回收站。具体来说，对于一个位置 (_x_, _y_) 是否适 合建立回收站，我们主要考虑以下几点：

• (_x_, _y_) 必须是整数坐标，且该处存在垃圾；

• 上下左右四个邻居位置， 即 (_x_, _y_ \+ 1) 、(_x_, _y_ − 1) 、(_x_ \+ 1, _y_) 和 (_x_ − 1, _y_) 处，必须 全部存在垃圾；

• 进一步地，我们会对满足上述两个条件的选址进行评分，分数为不大于 4 的自 然数，表示在 (_x_ ± 1, _y_ ± 1) 四个对角位置中有几处存在垃圾。

现在，请你统计一下每种得分的选址个数。

【输入格式】

从标准输入读入数据。

输入总共有 _n_ \+ 1 行。

第 1 行包含一个正整数 _n_，表示已查明的垃圾点个数。

第 1 + _i_ 行（1 ≤ _i_ ≤ _n_）包含由一个空格分隔的两个整数 _xi_ 和 _yi_ ，表示第 _i_ 处垃圾 的坐标。

保证输入的 _n_ 个坐标互不相同。

【输出格式】

输出到标准输出。

输出共五行，每行一个整数，依次表示得分为 0 、1 、2 、3 和 4 的回收站选址个数。

【样例 1 输入】

7

1 2

2 1

0

1

1

2

0

0

1

0

0

1

【样例 1 输出】

0

0

1

0

0

【样例 1 解释】

如图所示，仅有 (1, 1) 可选为回收站地址，评分为 2。

【样例 2 输入】

2

0 0

\-100000 10

【样例 2 输出】

0

0

0

0

0

【样例 2 解释】

不存在可选地址。

【样例 3 输入】

11

9 10

10 10

11 10

12 10

13 10

11 9

11 8

12 9

10 9

10 11

12 11

【样例 3 输出】

0

2

1

0

0

【样例 3 解释】

1 分选址：(10, 10) 和 (12, 10)；

2 分选址：(11, 9)。

【子任务】

• 测试点 1 和 2，保证对于任意的 _i_ 皆满足 0 ≤ _xi_, _yi_ ≤ 2；

• 测试点 3 、4 和 5，保证对于任意的 _i_ 皆满足 0 ≤ _xi_, _yi_ ≤ 500；

• 测试点 6 、7 和 8，保证对于任意的 _i_ 皆满足 0 ≤ _xi_, _yi_ ≤ 109；

• 测试点 9 和 10，保证对于任意的 _i_ 皆满足 |_xi_ |, |_yi_ | ≤ 109 ，即坐标可以是负数。 所有的测试点保证 1 ≤ _n_ ≤ 103。

【提示】

本题中所涉及的坐标皆为整数，且保证输入的坐标两两不同。

化学方程式（chemeq）

【题目描述】

化学方程式，也称为化学反应方程式， 是用化学式表示化学反应的式子。给出一组 化学方程式，请你编写程序判断每个方程式是否配平（也就是方程式中等号左右两边的 元素种类和对应的原子个数是否相同）。

本题给出的化学方程式由大小写字母、数字和符号（包括等号 =、加号 +、左圆括 号 ( 和右圆括号 )）组成，不会出现其他字符（包括空白字符，如空格、制表符等）。化 学方程式的格式与化学课本中的形式基本相同（化学式中表示元素原子个数的下标用 正常文本，如 H2 O 写成 H2O），用自然语言描述如下：

• 化学方程式由左右两个表达式组成， 中间用一个等号 = 连接，如 2H2+O2=2H2O；

. . . . . . . . . .

• 表达式由若干部分组成，每部分由系数和化学式构成，部分之间用加号 + 连接， . . . . . . . . . .

如 2H2+O2、2H2O；

• 系数是整数或空串，如为空串表示系数为 1；

. . . . . . . . . .

• 整数由一个或多个数字构成；

. . . .

• 化学式由若干部分组成，每部分由项和系数构成，部分之间直接连接，如 H2O、 . . . . . .

CO2、Ca(OH)2、Ba3(PO4)2；

• 项是元素或用左右圆括号括起来的化学式，如 H、Ca、(OH)、(PO4)；

. . . . . . . . . . .

• 元素可以是一个大写字母，也可以是一个大写字母跟着一个小写字母，如 H、O、 . . . . . . . . . . . . . .

Ca。

用巴科斯范式（Backus-Naur form ，BNF）给出的形式化定义如下：

&lt;equation&gt; ::= &lt;expr&gt; "=" &lt;expr&gt;

&lt;expr&gt; ::= &lt;coef&gt; &lt;formula&gt; | &lt;expr&gt; "+" &lt;coef&gt; &lt;formula&gt;

&lt;coef&gt; ::= &lt;digits&gt; | ""

&lt;digits&gt; ::= &lt;digit&gt; | &lt;digits&gt; &lt;digit&gt;

&lt;digit&gt; ::= "0" | "1" | ... | "9"

&lt;formula&gt; ::= &lt;term&gt; &lt;coef&gt; | &lt;formula&gt; &lt;term&gt; &lt;coef&gt;

&lt;term&gt; ::= &lt;element&gt; | "(" &lt;formula&gt; ")"

&lt;element&gt; ::= &lt;uppercase&gt; | &lt;uppercase&gt; &lt;lowercase&gt;

&lt;uppercase&gt; ::= "A" | "B" | ... | "Z"

&lt;lowercase&gt; ::= "a" | "b" | ... | "z"

【输入格式】

从标准输入读入数据。

输入的第一行包含一个正整数 _n_，表示输入的化学方程式个数。

接下来 _n_ 行，每行是一个符合定义的化学方程式。

【输出格式】

输出到标准输出。

输出共 _n_ 行，每行是一个大写字母 Y 或 N， 回答输入中相应的化学方程式是否 配平。

【样例输入】

11

H2+O2=H2O

2H2+O2=2H2O

H2+Cl2=2NaCl

H2+Cl2=2HCl

CH4+2O2=CO2+2H2O

CaCl2+2AgNO3=Ca(NO3)2+2AgCl

3Ba(OH)2+2H3PO4=6H2O+Ba3(PO4)2

3Ba(OH)2+2H3PO4=Ba3(PO4)2+6H2O

4Zn+10HNO3=4Zn(NO3)2+NH4NO3+3H2O

4Au+8NaCN+2H2O+O2=4Na(Au(CN)2)+4NaOH

Cu+As=Cs+Au

【样例输出】

N

Y

N

Y

Y

Y

Y

Y

Y

Y

N

【子任务】

• 1 ≤ _n_ ≤ 100

• 输入的化学方程式都是符合题目中给出的定义的，且长度不超过 1, 000

• 系数不会有前导零，也不会有为零的系数

• 化学方程式的任何一边，其中任何一种元素的原子总个数都不超过 109

|     |     |
| --- | --- |
| 测试点编号 | 满足条件 |
| 1, 2 | 只包含大写字母和等号 |
| 3, 4 | 加入小写字母和加号 |
| 5, 6 | 加入数字 |
| 7, 8 | 加入圆括号，圆括号不会出现嵌套 |
| 9, 10 | 圆括号可以出现嵌套 |

区块链（blockchain）

【题目描述】

区块链涉及密码学、哈希算法、拜占庭问题、共识算法、故障模型、网络模型等诸 多知识，也在金融等领域有广泛的应用。本题中， 我们需要实现一个简单的区块链系统。

在一个分布式网络中，有 _n_ 个节点通过 _m_ 条边相连，节点编号从 1 至 _n_。每个节 点初始化都有一个相同的“创世块”，链长都为 1。每个节点在整个过程中都需要维护 一条主链，任何操作都只在主链上进行。在整个系统中产生的每个新块都有唯一的整 数编号，创始块的编号为 0，其余块的编号都为正整数。当某个节点的链更新时， 会将 它的主链发送给它相邻的节点（邻居）；而当节点收到链时， 决定是否更新自己的主链。 下列情况可能会导致某个节点的链更新：

• 某个节点接收到邻居发送过来的链，与当前自己的主链进行比较：

**\-** 如果接收到的链更长，则将其作为自己的主链；

**\-** 如果收到的链长度与自身主链相同，且最后一块编号更小，则将其作为自

. . . . . .

己的主链

**\-** 如果接收到的链更短，则直接忽略该链。

• 某个节点产生一个新块，将新块放在主链的尾部。

假设网络带宽足够大， 每个节点状态更新后， 会立刻将自己的主链同时发送给所有 邻居。每个节点在每个时刻总是先接收链， 再产生新块（注意这与实际的区块链工作方 式不相同）。每个节点发送、接收、产生块不消耗时间，只有在网络中传输链会消耗时 间。不过因为一些故障，这个网络可能会出现“分区”的情况，即出现多个子网络， 不 同子网络的节点无法互相收发消息。

在计算机中常用逻辑时钟来定义“时刻”。逻辑时钟初始时间为 0，以单位 1 递增。 任意节点传输一条链到其邻居所花费的时间相同，都为 _t_。现在已知整个网络的结构以 及每个节点产生新块的时间，需要查询特定时刻某个节点的主链。

【输入格式】

从标准输入读入数据。

保证题中所有输入均为整数，并且所有整数绝对值不大于 109。

第一行两个正整数分别为 _n_, _m_，分别表示网络的 _n_ 个节点和 _m_ 条边。

接下来 _m_ 行，每行 2 个正整数 _ui_ , _vi_ (1 ≤ _i_ ≤ _m_)，表示网络中节点 _ui_ 和节点 _vi_ 具 有（双向）连接。

接下来一行两个正整数 _t_, _k_，分别表示每次传输延时 _t_ 和操作（产生块或查询） 的 数量。

接下来 _k_ 行，每行 2 或 3 个正整数：

• 如果是三个数 _ai_, _bi_, _ci_ ，表示节点 _ai_ 在 _bi_ 时刻产生了一个编号为 _ci_ 的块。保证 _bi_ ≤ _bi_+1 (1 ≤ _i_ < _k_)。

• 如果是两个数 _ai_, _bi_ ，表示查询节点 _ai_ 处理完 _bi_ 时刻及以前的所有操作后的主 链。保证对于同一时刻，任何查询在输入文件中都出现在当前时刻所有的新块被 产生之后。

【输出格式】

输出到标准输出。

依次输出若干行，分别对应每一次查询。

每行第一个正整数 _L_ 表示主链的长度，接下来 _L_ 个数表示主链每个块的编号。从 链头（一定为 0）到链尾依次输出。

【样例 1 输入】

5 10

1 2

1 3

1 4

1 5

2 3

2 4

2 5

3 4

3 5

4 5

1 27

1 1 1

2 1 2

3 1 3

4 1 4

5 1 5

1 1

2 1

3 1

4 1

5 1

1 2

2 2

3 2

4 2

5 2

1 10 10

2 11 9

1 11

2 11

3 11

4 11

5 11

1 12

2 12

3 12

4 12

5 12

【样例 1 输出】

2 0 1

2 0 2

2 0 3

2 0 4

2 0 5

2 0 1

2 0 1

2 0 1

2 0 1

2 0 1

3 0 1 10

4 0 1 10 9

3 0 1 10

3 0 1 10

3 0 1 10

4 0 1 10 9

4 0 1 10 9

4 0 1 10 9

4 0 1 10 9

4 0 1 10 9

【样例 1 解释】

网络中的节点与连接关系形成一张完全图。在时刻 1 时，所有节点都产生一个块， 所以查询结果主链长度都为 2 。主链更新后，将自己的主链发给所有邻居。

因为传输时间为 1，所以在时刻 2 时，所有节点都收到其他节点发来的主链并更 新，更新后发送新的主链给邻居。此时查询所有节点，主链都为 01。

节点 1 在时刻 10 产生了新的块 10，并发送给邻居。所有邻居在时刻 11 时接收到 节点 1 发送的块 10。同时， 节点 2 在时刻 11 产生了新块 11。所以， 时刻 11 时的节点 2 主链长为 4，其余节点主链长为 3。所有发生更新的节点在时刻 11 时向邻居发送自 己的主链。

所以在时刻 12 时，所有节点的主链长为 4。

【样例 2 输入】

15 13

1 2

2 3

3 4

4 5

1 6

6 7

7 8

8 9

1 10

10 11

11 12

12 13

14 15

6 28

1 1 1

1 2 2

1 6

2 7

13 7

9 7

5 7

3 14

8 14

5 14

11 14

9 25

5 25

13 25

9 29 3

5 29 4

13 29 5

1 53

2 59 6

2 59

1 1000

3 1000

8 1000

9 1000

10 1000

13 1000

14 1000

15 1000

【样例 2 输出】

3 0 1 2

2 0 1

1 0

1 0

1 0

3 0 1 2

1 0

1 0

3 0 1 2

2 0 1

2 0 1

2 0 1

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 4<br><br>5<br><br>5<br><br>5<br><br>5<br><br>5<br><br>5<br><br>5<br><br>1<br><br>1 | 0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0<br><br>0 | 1<br><br>1<br><br>1<br><br>1<br><br>1<br><br>1<br><br>1<br><br>1 | 2<br><br>2<br><br>2<br><br>2<br><br>2<br><br>2<br><br>2<br><br>2 | 3<br><br>3<br><br>3<br><br>3<br><br>3<br><br>3<br><br>3<br><br>3 | 6<br><br>6<br><br>6<br><br>6<br><br>6<br><br>6<br><br>6 |

【子任务】

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 测试点编号 | _n_ ≤ | _m_ ≤ | _t_ ≤ | _k_ ≤ | _L_ ≤ |
| 1   | 10  | 30  | 10  | 500 | 30  |
| 2   | 10  | 30  | 10  | 500 | 30  |
| 3   | 50  | 102 | 102 | 5,000 | 102 |
| 4   | 50  | 102 | 102 | 5,000 | 102 |
| 5   | 50  | 102 | 102 | 104 | 250 |
| 6   | 50  | 102 | 102 | 104 | 250 |
| 7   | 102 | 103 | 102 | 3 ×104 | 350 |
| 8   | 102 | 103 | 102 | 3 ×104 | 350 |
| 9   | 500 | 104 | 103 | 3 ×104 | 500 |
| 10  | 500 | 104 | 103 | 3 ×104 | 500 |

魔数（magic）

【题目背景】

“魔数”是指代码中出现但没有解释的数字常量。即使代码是你亲手写下的，很可 能在几个月以后你也不记得这些魔数的意义了。而这道题中魔数的含义， 就需要你自己 探索了......

在本题中，我们定义：

• _U_0 = 314882150829468584

• _U_1 = 427197303358170108

• _U_2 = 1022292690726729920

• _U_3 = 1698479428772363217

• _U_4 = 2006101093849356424

• _f_ (_x_) = (_x_ mod 2009731336725594113) mod 2019

【题目描述】

有一个长度为 _n_ 的序列 _A_。初始时所有元素依次为从 1 到 _n_ 的正整数， 即 _Ai_ \= _i_(1 ≤ _i_ ≤ _n_)。

有 _q_ 次查询，每次查询输入两个整数 _l_, _r_(1 ≤ _l_ ≤ _r_ ≤ _n_)，你需要依次进行以下操作：

• 设 _s_ \= _f_(_Al_ ) + _f_ (_Al_+1) + · · · + _f_ (_Ar_ )；

• 输出 _s_；

• 设 _t_ \= _s_ mod 5；

• 令 _Al_, _Al_+1 , . . . , _Ar_ 的每个数都乘以 _Ut_。

请你依次输出每一次查询的答案。

【输入格式】

从标准输入读入数据。

第一行包含两个正整数 _n_, _q_。

接下来 _q_ 行，每行输入两个正整数 _l_, _r_。

【输出格式】

输出到标准输出。

输出 _q_ 行，每一行依次表示每一次查询的答案。

【样例 1 输入】

4

1

3

3

1

4

3

4

3

3

【样例 1 输出】

6

1105

1735

4744

【样例 2 输入】

100 100

45 74

38 50

7 45

42 62

83 100

50 51

8 11

93 98

64 70

15 87

30 87

13 79

14 81

18 79

70 88

25 39

13 57

55 85

80 92

83 90

54 75

1 61

17 42

25 49

39 77

32 45

83 87

30 47

59 84

25 50

1 82

21 45

72 96

3 85

16 64

52 92

28 29

84 88

26 93

10 67

27 76

57 62

43 69

63 66

5 59

9 46

49 53

35 50

3 19

23 62

38 73

17 68

34 83

42 91

13 92

19 62

17 70

18 75

95 99

35 90

81 91

59 63

5 90

22 87

51 88

25 61

56 91

50 78

11 60

11 18

27 45

57 82

16 54

3 94

33 56

9 71

68 88

24 36

7 64

48 85

58 76

20 43

9 90

24 27

71 97

25 95

73 97

55 83

22 43

53 55

68 88

12 44

25 87

14 46

34 56

15 35

7 80

46 87

23 71

88 93

【样例 2 输出】

1785

5741

10423

24915

1647

2154

1872

8559

12936

60048

52916

79974

61897

50541

16819

15646

48044

30156

14581

6906

17346

45805

25217

29837

44539

12602

5964

16894

23972

30665

64047

28029

26086

89745

49102

40236

2297

6040

64456

57625

48151

8311

27574

4166

52887

37703

4922

17603

17729

35771

35915

52458

54055

44140

70298

39690

49407

48808

4775

55131

9378

2839

75644

58663

40660

29344

38759

31862

51760

7924

22539

22003

31095

86980

25718

61094

18995

13703

56434

35626

18678

22776

82576

3233

24072

76470

23887

28161

26150

2017

19769

31420

63547

31533

24513

20199

62729

39286

43276

6109

【子任务】

|     |     |     |
| --- | --- | --- |
| 测试点编号 | _n_ | _q_ |
| 1   | 1   | 1   |
| 2   | 10  | 1   |
| 3   | 100 | 10  |
| 4   | 1000 | 100 |
| 5   | 10000 | 1000 |
| 6   | 100000 | 10000 |
| 7   | 120000 | 12000 |
| 8   | 140000 | 14000 |
| 9   | 160000 | 16000 |
| 10  | 190000 | 19000 |
| 11  | 230000 | 23000 |
| 12  | 270000 | 27000 |
| 13  | 320000 | 32000 |
| 14  | 370000 | 37000 |
| 15  | 440000 | 44000 |
| 16  | 520000 | 52000 |
| 17  | 610000 | 61000 |
| 18  | 720000 | 72000 |
| 19  | 850000 | 85000 |
| 20  | 1000000 | 100000 |

所有最终测试数据的生成方式为：

• 按照上表指定 _n_, _q_；

• 对于每次查询， _l_, _r_ 均在合法范围内独立均匀随机确定。

第 **17** 次 **CCF CSP** 认证 CSP 201909

时间：2019 年 9 月 15 日 13:30 ~ 17:30

|     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |
| 题目名称 | 小明种苹果 | 小明种苹果 （续） | 字符画 | 推荐系统 | 城市规划 |
| 题目类型 | 传统型 | 传统型 | 传统型 | 传统型 | 传统型 |
| 输入  | 标准输入 | 标准输入 | 标准输入 | 标准输入 | 标准输入 |
| 输出  | 标准输出 | 标准输出 | 标准输出 | 标准输出 | 标准输出 |
| 每个测试点时 限 | 2.0 秒 | 1.0 秒 | 5.0 秒 | 2.0 秒 | 1.0 秒 |
| 内存限制 | 512 MB | 512 MiB | 512 MB | 512 MB | 512 MiB |
| 子任务数目 | 10  | 10  | 5   | 6   | 4   |
| 测试点是否等 分 | 是   | 是   | 否   | 否   | 否   |

小明种苹果（apple）

【题目描述】

小明在他的果园里种了一些苹果树。为了保证苹果的品质， 在种植过程中要进行若 干轮疏果操作，也就是提前从树上把不好的苹果去掉。第一轮疏果操作开始前， 小明记

. .

录了每棵树上苹果的个数。每轮疏果操作时，小明都记录了从每棵树上去掉的苹果个 数。在最后一轮疏果操作结束后，请帮助小明统计相关的信息。

【输入格式】

从标准输入读入数据。

第 1 行包含两个正整数 _N_ 和 _M_，分别表示苹果树的棵数和疏果操作的轮数。

第 1 + _i_ 行（1 ≤ _i_ ≤ _N_）， 每行包含 _M_ \+ 1 个整数 _ai_0, _ai_1, . . . , _aiM_。其中 _ai_0 为正整 数，表示第一轮疏果操作开始前第 _i_ 棵树上苹果的个数。_aij_（1 ≤ _j_ ≤ _M_）为零或负整 数，表示第 _j_ 轮疏果操作时从第 _i_ 棵树上去掉的苹果个数。如果为零， 表示没有去掉苹 果；如果为负，其绝对值为去掉的苹果个数。

每行中相邻两个数之间用一个空格分隔。

【输出格式】

输出到标准输出。

输出只有一行，包含三个整数 _T_ 、_k_ 和 _P_。其中，

• _T_ 为最后一轮疏果操作后所有苹果树上剩下的苹果总数（假设苹果不会因为其 他原因减少）；

• _k_ 为疏果个数（也就是疏果操作去掉的苹果个数） 最多的苹果树编号（如有并列， 输出满足条件的最小编号）；

• _P_ 为该苹果树的疏果个数。

相邻两个数之间用一个空格分隔。输入数据保证是正确的， 也就是说，每棵树在全 部疏果操作结束后剩下的苹果个数是非负的。

【样例 1 输入】

3 3

73 -8 -6 -4

76 -5 -10 -8

80 -6 -15 0

【样例 1 输出】

167 2 23

【样例 1 解释】

第 1 棵苹果树的疏果个数为 8 + 6 + 4 = 18，第 2 棵为 5 + 10 + 8 = 23，第 3 棵为 6 + 15 + 0 = 21， 因此最后一轮疏果操作后全部苹果树上的苹果个数总和为 (73 - 18) + (76 - 23) + (80 - 21) = 167，疏果个数最多的是第 2 棵数，其疏果个数为 23。

【样例 2 输入】

2 2

10 -3 -1

15 -4 0

【样例 2 输出】

17 1 4

【样例 2 解释】

两棵树的疏果个数均为 4，应该输出编号最小的第 1 棵树。

【子任务】

|     |     |     |
| --- | --- | --- |
| 测试点 | _N_ | _M_ |
| 1, 2 | 1   | 1   |
| 3, 4 | 10  | 10  |
| 5, 6 | 100 | 10  |
| 7, 8 | 10  | 100 |
| 9, 10 | 1000 | 1000 |

|_aij_ | ≤ 106 ，对所有 1 ≤ _i_ ≤ _N_, 0 ≤ _j_ ≤ _M_。

小明种苹果（续）（apple2）

【题目描述】

小明在他的果园里种了一些苹果树，这些苹果树排列成一个圆。为了保证苹果的品 质，在种植过程中要进行疏果操作。为了更及时地完成疏果操作， 小明会不时地检查每 棵树的状态，根据需要进行疏果。检查时， 如果发现可能有苹果从树上掉落， 小明会重 新统计树上的苹果个数（然后根据之前的记录就可以判断是否有苹果掉落了）。在全部 操作结束后，请帮助小明统计相关的信息。

【输入格式】

从标准输入读入数据。

第 1 行包含一个正整数 _N_，表示苹果树的棵数。

第 1 + _i_ 行（1 ≤ _i_ ≤ _N_），每行的格式为 _mi_, _ai_1, _ai_2, . . . , _ai_,_mi_。其中， 第一个正整数 _mi_ 表示本行后面的整数个数。后续的 _mi_ 个整数表示小明对第 _i_ 棵苹果树的操作记录。若 _aij_（1 ≤ _j_ ≤ _mi_）为正整数，则表示小明进行了重新统计该棵树上的苹果个数的操作， 统 计的苹果个数为 _aij_ ；若为零或负整数，则表示一次疏果操作，去掉的苹果个数是 |_aij_ |。

输入保证一定是正确的，满足：

1\. _ai_1 > 0，即对于每棵树的记录，第一个操作一定是统计苹果个数（初始状态，此 时不用判断是否有苹果掉落）；

2\. 每次疏果操作保证操作后树上的苹果个数仍为正。

【输出格式】

输出到标准输出。

输出只有一行，包含三个整数 _T_ 、_D_ 、_E_。其中，

• _T_ 为全部疏果操作结束后所有苹果树上剩下的苹果总数（假设每棵苹果树在最 后一次统计苹果个数操作后苹果不会因为疏果以外的原因减少）；

• _D_ 为发生苹果掉落的苹果树的棵数；

• _E_ 为相邻连续三棵树发生苹果掉落情况的组数。

对于第三个统计量的解释：_N_ 棵苹果树 _A_1, _A_2, . . . , _AN_ 排列成一个圆，那么 _A_1 与 _A_2 相邻，_A_2 与 _A_3 相邻，...... ，_AN_\- 1 与 _AN_ 相邻，_AN_ 与 _A_1 相邻。如果 _Ai_\- 1, _Ai_, _Ai_+1 这三棵树都发生了苹果掉落的情况，则记为一组。形式化的，有

_E_ \= ''{_Ai_ |Drop(Pred(_Ai_ )) Λ Drop(_Ai_ ) Λ Drop(Succ(_Ai_ ))}'' .

' '

其中，Drop(_Ai_ ) 表示苹果树 _Ai_ 是否发生苹果掉落的情况，Pred(_Ai_ ) 表示 _Ai_ 的前一棵树 _Ai_\- 1（如果 _i_ \> 1）或者 _AN_（如果 _i_ \= 1），Succ(_Ai_ ) 表示 _Ai_ 的后一棵树 _Ai_+1（如果 _i_ < _N_） 或者 _A_1 （如果 _i_ \= _N_）。

【样例 1 输入】

4

4 74 -7 -12 -5

5 73 -8 -6 59 -4

5 76 -5 -10 60 -2

5 80 -6 -15 59 0

【样例 1 输出】

222 1 0

【样例 1 解释】

全部操作结束后，第 1 棵树上剩下的苹果个数为 74 - 7 - 12 - 5 = 50，第 2 棵为 59-4 = 55，第 3 棵为 60-2 = 58，第 4 棵为 59-0 = 59。因此 _T_ \= 50+55+58+59 = 222。

其中，第 3 棵树在第 2 次统计之前剩下的苹果个数为 76 - 5 - 10 = 61 > 60，因此 发生了苹果掉落的情况。可以检验其他的树没有这种情况，因此 _D_ \= 1。

没有连续三棵树都发生苹果掉落的情况，因此 _E_ \= 0。

【样例 2 输入】

5

4 10 0 9 0

4 10 -2 7 0

2 10 0

4 10 -3 5 0

4 10 -1 8 0

【样例 2 输出】

39 4 2

【样例 2 解释】

第 1 、2 、4 、5 棵树发生了苹果掉落的情况， 因此 _D_ \= 4。其中，连续三棵树都发 生苹果掉落情况的有 (5, 1, 2) 和 (4, 5, 1)，因此 _E_ \= 2。

【子任务】

|     |     |     |
| --- | --- | --- |
| 测试点 | _N_ | max{_mi_ } |
| 1, 2 | 3   | 2   |
| 3, 4 | 10  | 10  |
| 5, 6 | 10  | 100 |
| 7, 8 | 100 | 100 |
| 9, 10 | 1000 | 1000 |

• _mi_ ≤ 1000，对所有 1 ≤ _i_ ≤ _N_

• |_aij_ | ≤ 106 ，对所有 1 ≤ _i_ ≤ _N_, 1 ≤ _j_ ≤ _mi_

【提示】

• 如果你的程序没有实现统计 _D_ 和 _E_ 的功能，请按照 _D_ \= 0, _E_ \= 0 输出结果，这 样如果 _T_ 的统计正确能够得到一部分分数。

• 如果你的程序没有实现统计 _E_ 的功能，请按照 _E_ \= 0 输出结果，这样如果 _T_ 和 _D_ 的统计正确能够得到一部分分数。

字符画（asciiart）

【题目背景】

君君是个喜欢旅行的女孩子， 世界那么大，她哪里都想去看看。这个暑假， 她踏遍 了大江南北，感慨于祖国幅员的辽阔。开学了， 君君打算整理一下最近拍的照片， 却发 现自己电脑上 Linux 的图形界面似乎罢工了。面对着终端里不断闪动的光标，她灵机 一动......

【题目描述】

本题中，你需要将图片转换为终端中可以显示的字符画。

你将得到一张 24 位图片，这意味着其中的像素表示为 RGB 三原色的形式，而每 种颜色的取值范围为 0 到 255（一个字节），因此每个像素占用的空间为 24 比特。你需 要这张图片分割为指定数量的块。对于每一块，你需要计算所有像素的三个颜色分量的 平均值，并输出对应颜色的字符形成字符画。

. . .

为了在终端中输出彩色的字符， 你需要使用特殊的转义序列。在目前通行的终端规 范中，与颜色相关的转义序列包括：

• ESC \[ 38; 2; R; G; B m 更改终端的前景色（字符的颜色）为 (_R_, _G_, _B_)

• ESC \[ 48; 2; R; G; B m 更改终端的背景色（未被字符遮盖处的颜色）为 (_R_, _G_, _B_)

• ESC \[ 0 m 重置终端的颜色状态为默认值（前景色为白色 (255, 255, 255)，背景 色为黑色 (0, 0, 0)）

你只需要在输出中加入这些转义序列， 就能够控制终端中显示的字符颜色。在书写 转义序列时，有以下注意事项：

• 所有空格都是为了方便辨认而添加的， 不需要出现在实际的转义序列输出中

. . . . .

• ESC 不是字面上的三个字符，而是 ASCII 序号为 27 （八进制表示为 033） 的

. . . . . . . . . .

一个字符，代表转义序列的开始。在 C/C++/Java/Python 中，你都可以使用 \\033 或 \\x1b 来在字符串中使用这个字符。

• 每个颜色分量的值需要在 0 到 255 的范围内

• 对终端状态的更改在当前转义序列结束（即最后的 m 字符）后立刻生效，直到 下一个序列再次改变状态为止

为了更方便理解，我们给出一个例子（为了显示效果而分行，实际输出时为一行）：

. . .

\\033\[38;2;255;0;0mHello\\033\[0m \\033\[38;2;0;0;255m

\\033\[48;2;255;255;255mWorld\\033\[0m\\n

当这个字符串被输出到终端中，你将会看到类似下面的效果：

特别需要注意的是， 在程序完成输出后， 应该主动恢复终端的颜色状态， 否则可能 让之后运行的程序表现异常。

【输入格式】

从标准输入读入数据。

输入的第一行为两个整数 _m_, _n_，分别表示图片的宽和高。第二行为两个整数 _p_, _q_， 分别表示每一小块的宽和高。保证 _p_ 整除 _m_，并且 _q_ 整除 _n_，也就是说图片总是能被 分割成整数块。

接下来共有 _m_ × _n_ 行，每一行是图片中的一个像素，按照从左到右、从上到下的顺 序列出。每个像素的颜色以 HTML 颜色代码的形式表示， 格式为 #abcdef，表示该像 素的 R 、G 、B 三个分量分别是 (0xab, 0xcd, 0xef)（注意为 **16** 进制）。此外，为 了使得表达简洁，#aabbcc 可以被缩写为 #abc，#aaaaaa 可以被缩写为 #a，你需要 处理这些情况。

【输出格式】

输出到标准输出。

输出包含两部分，每一个输出中应该有恰好 (_mn_)/(_pq_) 个空格（ ' '）以及 _n_/_q_ 个 换行符（ '\\n'），和若干个转义序列。空格用于绘制色块（呈现出的即为其背景色），转 义序列用于改变颜色。每一个色块都由 _p_ × _q_ 个像素组成， 其三个颜色分量值分别是对 应区域中所有像素该分量值的平均值（除法向零取整即可）。

. . . .

由于正确的答案显然不止一种，为了方便判定，我们有以下的约定：

• 初始时终端的前景色和背景色都为默认值（前景白色，背景黑色）

• 减少控制序列的冗余，这包含以下的情况：

**–** 如果下一个字符的颜色刚好与默认值完全相同，你应当直接使用重置转义 序列，而非手动更改颜色

**–** 如果某个字符的前景色/背景色与其前一个字符相同，或者对颜色的更改并 不影响最终显示效果，则不应该出现更改这个属性的控制序列

• 在输出每一行字符后，如果终端颜色不是默认值，你应该重置终端的颜色状态 为了便于观察和评测， 你需要将输出中的所有字符转换为 **ASCII** 编码转义后的格

. . . . . . . . . . . . . . . . . . .

式再进行输出。即， 如果某个字符的 16 进制编码是 0xAB，则你应该在输出文件中写

. . . . . .

入 \\xAB，注意大小写。所有的字符都需要被转义（包括空格、换行等空白字符）；所有

. . . . . . . .

字符的转义序列顺序输出， 不需要任何形式的分隔符号； 在输出所有的转义序列后， 不 需要写入换行符。也就是说， 最终的输出文件只有一行，并且其中所有内容都是原本输

. . . .

出字符的 ASCII 转义序列。

如果你使用的是 Linux 系统，你可以在终端中运行如下的命令查看输出文件的真 实显示效果（其中 1.out 是文件名）：

echo -ne $(cat 1.out)

【样例 1 输入】

1 1

1 1

#010203

【样例 1 输出】

\\x1B\\x5B\\x34\\x38\\x3B\\x32\\x3B\\x31\\x3B\\x32\\x3B

\\x33\\x6D\\x20\\x1B\\x5B\\x30\\x6D\\x0A

注意上面的换行是由于排版限制而添加的，实际输出中无需也不能换行。

. . . . . . .

【样例 1 解释】

输入文件图片大小为 1 × 1，要求的色块大小为 1 × 1，因此原样输出即可。在输出 后需要重置背景色。

【样例 2 输入】

2 2

1 2

#111111

#0

#000000

#111

【样例 2 输出】

\\x1B\\x5B\\x34\\x38\\x3B\\x32\\x3B\\x38\\x3B\\x38\\x3B

\\x38\\x6D\\x20\\x20\\x1B\\x5B\\x30\\x6D\\x0A

此处的换行同样是由于排版限制添加的。

【样例 2 解释】

输入文件图片大小为 2 × 2，要求的色块大小为 1 × 2 ，因此将被切为两个色块。

第一个色块的颜色是左侧两个像素的平均值，三个颜色分量为 (8, 8, 8)；第二个色 块同理，计算得到的颜色分量相同。因此最终只需要更改一次终端的背景色， 并输出两 个空格用于显示即可。

【子任务】

|     |     |     |     |
| --- | --- | --- | --- |
| 测试点 | _m_ | _n_ | _p_ \= 1, _q_ \= 2 |
| 1, 2 | ≤ 10 | ≤ 10 | 是   |
| 3, 4 | ≤ 102 | ≤ 102 | 否   |
| 5, 6 | ≤ 640 | ≤ 640 |
| 7, 8 | ≤ 800 | ≤ 800 |
| 9, 10 | ≤ 1, 920 | ≤ 1, 080 |

推荐系统（recommend）

【题目描述】

某电商有编号为 0 到 _m_ \- 1 的 _m_ 类商品，包括家电、汽车、电动车、面包、化妆品 等。对于每个 app 新用户，每类商品初始有编号不同的 _n_ 个商品，包括各个商家、品 牌、供应商等。在任何时刻， 同类的任意两个商品的编号各不相同， 不同类的任意两个

. . .

商品的编号可能相同。app 会给每个商品打分。初始时，各类商品的编号和得分都相

. .

同。在用户使用 app 时，会产生有效信息，包括喜欢、不喜欢等。app 会根据这些信 息，在某类商品增加或删除商品。app 每次会推荐一部分商品给用户看。 一个简单的想

. . . .

法是，选出各类所有商品中得分最大的若干商品。

该方法虽然简单，但是如果某类商品可能得分特别高， 这种简单想法就无法保证推 荐商品的多样性。因此， app 查询得分最大的若干商品， 同时限制各类商品个数不能超 过一个阈值。将上述过程抽象成 3 中操作：操作 1 、2 、3，分别对应增加、删除、查询 操作：

1 type commodity score 表示在 type 类商品中增加编号为 commodity 的商 品，该商品分数为 score。

2 type commodity 表示在 type 类商品中删除编号为 commodity 的商品。

3 K k_0 k_1 ... k_{m-1} 表示在各类所有商品中选出不超过 K 个（不一定要 达到 K 个）得分最大的商品， 同时第 _i_(0 ≤ _i_ < _m_) 类商品的个数不超过 k_i。在查询时， 如果第 _a_(0 ≤ _a_ < _m_) 类商品中编号为 _b_ 的商品和第 _A_(0 ≤ _A_ < _m_) 类商品中编号为 _B_ 的 商品得分相同：

1\. 当 _a_ \= _A_ 时，选取编号为 min(_b_, _B_) 的商品；

2\. 当 _a_ ≠ _A_ 时，选取第 min(_a_, _A_) 类商品。

【输入格式】

从标准输入读入数据。

输入的第一行包含两个正整数 _m_ 和 _n_，保证 _n_ ≤ 3 × 104 和 _m_ ≤ 50。

接下来 _n_ 行，每行两个正整数 _id_ 和 _score_。第 1 + _j_(1 ≤ _j_ ≤ _n_) 行表示所有 _m_ 类商 品的第 _j_ 个商品的编号和得分。

接下来一行包含一个正整数 _opnum_ ，表示操作总数， 保证 _n_ ≤ 105。其中， 查询操作 一共有 _opask_ 个，保证 _opask_ ≤ 102。

接下来 _opnum_ 行，每行若干个正整数， 格式对应 1 type commodity score、2 type commodity、3 K k_0 k_1 ... k_{m-1}。其中，K ≤ 102，k_0 k_1 ... k_{m-1} ≤ 105。

【输出格式】

输出到标准输出。

输出共 _opask_ × _m_，对应 _opask_ 个查询操作。第 _r_ × _m_ \+ _c_, 0 ≤ _r_ < _opask_ , 1 ≤ _c_ ≤ _m_ 行 表示，在第 _r_ 个查询操作中，第 _c_ 类商品选出的商品编号， 同类商品的编号从小到大 输出。如果 _r_ 个查询操作中，第 _c_ 类商品没有选出任何商品，则该行输出 -1。

【样例 1 输入】

2 3

1 3

2 2

3 1

8

3 100 1 1

1 0 4 3

1 0 5 1

3 10 2 2

3 10 1 1

2 0 1

3 2 1 1

3 1 1 1

【样例 1 输出】

1

1

1 4

1 2

1

1

4

1

4

\-1

【子任务】

|     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 测试点 | _m_ ≤ | _n_ ≤ | _opnum_ ≤ | _opask_ ≤ | _K_ ≤ | _ki_ ≤ | _id_ | _score_ |
| 1   | 1   | 103 | 103 | 102 | 102 | 105 | 109 | 109 |
| 2   | 10  | 104 | 105 | 10  |
| 3, 4 | 20  | 2 × 104 | 102 |
| 5, 6 | 30  | 50  |
| 7, 8 | 40  | 3 × 104 | 102 |
| 9, 10 | 50  |

城市规划（tree）

【题目描述】

有一座城市，城市中有 _N_ 个公交站，公交站之间通过 _N_ \- 1 条道路连接，每条道 路有相应的长度。保证所有公交站两两之间能够通过一唯一的通路互相达到。

两个公交站之间路径长度定义为两个公交站之间路径上所有边的边权和。

现在要对城市进行规划，将其中 _M_ 个公交站定为“重要的”。

现在想从中选出 _K_ 个节点，使得这 _K_ 个公交站两两之间路径长度总和最小。输出 路径长度总和即可（节点编号从 1 开始）。

【输入格式】

从标准输入读入数据。

第 1 行包含三个正整数 _N_ ，_M_ 和 _K_ 分别表示树的节点数， 重要的节点数， 需要选 出的节点数。

第 2 行包含 _M_ 个正整数，表示 _M_ 个重要的节点的节点编号。

接下来 _N_ \- 1 行，每行包含三个正整数 _a_ ，_b_ ，_c_，表示编号为 _a_ 的节点与编号为 _b_ 的节点之间有一条权值为 _c_ 的无向边。每行中相邻两个数之间用一个空格分隔。

【输出格式】

输出到标准输出。

输出只有一行，包含一个整数表示路径长度总和的最小值。

【样例输入】

5 3 2

1 3 5

1 2 4

1 3 5

1 4 3

4 5 1

【样例输出】

4

【样例解释】

样例中的树如上图所示。

重要的节点标号为 1 ，3 ，5 ，从中选出两个点，有三种方案： 方案 1 ：1 ，3 之间路径长度为 5

方案 2：1 ，5 之间路径长度为 4

方案 3 ：3 ，5 之间路径长度为 9

【子任务】

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| 测试点 | _N_ | _M_ | _K_ | _c_ |
| 1, 2 | ≤ 2, 000 | ≤ 2, 000 | ≤ 2 | ≤ 105 |
| 3, 4 | ≤ 5 × 104 | ≤ 16 | ≤ 16 |
| 5, 6, 7 | ≤ 2, 000 | ≤ 2, 000 | ≤ 102 |
| 8, 9, 10 | ≤ 5 × 104 | ≤ 104 |

对于所有的数据， 1 ≤ _a_, _b_ ≤ _N_ ，_M_ ≤ _N_ ，_K_ ≤ _M_