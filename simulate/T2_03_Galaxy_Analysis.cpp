/*
* 3. 银河解析
【问题描述】

宇宙第一天才骇客银狼小姐向全银河喊话：有意愿与银狼对决的骇客诸君，请在任何候任何地点向银狼发起网络进攻，银狼愿意随时应战。作为一个骇客，你也收到了银狼发出的奇怪代码，你需要按照规则解密这些代码，翻译成文字信息，以下是其解析规则：

该代码应为一连串的二进制码，每八个字符为一单元。

一、若前三个字符为101时表示需要转换为字母A-Z。字母A代码为10100000，字母C为10100010，26个大写字母以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。

二、若前三个字符为111，则该单元翻译为空格。

三、若第一个字符为0，则该单元表示一个数，待定与下一个单元所表示的数做加法。加法过程中，这两个单元应转换为十进制，然后除以2并舍弃余数才相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果，翻译结果用十进制表示，这两个单元就都翻译完毕了。

众所周知，银狼小姐十分调皮，她经常发送假代码，而假代码则不存在上述规则，如果是假代码，仅输出WA。

【输入形式】

输入仅一行，包含一串连续的代码（长度不超过114514个字符），中间不会出现空格，保证不出现空代码。

【输出形式】

输出仅一行，包含一个字符串，是二进制代码按照上述规则翻译后的文字信息。若该二进制代码中存在假代码信息，则只输出WA。

【样例输入】


10100000111000001010111110101000101001100000001000000010000000100000001010100000
【样例输出】

A PIG22A
【样例说明】
【评分标准】

【出题人】

拔尖班2022级周新城



 */
/*
题目：银河解析（按规则将二进制串解析为字符串）
----------------------------------------------------------------------
核心思路：
- 输入是一串二进制字符串，按每8位划分为一个单元进行解析。
- 分类规则：
  1) 若单元前三位为 "101"：该单元表示 A-Z 的某个字母。编码从 A=10100000 开始，按字母顺序递增，
     即字母索引等于该单元后5位的二进制值（范围需在 0..25 内，否则为假代码）。
  2) 若单元前三位为 "111"：表示一个空格字符。
  3) 若单元首位为 '0'：该单元表示“一个数”，需与下一个单元（也必须首位为 '0'）一起按如下规则翻译：
     - 将这两个 8 位二进制单元分别转为十进制整数 a、b；
     - 对各自进行整除 2（即 floor(a/2), floor(b/2)）；
     - 将两者相加，得到一个十进制数 S；
     - 输出 S 的十进制表示作为这两个单元共同的翻译结果。
- 若出现以下任一情况，判定为假代码（输出 "WA"）：
  - 输入长度不是 8 的倍数；
  - 出现非 '0'/'1' 的字符；
  - 单元不匹配任何规则（例如前三位为 "100" 或 "110" 等）；
  - 以 '0' 开头的数字单元没有成对出现，或其后一个单元不是以 '0' 开头；
  - 字母单元（"101"）的后 5 位表示的索引不在 0..25 范围。

正确性理由（关键性质）：
- 字母规则给定起始编码 A=10100000、C=10100010，说明“101xxxxx”的后 5 位按 0..25 对应 A..Z 递增；
- 空格规则明确为前三位 "111"；
- 数字规则严格要求首位为 '0'，并与下一数字单元组成一对进行转换与求和。

时间复杂度：
- 设输入长度为 L（L ≤ 114514），每 8 位一个单元，总单元数为 L/8。每个单元常数时间处理，整体 O(L)。

空间复杂度：
- 结果字符串与少量辅助变量，O(L/8)。

实现细节与健壮性：
- 严格检测非法输入并在首次发现时立即输出 "WA" 并返回；
- 对数字单元成对处理时，注意索引跨两个单元的步进。
*/

#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
using namespace std;

// 将从 s[pos..pos+7] 的 8 个 '0'/'1' 字符转换为 0..255 的整数
static inline bool readByte(const string& s, size_t pos, int& outVal) {
    if (pos + 8 > s.size()) return false;
    int v = 0;
    for (size_t i = 0; i < 8; ++i) {
        char c = s[pos + i];
        if (c != '0' && c != '1') return false;
        v = (v << 1) | (c - '0');
    }
    outVal = v;
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    if (!(cin >> s)) {
        // 按题意保证不出现空代码，这里容错；若无输入，判定为假代码
        cout << "WA\n";
        return 0;
    }

    // 1) 长度必须是 8 的倍数
    if (s.size() % 8 != 0) {
        cout << "WA\n";
        return 0;
    }

    // 2) 可选：校验全部字符为 '0' 或 '1'
    for (char c : s) {
        if (c != '0' && c != '1') {
            cout << "WA\n";
            return 0;
        }
    }

    string result;
    result.reserve(s.size() / 8); // 粗略预留

    // 逐单元解析
    for (size_t pos = 0; pos < s.size(); /* 手动步进 */) {
        // 当前单元的前三位/第一位
        // 已经保证 pos+7 存在
        char b7 = s[pos];         // 第一位
        char b6 = s[pos + 1];
        char b5 = s[pos + 2];

        if (b7 == '1') {
            // 分支：前三位为 101 -> 字母；前三位为 111 -> 空格；其余 -> 假代码
            if (b6 == '0' && b5 == '1') {
                // 字母 A-Z：取后 5 位作为索引（0..25）
                int idx = 0;
                for (int i = 3; i < 8; ++i) {
                    idx = (idx << 1) | (s[pos + i] - '0');
                }
                if (idx < 0 || idx > 25) {
                    cout << "WA\n";
                    return 0;
                }
                result.push_back(static_cast<char>('A' + idx));
                pos += 8;
            } else if (b6 == '1' && b5 == '1') {
                // 空格
                result.push_back(' ');
                pos += 8;
            } else {
                // 1xx 但不是 101/111
                cout << "WA\n";
                return 0;
            }
        } else if (b7 == '0') {
            // 数字对：当前单元与下一个单元都必须以 '0' 开头
            if (pos + 16 > s.size()) {
                // 没有下一个完整单元
                cout << "WA\n";
                return 0;
            }
            if (s[pos + 8] != '0') {
                // 下一个不是数字单元
                cout << "WA\n";
                return 0;
            }

            int a = 0, b = 0;
            if (!readByte(s, pos, a) || !readByte(s, pos + 8, b)) {
                cout << "WA\n";
                return 0;
            }
            // 按规则：各自除以 2 取整后相加
            int sum = (a / 2) + (b / 2);

            // 将十进制结果追加到输出（可能多位，如 "22"）
            result += to_string(sum);

            pos += 16; // 消耗两个单元
        } else {
            // 非 '0'/'1'，前面已过滤，这里理论不可达
            cout << "WA\n";
            return 0;
        }
    }

    cout << result << '\n';
    return 0;
}