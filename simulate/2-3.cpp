/*
* 3. 银河解析
【问题描述】

宇宙第一天才骇客银狼小姐向全银河喊话：有意愿与银狼对决的骇客诸君，请在任何候任何地点向银狼发起网络进攻，银狼愿意随时应战。作为一个骇客，你也收到了银狼发出的奇怪代码，你需要按照规则解密这些代码，翻译成文字信息，以下是其解析规则：

该代码应为一连串的二进制码，每八个字符为一单元。

一、若前三个字符为101时表示需要转换为字母A-Z。字母A代码为10100000，字母C为10100010，26个大写字母以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。

二、若前三个字符为111，则该单元翻译为空格。

三、若第一个字符为0，则该单元表示一个数，待定与下一个单元所表示的数做加法。加法过程中，这两个单元应转换为十进制，然后除以2并舍弃余数才相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果，翻译结果用十进制表示，这两个单元就都翻译完毕了。

众所周知，银狼小姐十分调皮，她经常发送假代码，而假代码则不存在上述规则，如果是假代码，仅输出WA。

【输入形式】

输入仅一行，包含一串连续的代码（长度不超过114514个字符），中间不会出现空格，保证不出现空代码。

【输出形式】

输出仅一行，包含一个字符串，是二进制代码按照上述规则翻译后的文字信息。若该二进制代码中存在假代码信息，则只输出WA。

【样例输入】


10100000111000001010111110101000101001100000001000000010000000100000001010100000
【样例输出】

A PIG22A
【样例说明】
【评分标准】

【出题人】

拔尖班2022级周新城



 */
/*
 * 核心思路:
 * 本题要求根据一套特定规则将二进制字符串解码为文本信息。
 * 1. 验证与分块: 首先，程序需要验证输入字符串的合法性，包括其长度是否为8的倍数，以及所有字符是否均为'0'或'1'。然后，以8个字符为一个“单元”进行迭代处理。
 * 2. 规则解析: 使用一个循环遍历所有单元，并根据每个单元的前缀进行分类处理：
 * - 前缀 "101": 这是字母单元。提取其后的5位二进制数，转换为十进制索引 `val`。若 `val` 在 [0, 25] 区间内，则对应为大写字母 'A' + `val`。超出此范围则为非法代码。
 * - 前缀 "111": 这是空格单元。直接在结果中追加一个空格。
 * - 前缀 "0": 这是加法单元。此规则涉及当前单元和紧随其后的下一个单元。程序需要检查是否存在下一个单元，然后将这两个单元都视为8位二进制数，转换为十进制 `num1` 和 `num2`。计算 `(num1 / 2) + (num2 / 2)`，并将结果的十进制字符串形式追加到最终输出中。处理完后，必须跳过下一个单元，因此循环计数器额外增加8。
 * 3. 错误处理: 在整个解析流程中，任何不符合上述规则的情况（如无效前缀、加法单元后没有跟随单元、字母索引越界等）都将导致解析失败。程序通过一个布尔标志位追踪解析状态，一旦发生错误，立即中断循环。
 * 4. 输出: 循环结束后，根据标志位的状态，如果解析全程无误，则输出最终拼接的字符串；否则，输出"WA"。
 *
 * 时间复杂度: O(L)
 * 其中 L 是输入二进制字符串的长度。程序只需要对字符串进行一次完整的线性扫描即可完成解码。
 *
 * 空间复杂度: O(L)
 * 在最坏的情况下，解码后的输出字符串长度可能与输入字符串长度在同一数量级，因此需要O(L)的空间来存储结果。
 */

#include <iostream> // 用于标准输入输出
#include <string>   // 用于字符串操作
#include <vector>   // 包含常用的容器

// 使用标准命名空间，简化代码
using namespace std;

// 主解决函数
void solve() {
    string binaryCode;
    cin >> binaryCode;

    // 预先检查：输入字符串的长度必须是8的倍数
    if (binaryCode.length() % 8 != 0) {
        cout << "WA" << endl;
        return;
    }

    string result = ""; // 用于存储解码后的结果
    bool isValid = true;  // 标志位，用于追踪解码过程是否一直合法

    // 以8个字符为步长遍历整个二进制码
    for (int i = 0; i < int(binaryCode.length()); i += 8) {
        // 提取当前处理的8位单元
        string unit = binaryCode.substr(i, 8);

        // 检查单元内是否包含非二进制字符
        for (char c : unit) {
            if (c != '0' && c != '1') {
                isValid = false;
                break;
            }
        }
        if (!isValid) {
            break; // 如果发现非法字符，立即中断循环
        }

        // 根据规则进行解析
        if (unit.substr(0, 3) == "101") {
            // 规则一：转换为字母
            string valuePart = unit.substr(3, 5);
            int charIndex = stoi(valuePart, nullptr, 2); // 将5位二进制转换为整数

            // 检查转换后的索引是否在 A-Z (0-25) 的有效范围内
            if (charIndex >= 0 && charIndex <= 25) {
                result += (char)('A' + charIndex);
            } else {
                isValid = false; // 索引越界，标记为非法
                break;
            }
        } else if (unit.substr(0, 3) == "111") {
            // 规则二：转换为空格
            result += ' ';
        } else if (unit[0] == '0') {
            // 规则三：加法操作
            // 检查是否存在下一个单元用于配对
            if (i + 8 >= int(binaryCode.length())) {
                isValid = false; // 这是最后一个单元，无法配对，非法
                break;
            }

            string nextUnit = binaryCode.substr(i + 8, 8);

            // 同样检查下一个单元的合法性
            for (char c : nextUnit) {
                if (c != '0' && c != '1') {
                    isValid = false;
                    break;
                }
            }
            if (!isValid) {
                break;
            }

            // 将两个单元的二进制码转换为十进制数
            int num1 = stoi(unit, nullptr, 2);
            int num2 = stoi(nextUnit, nullptr, 2);

            // 计算 "(num1 / 2) + (num2 / 2)" 并追加到结果
            int sumResult = (num1 / 2) + (num2 / 2);
            result += to_string(sumResult);

            // 因为已经处理了两个单元，所以循环计数器需要额外跳过下一个单元
            i += 8;
        } else {
            // 不符合任何已知规则前缀，视为假代码
            isValid = false;
            break;
        }
    }

    // 根据解析过程是否一直有效来决定最终输出
    if (isValid) {
        cout << result << endl;
    } else {
        cout << "WA" << endl;
    }
}

int main() {
    // 优化C++标准流的输入输出速度，对大数据量输入有效
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 本题只有一组测试数据，直接调用解决函数
    solve();

    return 0;
}
